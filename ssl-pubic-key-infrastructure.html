<!doctype html>
<html lang="en">

<head>
  <!-- Required meta tags -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <title>  PKI, SSL/TLS, 인증서(Certificate), HTTPS | garret
</title>
  <link rel="canonical" href="https://imjang57.github.io/garret/ssl-pubic-key-infrastructure.html">


  <link rel="stylesheet" href="https://imjang57.github.io/garret/theme/css/bootstrap.min.css">
  <link rel="stylesheet" href="https://imjang57.github.io/garret/theme/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://imjang57.github.io/garret/theme/css/pygments/default.min.css">
  <link rel="stylesheet" href="https://imjang57.github.io/garret/theme/css/theme.css">

  <link rel="alternate" type="application/atom+xml" title="Full Atom Feed"
        href="https://imjang57.github.io/garret/feeds/all.atom.xml">
  <link rel="alternate" type="application/atom+xml" title="Categories Atom Feed"
        href="https://imjang57.github.io/garret/feeds/engineering.atom.xml">  
  <meta name="description" content="PKI, SSL/TLS, 인증서, HTTPS 등 인터넷 상의 보안과 인증이 어떤 원리로 동작하는지에 대한 설명">
  <script>
    (function(i, s, o, g, r, a, m) {
      i['GoogleAnalyticsObject'] = r;
      i[r] = i[r] || function() {
        (i[r].q = i[r].q || []).push(arguments)
      }, i[r].l = 1 * new Date();
      a = s.createElement(o);
      a.async = 1;
      a.src = g;
      m = s.getElementsByTagName(o)[0];
      m.parentNode.insertBefore(a, m)
    })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
    ga('create', 'UA-90095241-1', 'auto');
    ga('send', 'pageview');
  </script>


</head>

<body>
  <header class="header">
    <div class="container">
<div class="row">
  <div class="col-sm-12">
    <h1 class="title"><a href="https://imjang57.github.io/garret/">garret</a></h1>
      <ul class="list-inline">
          <li class="list-inline-item"><a href="https://github.com/imjang57" target="_blank">Github</a></li>
          <li class="list-inline-item"><a href="https://github.com/imjang57/garret" target="_blank">Github site repo</a></li>
          <li class="list-inline-item"><a href="#" target="_blank">Site</a></li>
              <li class="list-inline-item text-muted">|</li>
            <li class="list-inline-item"><a href="https://imjang57.github.io/garret/pages/about.html">About</a></li>
      </ul>
  </div>
</div>    </div>
  </header>

  <div class="main">
    <div class="container">
      <h1>  PKI, SSL/TLS, 인증서(Certificate), HTTPS
</h1>
      <hr>
  <article class="article">
    <header>
      <ul class="list-inline">
        <li class="list-inline-item text-muted" title="2017-11-01T00:00:00+09:00">
          <i class="fa fa-clock-o"></i>
          Wed 01 November 2017
        </li>
        <li class="list-inline-item">
          <i class="fa fa-folder-open-o"></i>
          <a href="https://imjang57.github.io/garret/category/engineering.html">engineering</a>
        </li>
          <li class="list-inline-item">
            <i class="fa fa-files-o"></i>
              <a href="https://imjang57.github.io/garret/tag/ssl.html">#ssl</a>,               <a href="https://imjang57.github.io/garret/tag/tls.html">#tls</a>,               <a href="https://imjang57.github.io/garret/tag/certificate.html">#certificate</a>,               <a href="https://imjang57.github.io/garret/tag/https.html">#https</a>          </li>
      </ul>
    </header>
    <div class="content">
      <h1>암호화 (Encryption) : SSL and TLS</h1>
<p>TCP/IP 로 패킷(Packet)들이 전송될 때 인터넷 상의 수많은 라우터와 노드들을 지나가게 된다. 그리고 이들 중 어떤 노드에서는 패킷 감청(Package Sniffing)을 하기도 하는데, 암호화가 되어있지 않은 패킷들은 이러한 감청에 속수무책으로 당할 수 밖에 없다. 감청을 통해 정보를 훔치는 것 외에 가로챈 패킷을 변조할 수도 있다. 그래서 이를 막기 위해 네트웍(Network) 상에서 흐르는 패킷들을 암호화하는 기술들이 등장했고 TCP/IP Layer 와 Application Layer 사이에서 데이터를 암호화하는 SSL(Secure Sockets Layer)가 등장했다.</p>
<p>SSL은 현재에는 TLS(Transport Layer Security)로 이름이 바뀌었지만 많은 사람들이 아직도 SSL이라는 이름을 많이 사용하고 있다. 그래서 보통 SSL/TLS 등과 같이 표기를 많이 한다. 즉, SSL과 TLS는 같은 녀석이다.</p>
<h2>인코딩과 디코딩 (Encoding and Decoding)</h2>
<p>정보의 형태를 임의로 변환하는 것을 인코딩(Encoding)이라고 한다. 그리고 인코딩된 정보를 다시 원래대로 되돌리는 것을 디코딩(Decoding)이라고 한다.</p>
<p>인코딩의 방법에 따라 디코딩이 될 수도 있고 안될 수도 있다. 예를 들어 가장 기초적인 인코딩 방법인 Base64는 쉽게 원래의 데이터로 디코딩할 수 있지만 해싱(Hashing)은 서로 다른 정보도 같은 값으로 인코딩될 수 있기 때문에 디코딩이 불가능하다.</p>
<h2>Base64</h2>
<p>Base64는 8 bits 바이너리 데이터(Binary data)를 문자 코드에 영향을 받지 않는 공통 ASCII 문자들로만 이루어진 문자열로 바꾸는 인코딩 방식이다. Base 64 라는 단어를 글자 그대로 번역하여 보면 64진법이란 뜻이다. 64가 2의 제곱수(64 = 2^6)이며, 2의 제곱수들에 기반한 진법들 중에서 화면에 표시되는 ASCII 문자들을 써서 표현할 수 있는 가장 큰 진법이기 때문에 Base64라는 이름이 되었다.</p>
<p>Base 64에는 어떤 문자와 기호를 쓰느냐에 따라 여러 변종이 있지만, 잘 알려진 것은 모두 처음 62개는 알파벳 A-Z, a-z와 0-9를 사용하고 있으며 마지막 두 개를 어떤 기호를 쓰느냐의 차이만 있다.</p>
<p>베이스64의 정확한 규격은 <a href="https://tools.ietf.org/html/rfc1421">RFC 1421</a>, <a href="https://tools.ietf.org/html/rfc2045">RFC 2045</a>에 정의된다. 연속된 8 bits 단위로 인코딩하도록 정의되어 있으며, 이는 대부분 시스템에서 파일의 정의와 들어맞는다. 베이스64코딩을 거친 결과물은 원본보다 대략 4/3 정도 크기가 늘어나게 되며, 보통 의미없어 보이는 문자열이 나열된 형태가 된다.</p>
<p>데이터를 베이스64로 바꾸는 과정은 다음과 같다. 우선 24 bits 버퍼에 위쪽(MSB)부터 한 바이트(byte)씩 3 바이트를 집어넣는다. 그리고 남은 바이트가 3 바이트 미만이라면, 버퍼의 남은 부분은 0으로 채워넣게 된다. 그리고, 버퍼의 위쪽부터 6 bits씩 잘라 그 값을 읽어, 다음에 정렬된 64개 "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"의 문자 중에서 읽은 값 번째 문자를 골라 출력한다. 만약 입력된 바이트가 하나라면 출력 중 두 개만이 사용되고 나머지 둘은 "="으로 패딩되며, 입력된 바이트가 둘이라면 출력 중 세 개 만이 사용되고 나머지 하나는 "="으로 패딩되게 된다. 이것은 원본으로 되돌릴 때 원본에는 없던 비트가 생기는 것을 방지하기 위함이다. 이 과정은 입력 데이터가 끝날 때까지 반복하면 인코딩이 된다.</p>
<p>예를 들어 아래의 문장이 있다고 하자.</p>
<p>Man is distinguished, not only by his reason, but by this singular passion from other animals, which is a lust of the mind, that by a perseverance of delight in the continued and indefatigable generation of knowledge, exceeds the short vehemence of any carnal pleasure.</p>
<p>이를 Base64로 인코딩하면 다음과 같다.</p>
<div class="highlight"><pre><span></span>TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0
aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1
c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0
aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdl
LCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=
</pre></div>


<p>이렇게 특정한 패턴으로 인코딩 및 디코딩하는 것이 가장 기초적인 방법이다.</p>
<h2>암호화와 복호화 (Encryption and Decryption)</h2>
<p>위의 특정한 패턴을 이용한 인코딩/디코딩 방법은 패턴이 파악될 경우 의미가 없어진다. 실제로 2차 세계대전이 발생했을 때 서로 적국의 통신 내용을 파악하기 위해 패턴으로 암호화된 내용을 도청하여 인력을 투입하여 분석했었다. 그래서 매일 패턴을 바꿔가며 통신을 했었다.</p>
<p>보안을 위한 암호화/복호화에는 더 복잡하고 어려운 방법이 필요하다. 이를 위해 키(Key)를 이용한 방법이 사용된다. 현대에 암호화라고 하면 보통 이 키를 이용한 인코딩/디코딩 방법을 의미한다.</p>
<p>키를 이용한 암호화 방법에는 대칭키 암호화(Symmetric Key Encryption), 비대칭키 암호화(Asymmetric Key Encryption)이 있다. 키를 생성하는 방법은 매우 수학적 이론이 필요한 내용이므로 따로 자료를 찾아보고 여기서는 인코딩/디코딩으로 암호화되는 과정에 집중해서 보자.</p>
<h2>대칭키 암호화</h2>
<p>대칭키 암호화는 발신자와 수신자가 동일한 알고리즘과 키를 공유하는 방식이다. 이 방법을 사용해서 제대로 보안을 유지하려면 직접 만나서 대칭키를 전달받는 것이 가장 안전한 방법이지만 사람이 많아질 수록 번거로운 방법이 되며, 누군가 키를 유출했을 경우 속수무책으로 당할 수 있다. 키를 잘 관리한다면 충분히 안전할 수도 있지만, 사실 모두가 공개된 환경인 인터넷에서 대칭키를 어떻게 배포하느냐는 중요한 문제를 해결하지 못하면 사용할 수가 없는 방법이기도 하다.</p>
<h2>비대칭키 암호화</h2>
<p>공개키(Public Key)와 비밀키(Private Key)라고 불리는 두 가지 종류의 키를 사용하는 방식이다. 참고로 비밀키는 개인키라고도 불린다. 공개키로 암호화된 데이터는 비밀키로만 복호화가 되고, 비밀키로 암호화된 데이터는 공개키로만 복호화된다. 이러한 특성을 통해 비대칭키 암호화는 대칭키 안호화가 가지고 있던 고질적 문제(키를 어떻게 배포할 것인가)를 해결하였다.</p>
<p>수신자는 비밀키를 갖고 이를 절대 외부로 유출하지 않는다. 그리고 공개키를 인터넷에 공개하여 발신자가 가져갈 수 있도록 한다. 발신자는 인터넷에서 공개키를 가져간 후 공개키로 데이터를 암호화하여 수신자에게 전송한다. 수신자는 본인이 가진 비밀키로 데이터를 복호화한다. 공개키는 아무나 가져가도 암호화만 가능할 뿐 복호화를 할 수 없기 때문에 키의 배포 문제도 해결하면서 높은 보안성도 얻을 수 있다.</p>
<p>하지만 비대칭키 암호화는 대칭키 암호화 방법보다도 복잡한 수학적 이론을 사용하기 때문에 속도가 느리고 연산량이 많다. 때문에 보통 비대칭키 암호화 방식으로 둘만의 대칭키를 교환하고 실제 데이터 통신은 둘만 공유하는 대칭키를 이용하여 하는 경우가 많다.</p>
<p>보통 비대칭키 알고리즘이라고 하면 RSA 알고리즘을 말한다. RSA 알고리즘은 로널드 라이베스트(Ron Rivest), 아디 샤미르(Adi Shamir), 레너드 애들먼(Leonard Adleman)의 연구에 의해 체계화되었으며, RSA라는 이름은 이들 3명의 이름 앞글자를 딴 것이다.</p>
<h2>전자서명 (Digital Signature)</h2>
<p>전자서명은 인터넷 상에서 본인을 증빙하기 위한 방법이다. RSA 알고리즘을 이용하여 구현되었으며, 전자서명은 오프라인에서의 수기서명과 동일하다. 보통 인터넷 상에서 어떠한 파일을 배포하거나 서비스를 제공할 때 제공자가 본인이 배포한 것이 맞음을 증빙하고, 데이터가 변조되지 않았음을 증명하는 수단으로 사용된다.</p>
<p>예를 들어, 문서 내용을 A라고 하면 잘 알려진 Hash 함수인 SHA1 같은 함수 하나를 정해서 문서 A의 Hash 값을 구하고 이 Hash 값을, 보내는 사람의 비밀키로 암호화 한다. 이런 다음 이렇게 암호화된 Hash값을 원래 문서 A의 끝에 첨부하여 이 문서 전체를 받는 사람에게 보낸다.</p>
<p>받는 사람은 먼저 메시지가 오면 해쉬값을 뺀 앞부분의 문서에 대해 보내는 사람이 사용했던 Hash함수를 이용해 받은 문서의 Hash값을 구한다. 그 다음 문서 뒤에 달린 암호화된 Hash값을 보내는 사람의 공개키로 복호화한 다음 이 복호화된 Hash값을, 받은 문서의 Hash값과 비교하게된다. 이 두개의 Hash값이 동일한 값이면 서명이 올바른 것이고 값이 서로 다르거나 변환에 오류가 있으면 서명이 틀린 것이다.</p>
<h2>인증서 (Certificate)</h2>
<p>전자서명은 데이터가 제공자가 제공한 것이 맞고 변조되지 않았음을 보장해줄 수 있다. 하지만 데이터 제공자, 즉 공개키의 실제 소유자가 실제로 누군지를 증명해주지는 않는다. 그래서 인증서라는 개념이 등장하게 되었다.</p>
<p>인증서는 정부기관이나 은행 등 공인된 기관에서 발급받을 수 있다. 기관은 신청자에게 생성된 비밀키와 인증서를 제공해준다. 이때 받는 인증서에는 신청자에 대한 정보, 신청자의 공개키, 유효기간, 인증기관 정보, 인증서에 대한 인증기관의 전자서명 등이 포함되어 있다. 즉, 인증서는 공인된 인증기관이 인증서의 소유자에 대한 신원을 보증해주는 것이다. 그리고 이를 위해 세계적으로 몇몇 인증기관(CA, Certification Authority)들이 존재하고 있으며, 이렇게 비대칭키 암호화 방법을 기반으로 공개키와 인증서를 활용하는 환경을 공개키 기반 구조(PKI, Public Key Infrastructure)라고 한다. HTTPS, SFTP, SSH, SCP 등 현대에서 인터넷 상의 모든 보안 관련된 기능들은 모두 PKI 기반이라고 볼 수 있다.</p>
<p>인증기관은 범국제적인 PKI를 위해서 X.509라는 인증서의 국제 표준 규격을 따르고 있다. X.509 는 <a href="https://tools.ietf.org/html/rfc5280">RFC 5280</a>에 의해 정의되어 있다. X.509 규격에 따르면 인증서는 최상위 인증기관(Root CA)의 루트 인증서(Root Certificate)를 시작으로 하위 인증기관들의 인증서들이 존재하고 일반 사용자들의 인증서도 존재한다. 루트 인증서를 제공하는 최상위 인증기관은 하위 인증기관들을 인증하고, 하위 인증기관들은 다른 하위 인증기관 또는 일반 사용자들을 인증한다. 즉, 인증기관들의 인증서에는 상위 인증기관의 전자서명이 포함되어 있고, 일반 사용자들의 인증서에는 인증기관의 전자서명이 포함되어 있다. 예외적으로 루트 인증서만 자가서명(Self-signed)되어 있다. 그리고 이러한 PKI 기반 구조에서 사용자가 상위 인증서를 신뢰한다면 그 하위의 모든 인증서도 신뢰하는 것으로 받아들여 진다. 요즘의 시스템들은 모두 신뢰할 수 있는 CA 리스트를 갖고 있어서 이들 하위의 인증서들은 신뢰할 수 있다고 판단한다.</p>
<p>일반적으로 인증서는 인증기관에서 유료로 발급받을 수 있다. 인증기관들도 무료 자원봉사를 하는 것은 아니기 떄문에 인증 서비스를 위한 비용을 지불해야 한다. 한국에서는 한국인터넷진흥원(KISA)가 최상위 인증기관(Root CA)이 되는 별도의 PKI 시스템이 있지만, KISA가 아직 국제 최상위 인증기관(Root CA)의 인증을 받지 못해서 (병신같지만) 국내 인증기관(CA)에서 발급받은 인증서는 특정 웹 브라우저들에게는 신뢰받지 못할 수도 있다.</p>
<p>참고로 개인도 자가서명된 인증서(Self-signed certificate)를 가질 수 있다. <code>openssl</code> 등과 같이 SSL 규격을 구현한 프로그램들을 사용하여 생성할 수 있다. 단, 자가서명된 인증서를 사용하려면 시스템(운영체제, 가상머신 등)에 인증서를 추가하는 작업을 별도로 해야 한다.</p>
<p>2016년에는 Mozilla, Sisco, Akamai 등이 HTTPS의 보급을 위하여 <a href="https://letsencrypt.org">Let's Encrypt</a>라는 비영리 인증기관을 설립하고 무료로 인증서를 발급해주고 있다. 여기서 받은 인증서는 별도의 과정없이 신뢰할 수 있는 인증서로 사용될 수 있다.</p>
<h2>SSL/TLS</h2>
<p>SSL/TLS는 TCP Layer와 Application Layer 사이에서 비대칭키 암호화를 이용하여 데이터들을 암호화하여 감청을 방지하고, 전송하는 데이터에 전자서명을 첨부하여 변조를 방지하고, 인증서를 이용하여 서버에 대한 인증을 담당한다.</p>
<p>SSL Handshake :</p>
<ol>
<li>서버가 클라이언트에게 공개키가 포함되어 있는 인증서를 전달한다.</li>
<li>클라이언트는 신뢰하는 CA 리스트를 확인하여 서버의 인증서를 신뢰할 수 있는지 판단한다.</li>
<li>클라이언트는 대칭키를 생성하여 서버의 공개키로 암호화하여 서버에게 전달한다.</li>
<li>서버아 클라이언트는 대칭키를 이용하여 데이터를 주고받는다.</li>
</ol>
<h2>SSH (Secure SHell) and SSL/TLS</h2>
<p>SSH는 보안이 강화된 텔넷(Telnet)이라고 볼 수도 있다. 물론 SSH는 Port Forwarding 등 더 다양한 기능을 제공하고 쓰임새가 더 많지만 어찌되었든 본질은 보안이 강화된 텔넷과도 같다. 그리고 SSH도 보안을 위해 비대칭키 방식과 대칭키 방식을 SSL/TLS와 같은 방법으로 사용한다. 단지 키를 주고받는 메시지의 포맷이 다를 뿐이다. 위에서 언급한 것과 같이 SSL/TLS는 X.509 규격을 따르고 <code>openssl</code> 등과 같은 프로그램으로 인증서를 생성할 수 있다. SSH는 독자적인 포맷을 따르고 <code>ssh-keygen</code> 프로그램을 통해서 SSH Key 파일을 생성할 수 있다.</p>
<p>어찌되었든 SSH도 SSL/TLS와 똑같은 보안 체계이기 때문에 보안성이 높다. 그래서 보통 보안이 약한 네트웍 통신을 하게 될 경우 SSH Port Forwarding 기능을 통해 Tunneling하여 사용하기도 한다.</p>
    </div>
  </article>
    </div>
  </div>

  <footer class="footer">
    <div class="container">
<div class="row">
  <ul class="col-sm-6 list-inline">
    <li class="list-inline-item"><a href="https://imjang57.github.io/garret/archives.html">Archives</a></li>
    <li class="list-inline-item"><a href="https://imjang57.github.io/garret/categories.html">Categories</a></li>
      <li class="list-inline-item"><a href="https://imjang57.github.io/garret/tags.html">Tags</a></li>
  </ul>
  <p class="col-sm-6 text-sm-right text-muted">
    Generated by <a href="https://github.com/getpelican/pelican" target="_blank">Pelican</a>
    / <a href="https://github.com/nairobilug/pelican-alchemy" target="_blank">&#x2728;</a>
  </p>
</div>    </div>
  </footer>
</body>

</html>