<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>garret - dev-issues</title><link href="https://imjang57.github.io/garret/" rel="alternate"></link><link href="https://imjang57.github.io/garret/feeds/dev-issues.atom.xml" rel="self"></link><id>https://imjang57.github.io/garret/</id><updated>2017-01-18T00:00:00+09:00</updated><entry><title>NPE (NullPointerException) 을 피하자</title><link href="https://imjang57.github.io/garret/avoid-null-pointer-exception-in-java.html" rel="alternate"></link><published>2017-01-18T00:00:00+09:00</published><updated>2017-01-18T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-18:/garret/avoid-null-pointer-exception-in-java.html</id><summary type="html">&lt;p&gt;Java 에서 NPE (NullPointerException) 을 피하면서 코딩하기 위한 습관들&lt;/p&gt;</summary><content type="html">&lt;h1&gt;NPE(NullPointerException) 을 피하자.&lt;/h1&gt;
&lt;p&gt;자바 개발을 하다보면 가장 많이 만나고 영향이 큰 예외 중 하나가 &lt;em&gt;NPE&lt;/em&gt; 이다. NPE 는 개발자의 습관이나 부주의 등이 대부분 원인이다. 이를 예방하는 가장 좋은 방법은 NPE 를 피하는 코딩 습관을 갖는 것이다.&lt;/p&gt;
&lt;h2&gt;null 의 의미&lt;/h2&gt;
&lt;p&gt;자바에서 &lt;code&gt;null&lt;/code&gt; 이란 아래와 같은 상태를 의미한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;아직 object 가 생성되지 않은 상태, 즉 아직 memory 할당이 되지 않은 object 상태&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;NPE 는 null 상태인 object 를 참조하여 어떠한 행위(method 실행)를 하려할 때 발생하는 예외이다.&lt;/p&gt;
&lt;h2&gt;NPE가 발생하는 상황&lt;/h2&gt;
&lt;p&gt;NPE 는 아래와 같은 상황에서 발생할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;null object 의 method 를 호출&lt;/li&gt;
&lt;li&gt;null object 의 instance member 에 접근&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Avoid NPE in source code&lt;/h1&gt;
&lt;p&gt;NPE 는 대부분 개발자의 부주의로 발생하므로, 개발할 때 조금만 신경쓰면 대부분의 NPE 를 예방할 수 있다.&lt;/p&gt;
&lt;h2&gt;String 객체를 비교할 경우&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;equals()&lt;/code&gt;, &lt;code&gt;equalsIgnoreCase()&lt;/code&gt; 등을 사용할 때 null 이 아닌 것이 확실한 객체가 있다면 해당 객체의 method 를 호출하자.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt; &lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="n"&gt;Compare&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;equals&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;testStr&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
 &lt;span class="c1"&gt;// logic&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;String.valueOf() 사용&lt;/h2&gt;
&lt;p&gt;로그 등을 남길 때 객체의 상태를 확인하기 위해 객체의 &lt;code&gt;toString()&lt;/code&gt; 을 호출하는 경우가 있는데, 객체가 null 일 경우 NPE 가 발생한다. 로그를 위해 null 을 체크하는 로직을 추가하는 것은 불필요한 코드가 될 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;toString()&lt;/code&gt; method 보다는 &lt;code&gt;String.valueOf()&lt;/code&gt; 를 사용하자.&lt;/p&gt;
&lt;h2&gt;Primitive type 사용&lt;/h2&gt;
&lt;p&gt;꼭 필요한 경우가 아니라면 Primitive type data 를 사용하자. NPE 를 줄이고 memory 도 더 효율적으로 사용할 수 있다.&lt;/p&gt;
&lt;h2&gt;return empty collection&lt;/h2&gt;
&lt;p&gt;List, Set, Map 등과 같은 Collection 을 return 하는 method 를 구현할 때, null 을 return 하지 말자. 대신 empty collection 을 return 하자. 그러면 함수를 사용하는 개발자는 불필요한 null 체크를 하지 않아도 된다.&lt;/p&gt;
&lt;h2&gt;Use null-safe stuffs&lt;/h2&gt;
&lt;p&gt;null 에 안전한 자바 내장 함수나 commons-lang 과 같은 helper class 를 사용하자. Apache Commons 도 좋고, 요즘은 Googld guava 가 매우 유용한 라이브러리들을 많이 제공한다.&lt;/p&gt;
&lt;h2&gt;Unit Test&lt;/h2&gt;
&lt;p&gt;Java assert, Unit test (JUnit) 등을 활용하여 사전 확인 및 다양한 상황에서의 테스트를 수행하자.&lt;/p&gt;
&lt;h2&gt;협업할 때는 기능 및 제약사항 등을 확실히 명시하자.&lt;/h2&gt;
&lt;p&gt;NPE 는 개발자의 부주의에 의해 대부분 발생하고, 개발자의 부주의는 정보가 없어서 발생하는 경우가 많다. 아래의 내용들은 명확하게 공유하자.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Method parameter 와 return value 에 대한 명세&lt;/li&gt;
&lt;li&gt;Method 에서 수행하는 validation 으로 인해 발생가능한 Exception 들&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="https://github.com/google/guava"&gt;Google guava&lt;/a&gt; 의 &lt;em&gt;Preconditions&lt;/em&gt; 등을 사용하면 parameter 에 대한 validation 을 쉽게 처리할 수 있다.&lt;/p&gt;
&lt;p&gt;또한 &lt;em&gt;Java Doc&lt;/em&gt; 등의 문서를 적절히 사용하자. 자동으로 Java doc 을 생성해주는 프로그램도 많다. 또는 &lt;a href="http://swagger.io"&gt;swagger&lt;/a&gt; 등을 이용하여 RestAPI 서비스의 API 에 대한 명세를 공유할 수도 있다.&lt;/p&gt;
&lt;p&gt;문서의 내용을 자세하게 채우지 않아도 된다. 위의 내용들에 대해서만이라도 명확하게 작성하자.&lt;/p&gt;
&lt;h2&gt;Optional class&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Optional&lt;/em&gt; 을 사용하면 null check 를 위한 코드를 상당히 줄일 수 있으며 코드의 Readability 를 높일 수 있다.&lt;/p&gt;
&lt;p&gt;Optional 은 원래 google guava 라이브러리에서 제공되었었는데 java 8 로 버전 업하면서 자바에서도 지원(&lt;code&gt;java.util.Optional&amp;lt;T&amp;gt;&lt;/code&gt;)하게 되었다.&lt;/p&gt;
&lt;p&gt;Optional object 생성:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;nStr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="n"&gt;Test&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;Optional&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;eOp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Optional&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;empty&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// empty Optional 객체 생성&lt;/span&gt;
&lt;span class="n"&gt;Optional&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;nullableOp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Optional&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ofNullable&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nStr&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// null 을 허용하는 Optional 객체 생성&lt;/span&gt;
&lt;span class="n"&gt;Optional&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;notNullableOp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Optional&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;of&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// str 에 접근하는 시점이 아니라 Optional 객체를 생성하는 이 순간 parameter 의 null 여부를 체크하여 NPE 가 발생&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt; &lt;span class="n"&gt;notNullableOp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;isPresent&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
 &lt;span class="c1"&gt;// Optional 객체에 값이 있는지 확인 후 아래 코드를 실행&lt;/span&gt;
 &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;notNullableOp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;get&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;notNullableOp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ifPresent&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Optional 객체에 값이 있는지 확인 후 전달받은 function 을 실행&lt;/span&gt;
&lt;span class="n"&gt;notNullableOp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ifPresent&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;});&lt;/span&gt;
&lt;span class="n"&gt;nullableOp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ifPresent&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// null 이므로 실행되지 않는다.&lt;/span&gt;
&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;emtpyStr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;eOp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;orElse&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="n"&gt;Empty&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Optional 객체가 empty 일 경우 (null 일 경우) “Empty String” 의 reference 를 return.&lt;/span&gt;
&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;exStr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;eOp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;orElseThrow&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Exception&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Optional 객체가 empty 일 경우 (null 일 경우) 지정된 Exception 을 throw.&lt;/span&gt;
&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;notNullableOp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;filter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;length&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="na"&gt;orElse&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="n"&gt;Too&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Optional 과 map 을 이용하여 null check 없이 jsonNode 접근하기:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Optional&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;of&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rootNode&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
 &lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;map&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;get&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="n"&gt;secondNode&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
 &lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;map&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;get&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="n"&gt;thirdNode&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
 &lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ifPresent&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
 &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;get&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;
 &lt;span class="o"&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;if else 를 이용한 null 체크는 source code readability 를 떨어뜨린다. Optional 과 Java doc 을 이용한 직관적인 코드 작성을 하자.&lt;/p&gt;</content><category term="java"></category><category term="NPE"></category><category term="NullPointerException"></category><category term="null"></category></entry><entry><title>JVM Process monitoring with JDK tools</title><link href="https://imjang57.github.io/garret/jvm-process-monitoring-with-jdk-tools.html" rel="alternate"></link><published>2017-01-18T00:00:00+09:00</published><updated>2017-01-18T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-18:/garret/jvm-process-monitoring-with-jdk-tools.html</id><summary type="html">&lt;p&gt;JDK Tools 을 사용하여 JVM Process 를 모니터링하는 방법에 대한 소개&lt;/p&gt;</summary><content type="html">&lt;h1&gt;JVM Process monitoring&lt;/h1&gt;
&lt;p&gt;요즘 일 때문에 오랜만에 자바를 사용하고 있고, 스칼라에 관심이 생겨 공부해보고 있다. 그런데 둘다 &lt;em&gt;JVM&lt;/em&gt; 기반 언어다 보니 JVM 에 대해 알아야 겠다는 생각이 들었다. (사실 일하다가 JVM 모니터링 할 일이 생긴 김에 간단하게 정리한다.) 어쨌든 둘 다 JVM 에서 동작하는 녀석들이라 JVM 모니터링에 대해 간단하게 남겨보고자 한다.&lt;/p&gt;
&lt;p&gt;자바든 스칼라든 실행되면 JVM 프로세스이다. 자바나 스칼라로 쓰여진 코드는 Java Bytecode 로 컴파일되고, JVM 은 이 Bytecode 를 실행한다. 그러므로 컴파일 된 이후에는 자바로 작성했든 스칼라로 작성했든 JVM 입장에서는 그냥 똑같은 Bytecode 이다. 그러니 같은 방법(JVM Process monitoring)으로 모니터링할 수 있다.&lt;/p&gt;
&lt;h1&gt;JVM Monitoring tools&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;JDK (Java Development Kit)&lt;/em&gt; 를 설치하면 기본적으로 자바 코드를 컴파일하기 위한 &lt;code&gt;javac&lt;/code&gt;, 컴파일된 bytecode 를 실행하는 &lt;code&gt;java&lt;/code&gt; 를 제공한다. 그리고 개발자들을 위한 다양한 도구들을 기본적으로 제공한다. 모니터링을 위해서 아래 도구들을 사용가능하다.(물론 아래 도구들 외에 더 많다.)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;jps&lt;/code&gt; : JVM Process Status&lt;/li&gt;
&lt;li&gt;&lt;code&gt;jstat&lt;/code&gt; : JVM Statistics&lt;/li&gt;
&lt;li&gt;&lt;code&gt;jhat&lt;/code&gt; : Java Heap Analysis Tool&lt;/li&gt;
&lt;li&gt;&lt;code&gt;jstack&lt;/code&gt; : Java thread Stack traces&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;VisualVM&lt;/em&gt; 과 같은 GUI 도구도 있지만 어쨌든 기본은 CLI 도구들이고, GUI 도구들도 CLI 도구들을 이용하는 형태이다.&lt;/p&gt;
&lt;h1&gt;JVM Monitoring&lt;/h1&gt;
&lt;p&gt;JVM 프로세스를 모니터링하려면 당연히 JVM 프로세스가 있어야 한다. 테스트 프로그램은 임시로 tomcat 을 사용하였다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;yum install -y tomcat&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;passwd tomcat&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/etc/passwd&lt;/code&gt; 파일에서 tomcat 계정의 login shell 을 bash 로 지정&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sudo service tomcat start&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;tomcat 계정으로 전환(&lt;code&gt;su - tomcat&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;jps : JVM Process Status&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;jps&lt;/code&gt; 를 실행하면 JVM Process 목록과 PID 를 확인할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ jps
&lt;span class="m"&gt;17285&lt;/span&gt; Bootstrap
&lt;span class="m"&gt;17322&lt;/span&gt; Jps
$ jps -m
&lt;span class="m"&gt;17285&lt;/span&gt; Bootstrap start
&lt;span class="m"&gt;17398&lt;/span&gt; Jps -m
$ jps -ml
&lt;span class="m"&gt;17285&lt;/span&gt; org.apache.catalina.startup.Bootstrap start
&lt;span class="m"&gt;17413&lt;/span&gt; sun.tools.jps.Jps -ml
$
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;jstat: JVM Statistics&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;jps&lt;/code&gt; 에서 확인한 PID 로 &lt;code&gt;jstat&lt;/code&gt; 를 실행할 수 있다. 위에서 tomcat 을 실행하는 Bootstrap 의 PID 가 17285 이므로 이를 이용하여 &lt;code&gt;jstat&lt;/code&gt; 을 실행하였다. 그리고 1000 밀리초 단위로 통계치를 수집하도록 하였다. 결과는 퍼센트(%)로 출력된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ jstat -gcutil &lt;span class="m"&gt;17285&lt;/span&gt; 1000
  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT   
  0.00  98.44  60.41   5.27  96.61  89.46      &lt;span class="m"&gt;1&lt;/span&gt;    0.005     &lt;span class="m"&gt;0&lt;/span&gt;    0.000    0.005
  0.00  98.44  60.41   5.27  96.61  89.46      &lt;span class="m"&gt;1&lt;/span&gt;    0.005     &lt;span class="m"&gt;0&lt;/span&gt;    0.000    0.005
  0.00  98.44  60.41   5.27  96.61  89.46      &lt;span class="m"&gt;1&lt;/span&gt;    0.005     &lt;span class="m"&gt;0&lt;/span&gt;    0.000    0.005
  0.00  98.44  60.41   5.27  96.61  89.46      &lt;span class="m"&gt;1&lt;/span&gt;    0.005     &lt;span class="m"&gt;0&lt;/span&gt;    0.000    0.005
  0.00  98.44  60.41   5.27  96.61  89.46      &lt;span class="m"&gt;1&lt;/span&gt;    0.005     &lt;span class="m"&gt;0&lt;/span&gt;    0.000    0.005
$
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;위에서처럼 &lt;code&gt;-gcutil&lt;/code&gt; 옵션을 사용하면 Java Heap 현황을 확인할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;GCT&lt;/em&gt; : Garbage Collection Time (seconds, 누적)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;FGCT&lt;/em&gt; : Full GCT (seconds, 누적)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;FGC&lt;/em&gt; : Full Garbage Collection 발생 회수&lt;/li&gt;
&lt;li&gt;&lt;em&gt;M&lt;/em&gt; : Metaspace 영역의 사용률&lt;/li&gt;
&lt;li&gt;&lt;em&gt;S0&lt;/em&gt; : Survivor 0 영역의 사용률&lt;/li&gt;
&lt;li&gt;&lt;em&gt;S1&lt;/em&gt; : Survivor 1 영역의 사용률&lt;/li&gt;
&lt;li&gt;&lt;em&gt;E&lt;/em&gt; : Eden 영역의 사용률&lt;/li&gt;
&lt;li&gt;&lt;em&gt;O&lt;/em&gt; : Old 영역의 사용률&lt;/li&gt;
&lt;li&gt;&lt;em&gt;CCS&lt;/em&gt; : Compressed Class Space (part of metaspace)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;YGC&lt;/em&gt; : Young GC 발생 회수&lt;/li&gt;
&lt;li&gt;&lt;em&gt;YGCT&lt;/em&gt; : Young GC Time (seconds, 누적)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;FGCT 열의 값이 계속 증가하면 문제가 있는 것이다.&lt;/p&gt;
&lt;p&gt;M 열은 Metadata 를 위한 힙 영역이다. 이 영역은 자바8부터 M(Metaspace)로 표시되기 시작했고 이전 버전까지는 P(Permgen, Permanent Generation) 영역이라고 불리었다. 클래스의 Metadata, JVM 내부 객체 등이 저장되는 중요한 곳이다. 매우 무조건 자바 프로그램의 경우 이 영역에서 &lt;code&gt;java.lang.OutOfMemoryError&lt;/code&gt; 를 만날 수도 있다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-gcutil&lt;/code&gt; 대신 &lt;code&gt;-gccause&lt;/code&gt; 옵션을 사용하면 &lt;code&gt;-gcutil&lt;/code&gt; 의 결과에 GC 의 원인까지 확인할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ jstat -gccause &lt;span class="m"&gt;17285&lt;/span&gt; 1000
  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT    LGCC                 GCC                 
  0.00  98.44  61.41   5.27  96.61  89.46      &lt;span class="m"&gt;1&lt;/span&gt;    0.005     &lt;span class="m"&gt;0&lt;/span&gt;    0.000    0.005 Allocation Failure   No GC               
  0.00  98.44  61.41   5.27  96.61  89.46      &lt;span class="m"&gt;1&lt;/span&gt;    0.005     &lt;span class="m"&gt;0&lt;/span&gt;    0.000    0.005 Allocation Failure   No GC               
  0.00  98.44  61.41   5.27  96.61  89.46      &lt;span class="m"&gt;1&lt;/span&gt;    0.005     &lt;span class="m"&gt;0&lt;/span&gt;    0.000    0.005 Allocation Failure   No GC               
$
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;&lt;em&gt;LGCC&lt;/em&gt; : 지난 GC의 발생 이유&lt;/li&gt;
&lt;li&gt;&lt;em&gt;GCC&lt;/em&gt; : 현재 GC의 발생 이유&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;jstack: Java thread Stack traces&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;jstack&lt;/code&gt; 을 이용하면 현재 Java 프로세스의 stack dump 를 얻을 수 있다. &lt;code&gt;jstack&lt;/code&gt; 을 이용하면 현재 실행 중인 여러 thread 들의 stack 을 확인할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ jstack 17285
2016-12-26 10:32:20
Full thread dump OpenJDK 64-Bit Server VM &lt;span class="o"&gt;(&lt;/span&gt;25.111-b15 mixed mode&lt;span class="o"&gt;)&lt;/span&gt;:
&lt;span class="s2"&gt;&amp;quot;Attach Listener&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#17 daemon prio=9 os_prio=0 tid=0x00007f48d0001000 nid=0x458b waiting on condition [0x0000000000000000]&lt;/span&gt;
   java.lang.Thread.State: RUNNABLE
&lt;span class="s2"&gt;&amp;quot;ajp-bio-8009-AsyncTimeout&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#15 daemon prio=5 os_prio=0 tid=0x00007f491049c800 nid=0x43a9 waiting on condition [0x00007f48f8ba4000]&lt;/span&gt;
   java.lang.Thread.State: TIMED_WAITING &lt;span class="o"&gt;(&lt;/span&gt;sleeping&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.Thread.sleep&lt;span class="o"&gt;(&lt;/span&gt;Native Method&lt;span class="o"&gt;)&lt;/span&gt;
 at org.apache.tomcat.util.net.JIoEndpoint&lt;span class="nv"&gt;$AsyncTimeout&lt;/span&gt;.run&lt;span class="o"&gt;(&lt;/span&gt;JIoEndpoint.java:152&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.Thread.run&lt;span class="o"&gt;(&lt;/span&gt;Thread.java:745&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;ajp-bio-8009-Acceptor-0&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#14 daemon prio=5 os_prio=0 tid=0x00007f491049a000 nid=0x43a8 runnable [0x00007f48f8ca5000]&lt;/span&gt;
   java.lang.Thread.State: RUNNABLE
 at java.net.PlainSocketImpl.socketAccept&lt;span class="o"&gt;(&lt;/span&gt;Native Method&lt;span class="o"&gt;)&lt;/span&gt;
 at java.net.AbstractPlainSocketImpl.accept&lt;span class="o"&gt;(&lt;/span&gt;AbstractPlainSocketImpl.java:409&lt;span class="o"&gt;)&lt;/span&gt;
 at java.net.ServerSocket.implAccept&lt;span class="o"&gt;(&lt;/span&gt;ServerSocket.java:545&lt;span class="o"&gt;)&lt;/span&gt;
 at java.net.ServerSocket.accept&lt;span class="o"&gt;(&lt;/span&gt;ServerSocket.java:513&lt;span class="o"&gt;)&lt;/span&gt;
 at org.apache.tomcat.util.net.DefaultServerSocketFactory.acceptSocket&lt;span class="o"&gt;(&lt;/span&gt;DefaultServerSocketFactory.java:60&lt;span class="o"&gt;)&lt;/span&gt;
 at org.apache.tomcat.util.net.JIoEndpoint&lt;span class="nv"&gt;$Acceptor&lt;/span&gt;.run&lt;span class="o"&gt;(&lt;/span&gt;JIoEndpoint.java:222&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.Thread.run&lt;span class="o"&gt;(&lt;/span&gt;Thread.java:745&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;ContainerBackgroundProcessor[StandardEngine[Catalina]]&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#13 daemon prio=5 os_prio=0 tid=0x00007f4910497000 nid=0x43a7 waiting on condition [0x00007f48f8da6000]&lt;/span&gt;
   java.lang.Thread.State: TIMED_WAITING &lt;span class="o"&gt;(&lt;/span&gt;sleeping&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.Thread.sleep&lt;span class="o"&gt;(&lt;/span&gt;Native Method&lt;span class="o"&gt;)&lt;/span&gt;
 at org.apache.catalina.core.ContainerBase&lt;span class="nv"&gt;$ContainerBackgroundProcessor&lt;/span&gt;.run&lt;span class="o"&gt;(&lt;/span&gt;ContainerBase.java:1510&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.Thread.run&lt;span class="o"&gt;(&lt;/span&gt;Thread.java:745&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;GC Daemon&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#11 daemon prio=2 os_prio=0 tid=0x00007f491040c800 nid=0x43a5 in Object.wait() [0x00007f48fa637000]&lt;/span&gt;
   java.lang.Thread.State: TIMED_WAITING &lt;span class="o"&gt;(&lt;/span&gt;on object monitor&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.Object.wait&lt;span class="o"&gt;(&lt;/span&gt;Native Method&lt;span class="o"&gt;)&lt;/span&gt;
 - waiting on &amp;lt;0x00000000ecfdd7d0&amp;gt; &lt;span class="o"&gt;(&lt;/span&gt;a sun.misc.GC&lt;span class="nv"&gt;$LatencyLock&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
 at sun.misc.GC&lt;span class="nv"&gt;$Daemon&lt;/span&gt;.run&lt;span class="o"&gt;(&lt;/span&gt;GC.java:117&lt;span class="o"&gt;)&lt;/span&gt;
 - locked &amp;lt;0x00000000ecfdd7d0&amp;gt; &lt;span class="o"&gt;(&lt;/span&gt;a sun.misc.GC&lt;span class="nv"&gt;$LatencyLock&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;Service Thread&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#8 daemon prio=9 os_prio=0 tid=0x00007f49100e1000 nid=0x43a3 runnable [0x0000000000000000]&lt;/span&gt;
   java.lang.Thread.State: RUNNABLE
&lt;span class="s2"&gt;&amp;quot;C1 CompilerThread2&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#7 daemon prio=9 os_prio=0 tid=0x00007f49100ce000 nid=0x43a2 waiting on condition [0x0000000000000000]&lt;/span&gt;
   java.lang.Thread.State: RUNNABLE
&lt;span class="s2"&gt;&amp;quot;C2 CompilerThread1&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#6 daemon prio=9 os_prio=0 tid=0x00007f49100cc800 nid=0x43a1 waiting on condition [0x0000000000000000]&lt;/span&gt;
   java.lang.Thread.State: RUNNABLE
&lt;span class="s2"&gt;&amp;quot;C2 CompilerThread0&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#5 daemon prio=9 os_prio=0 tid=0x00007f49100bf000 nid=0x43a0 waiting on condition [0x0000000000000000]&lt;/span&gt;
   java.lang.Thread.State: RUNNABLE
&lt;span class="s2"&gt;&amp;quot;Signal Dispatcher&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#4 daemon prio=9 os_prio=0 tid=0x00007f49100bc800 nid=0x439f runnable [0x0000000000000000]&lt;/span&gt;
   java.lang.Thread.State: RUNNABLE
&lt;span class="s2"&gt;&amp;quot;Finalizer&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#3 daemon prio=8 os_prio=0 tid=0x00007f4910093000 nid=0x439e in Object.wait() [0x00007f48fb5f4000]&lt;/span&gt;
   java.lang.Thread.State: WAITING &lt;span class="o"&gt;(&lt;/span&gt;on object monitor&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.Object.wait&lt;span class="o"&gt;(&lt;/span&gt;Native Method&lt;span class="o"&gt;)&lt;/span&gt;
 - waiting on &amp;lt;0x00000000edd08988&amp;gt; &lt;span class="o"&gt;(&lt;/span&gt;a java.lang.ref.ReferenceQueue&lt;span class="nv"&gt;$Lock&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.ref.ReferenceQueue.remove&lt;span class="o"&gt;(&lt;/span&gt;ReferenceQueue.java:143&lt;span class="o"&gt;)&lt;/span&gt;
 - locked &amp;lt;0x00000000edd08988&amp;gt; &lt;span class="o"&gt;(&lt;/span&gt;a java.lang.ref.ReferenceQueue&lt;span class="nv"&gt;$Lock&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.ref.ReferenceQueue.remove&lt;span class="o"&gt;(&lt;/span&gt;ReferenceQueue.java:164&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.ref.Finalizer&lt;span class="nv"&gt;$FinalizerThread&lt;/span&gt;.run&lt;span class="o"&gt;(&lt;/span&gt;Finalizer.java:209&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;Reference Handler&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#2 daemon prio=10 os_prio=0 tid=0x00007f491008e800 nid=0x439d in Object.wait() [0x00007f48fb6f5000]&lt;/span&gt;
   java.lang.Thread.State: WAITING &lt;span class="o"&gt;(&lt;/span&gt;on object monitor&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.Object.wait&lt;span class="o"&gt;(&lt;/span&gt;Native Method&lt;span class="o"&gt;)&lt;/span&gt;
 - waiting on &amp;lt;0x00000000edd00970&amp;gt; &lt;span class="o"&gt;(&lt;/span&gt;a java.lang.ref.Reference&lt;span class="nv"&gt;$Lock&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.Object.wait&lt;span class="o"&gt;(&lt;/span&gt;Object.java:502&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.ref.Reference.tryHandlePending&lt;span class="o"&gt;(&lt;/span&gt;Reference.java:191&lt;span class="o"&gt;)&lt;/span&gt;
 - locked &amp;lt;0x00000000edd00970&amp;gt; &lt;span class="o"&gt;(&lt;/span&gt;a java.lang.ref.Reference&lt;span class="nv"&gt;$Lock&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.ref.Reference&lt;span class="nv"&gt;$ReferenceHandler&lt;/span&gt;.run&lt;span class="o"&gt;(&lt;/span&gt;Reference.java:153&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;main&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#1 prio=5 os_prio=0 tid=0x00007f4910009000 nid=0x4397 runnable [0x00007f4919dbd000]&lt;/span&gt;
   java.lang.Thread.State: RUNNABLE
 at java.net.PlainSocketImpl.socketAccept&lt;span class="o"&gt;(&lt;/span&gt;Native Method&lt;span class="o"&gt;)&lt;/span&gt;
 at java.net.AbstractPlainSocketImpl.accept&lt;span class="o"&gt;(&lt;/span&gt;AbstractPlainSocketImpl.java:409&lt;span class="o"&gt;)&lt;/span&gt;
 at java.net.ServerSocket.implAccept&lt;span class="o"&gt;(&lt;/span&gt;ServerSocket.java:545&lt;span class="o"&gt;)&lt;/span&gt;
 at java.net.ServerSocket.accept&lt;span class="o"&gt;(&lt;/span&gt;ServerSocket.java:513&lt;span class="o"&gt;)&lt;/span&gt;
 at org.apache.catalina.core.StandardServer.await&lt;span class="o"&gt;(&lt;/span&gt;StandardServer.java:470&lt;span class="o"&gt;)&lt;/span&gt;
 at org.apache.catalina.startup.Catalina.await&lt;span class="o"&gt;(&lt;/span&gt;Catalina.java:781&lt;span class="o"&gt;)&lt;/span&gt;
 at org.apache.catalina.startup.Catalina.start&lt;span class="o"&gt;(&lt;/span&gt;Catalina.java:727&lt;span class="o"&gt;)&lt;/span&gt;
 at sun.reflect.NativeMethodAccessorImpl.invoke0&lt;span class="o"&gt;(&lt;/span&gt;Native Method&lt;span class="o"&gt;)&lt;/span&gt;
 at sun.reflect.NativeMethodAccessorImpl.invoke&lt;span class="o"&gt;(&lt;/span&gt;NativeMethodAccessorImpl.java:62&lt;span class="o"&gt;)&lt;/span&gt;
 at sun.reflect.DelegatingMethodAccessorImpl.invoke&lt;span class="o"&gt;(&lt;/span&gt;DelegatingMethodAccessorImpl.java:43&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.reflect.Method.invoke&lt;span class="o"&gt;(&lt;/span&gt;Method.java:498&lt;span class="o"&gt;)&lt;/span&gt;
 at org.apache.catalina.startup.Bootstrap.start&lt;span class="o"&gt;(&lt;/span&gt;Bootstrap.java:294&lt;span class="o"&gt;)&lt;/span&gt;
 at org.apache.catalina.startup.Bootstrap.main&lt;span class="o"&gt;(&lt;/span&gt;Bootstrap.java:428&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;VM Thread&amp;quot;&lt;/span&gt; &lt;span class="nv"&gt;os_prio&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="nv"&gt;tid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00007f4910084800 &lt;span class="nv"&gt;nid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x439c runnable
&lt;span class="s2"&gt;&amp;quot;GC task thread#0 (ParallelGC)&amp;quot;&lt;/span&gt; &lt;span class="nv"&gt;os_prio&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="nv"&gt;tid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00007f491001e000 &lt;span class="nv"&gt;nid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x4398 runnable
&lt;span class="s2"&gt;&amp;quot;GC task thread#1 (ParallelGC)&amp;quot;&lt;/span&gt; &lt;span class="nv"&gt;os_prio&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="nv"&gt;tid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00007f491001f800 &lt;span class="nv"&gt;nid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x4399 runnable
&lt;span class="s2"&gt;&amp;quot;GC task thread#2 (ParallelGC)&amp;quot;&lt;/span&gt; &lt;span class="nv"&gt;os_prio&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="nv"&gt;tid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00007f4910021800 &lt;span class="nv"&gt;nid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x439a runnable
&lt;span class="s2"&gt;&amp;quot;GC task thread#3 (ParallelGC)&amp;quot;&lt;/span&gt; &lt;span class="nv"&gt;os_prio&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="nv"&gt;tid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00007f4910023800 &lt;span class="nv"&gt;nid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x439b runnable
&lt;span class="s2"&gt;&amp;quot;VM Periodic Task Thread&amp;quot;&lt;/span&gt; &lt;span class="nv"&gt;os_prio&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="nv"&gt;tid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00007f49100ef800 &lt;span class="nv"&gt;nid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x43a4 waiting on condition
JNI global references: 44
$
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;References&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.wolfe.id.au/2011/10/16/monitoring-the-openjdk-from-the-cli/"&gt;Monitoring the OpenJDK from the CLI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://d2.naver.com/helloworld/6043"&gt;Garbage Collection 모니터링 방법&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="java"></category><category term="jvm"></category><category term="monitoring"></category><category term="jps"></category><category term="stat"></category><category term="stack"></category></entry><entry><title>Windows 에서 apache zeppelin 사용 시 HiveContext 에러</title><link href="https://imjang57.github.io/garret/hive-context-error-of-zeppelin-on-windows.html" rel="alternate"></link><published>2017-01-10T00:00:00+09:00</published><updated>2016-01-10T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-10:/garret/hive-context-error-of-zeppelin-on-windows.html</id><summary type="html">&lt;p&gt;Windows 에서 apache zeppelin 사용 시 HiveContext 에러가 발생하는 경우&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Windows 에서 zeppelin 실행&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://imjang57.github.io/garret/run-spark-shell-on-windows.html"&gt;윈도우에서 spark-shell을 실행하는 방법&lt;/a&gt; 에서 윈도우에서 spark-shell 을 실행하는 방법에 대해 알아봤다. spark-shell 이 실행가능하니까 당연히 zeppelin 도 실행가능할거라고 생각된다. 그래서 실행해보니 에러가 발생했다..-_-..; 메시지가 매우 긴데.. 다음과 같은 메시지가 나오는 경우였다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Caused by: java.lang.IllegalArgumentException: java.net.URISyntaxException: Relative path in absolute URI: file:C:/Users/imjan/Desktop/zeppelin-0.6.2/spark-warehouse
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;%ZEPPELIN_HOME%\spark-warehouse&lt;/code&gt; 를 hive 테이블들을 저장하기 위해 사용하는 것 같다. 그래서 &lt;code&gt;%ZEPPELIN_HOME%\spark-warehouse&lt;/code&gt; 폴더를 생성하고 &lt;a href="https://imjang57.github.io/garret/run-spark-shell-on-windows.html"&gt;윈도우에서 spark-shell을 실행하는 방법&lt;/a&gt; 포스트에서 했떤 것 처럼 winutils 를 사용해서 권한을 설정해줬다&lt;/p&gt;
&lt;p&gt;그런데 같은 에러가 또 발생한다..!!!!..ㅆ....&lt;/p&gt;
&lt;p&gt;그래서 찾다보니 &lt;a href="https://hernandezpaul.wordpress.com/2016/11/14/apache-zeppelin-installation-on-windows-10/"&gt;이 블로그 포스트&lt;/a&gt; 에서 해결책을 찾았다.&lt;/p&gt;
&lt;p&gt;결론은 &lt;code&gt;spark.sql.warehouse.dir&lt;/code&gt; 이라는 설정값을 정확하게 설정해줘야 한다는 것이다. &lt;code&gt;%ZEPPELIN_HOME%\conf\interpreter.json&lt;/code&gt; 을 열어서 spark interprefter 설정을 찾아서 아래와 같이 &lt;code&gt;spark.sql.warehouse.dir&lt;/code&gt; 을 추가하자.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="err"&gt;...&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;quot;2C5DV85NF&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;quot;id&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;2C5DV85NF&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;quot;name&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;spark&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;quot;group&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;spark&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;quot;properties&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;quot;spark.sql.warehouse.dir&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;file:///C:/Users/imjan/Desktop/zeppelin-0.6.2/spark-warehouse&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;quot;spark.executor.memory&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;quot;args&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;quot;zeppelin.spark.printREPLOutput&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;true&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;quot;spark.cores.max&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;quot;zeppelin.dep.additionalRemoteRepository&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;spark-packages,http://dl.bintray.com/spark-packages/maven,false;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;quot;zeppelin.spark.sql.stacktrace&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;false&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;quot;zeppelin.spark.importImplicit&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;true&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;quot;zeppelin.spark.concurrentSQL&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;false&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;quot;zeppelin.spark.useHiveContext&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;true&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;quot;zeppelin.pyspark.python&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;python&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;quot;zeppelin.dep.localrepo&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;local-repo&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;quot;zeppelin.R.knitr&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;true&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;quot;zeppelin.spark.maxResult&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;1000&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;quot;master&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;local[*]&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;quot;spark.app.name&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Zeppelin&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;quot;zeppelin.R.image.width&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;100%&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;quot;zeppelin.R.render.options&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;out.format \u003d \u0027html\u0027, comment \u003d NA, echo \u003d FALSE, results \u003d \u0027asis\u0027, message \u003d F, warning \u003d F&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;quot;zeppelin.R.cmd&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;R&amp;quot;&lt;/span&gt;
      &lt;span class="p"&gt;},&lt;/span&gt;
      &lt;span class="err"&gt;...&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="err"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;그리고 아래 코드를 실행해서 테스트해보니 잘된다. &lt;code&gt;%ZEPPELIN_HOME&lt;/code&gt;\spark-warehouse&lt;code&gt;에&lt;/code&gt;tmptable` 이라는 폴더가 생성된 걸 확인할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;hiveCtx&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;org&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;apache&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;spark&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sql&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;hive&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;HiveContext&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sc&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;hiveCtx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sql&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;select 1, 2&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;saveAsTable&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;tmpTable&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr&gt;
&lt;p&gt;위의 내용은 zeppelin 내장 spark interpreter 를 사용한 경우라서 사용 형태라 다른 경우 맞지 않을 수도 있다.&lt;/p&gt;
&lt;h1&gt;참고&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://hernandezpaul.wordpress.com/2016/11/14/apache-zeppelin-installation-on-windows-10/"&gt;Apache Zeppelin installation on Windows 10&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="spark"></category><category term="zeppelin"></category></entry><entry><title>Windows 에서 spark-shell 을 실행하는 방법</title><link href="https://imjang57.github.io/garret/run-spark-shell-on-windows.html" rel="alternate"></link><published>2017-01-10T00:00:00+09:00</published><updated>2016-01-10T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-10:/garret/run-spark-shell-on-windows.html</id><summary type="html">&lt;p&gt;Windows 에서 spark-shell 을 실행하는 방법&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Windows 에서 spark-shell 실행&lt;/h1&gt;
&lt;p&gt;윈도우에서 spark-shell 실행 시 NullPointerException 발생할 경우 문제 해결하는 방법에 대한 글이다.&lt;/p&gt;
&lt;h1&gt;윈도우에서 Spark 실행 시 RuntimeException(NullPointerException) 발생&lt;/h1&gt;
&lt;p&gt;Spark 은 보통 리눅스에서 사용되지만 Local mode 로 실행하면 윈도우에서도 실행할 수 있다. 그런데 리눅스에서는 단순히 spark-shell 스크립트를 실행하면 되는데 윈도우에서는 아래와 같은 에러가 발생하는 경우가 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;java.lang.RuntimeException: java.lang.NullPointerException&lt;/span&gt;
&lt;span class="x"&gt;        at org.apache.hadoop.hive.ql.session.SessionState.start(SessionState.java:522)&lt;/span&gt;
&lt;span class="x"&gt;at org.apache.spark.sql.hive.client.ClientWrapper.&amp;lt;init&amp;gt;(ClientWrapper.scala:194)&lt;/span&gt;
&lt;span class="x"&gt;at org.apache.spark.sql.hive.client.IsolatedClientLoader.createClient(IsolatedClientLoader.scala:238)&lt;/span&gt;
&lt;span class="x"&gt;at org.apache.spark.sql.hive.HiveContext.executionHive&lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;lzycompute&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;HiveContext.scala&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="m"&gt;218&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;span class="x"&gt;at org.apache.spark.sql.hive.HiveContext.executionHive(HiveContext.scala:208)&lt;/span&gt;
&lt;span class="x"&gt;at org.apache.spark.sql.hive.HiveContext.functionRegistry&lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;lzycompute&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;HiveContext.scala&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="m"&gt;462&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;span class="x"&gt;at org.apache.spark.sql.hive.HiveContext.functionRegistry(HiveContext.scala:461)&lt;/span&gt;
&lt;span class="x"&gt;at org.apache.spark.sql.UDFRegistration.&amp;lt;init&amp;gt;(UDFRegistration.scala:40)&lt;/span&gt;
&lt;span class="x"&gt;................&lt;/span&gt;
&lt;span class="x"&gt;................&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;그냥 NullPointerException 이고 아무런 메시지가 없다…-_-…&lt;/p&gt;
&lt;p&gt;내 기억에 작년에 분명 spark-shell 을 윈도우에서 잘 썼었는데 갑자기 에러가 나서 당황했는데, HiveContext 가 원인이었다.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://blogs.msdn.microsoft.com/arsen/2016/02/09/resolving-spark-1-6-0-java-lang-nullpointerexception-not-found-value-sqlcontext-error-when-running-spark-shell-on-windows-10-64-bit/"&gt;MSDN 블로그의 한 글&lt;/a&gt;에 따르면 윈도우에서 Spark 이 HiveContext 를 초기화하기 위해서는 &lt;code&gt;winutils.exe&lt;/code&gt; 이라는 파일이 필요하다. 블로그에 따르면 HiveContext 를 초기화하는데 Hadoop 의 Native libraries 를 필요로 하기 때문이라는 듯 하다.&lt;/p&gt;
&lt;p&gt;이번에 사용하려고 했던 spark 빌드는 hive 를 포함한 빌드이기 때문에 spark-shell 이 실행될 때 무조건 HiveContext 를 초기화하게 되어 있었다. 생각해보니 작년에 사용했던 건 hive 를 제외하고 소스를 빌드해서 사용했던 것 같다.ㅠㅠ&lt;/p&gt;
&lt;p&gt;어쨌든 이 문제를 해결하기 위해서는 아래와 같은 것들이 필요하다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;winutils.exe 다운로드 및 %HADOOP_HOME%\bin 에 복사&lt;/li&gt;
&lt;li&gt;HADOOP_HOME 환경 변수 설정&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;자세한 내용은 블로그에 쉽게 나와있으니 읽어보면 되고, 아래 명령들만 기억하자.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;%HADOOP_HOME%&lt;span class="se"&gt;\b&lt;/span&gt;in&lt;span class="se"&gt;\w&lt;/span&gt;inutils.exe ls &lt;span class="se"&gt;\t&lt;/span&gt;mp&lt;span class="se"&gt;\h&lt;/span&gt;ive
%HADOOP_HOME%&lt;span class="se"&gt;\b&lt;/span&gt;in&lt;span class="se"&gt;\w&lt;/span&gt;inutils.exe chmod &lt;span class="m"&gt;777&lt;/span&gt; &lt;span class="se"&gt;\t&lt;/span&gt;mp&lt;span class="se"&gt;\h&lt;/span&gt;ive
%HADOOP_HOME%&lt;span class="se"&gt;\b&lt;/span&gt;in&lt;span class="se"&gt;\w&lt;/span&gt;inutils.exe ls &lt;span class="se"&gt;\t&lt;/span&gt;mp&lt;span class="se"&gt;\h&lt;/span&gt;ive
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;hadoop 은 설치하고 파일 옮기고 귀찮으니까 그냥 &lt;a href="https://github.com/steveloughran/winutils"&gt;winutils github&lt;/a&gt; 에서 다운로드 하자. 윈도우에서 hadoop 을 잘 쓸 수 있게 &lt;code&gt;winutils.exe&lt;/code&gt; 파일까지 포함시켜서 구성되어 있다. 다운로드 해서 &lt;code&gt;%HADOOP_HOME%&lt;/code&gt; 만 잘 잡아주면 된다.&lt;/p&gt;
&lt;h1&gt;추가로 발생한 문제&lt;/h1&gt;
&lt;p&gt;나의 경우에 위 내용을 다 했는데도 에러가 발생했다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;java.lang.RuntimeException: java.lang.RuntimeException: The root scratch dir: /tmp/hive on HDFS should be writable. Current permissions are: rwx------&lt;/span&gt;
&lt;span class="x"&gt;  at org.apache.hadoop.hive.ql.session.SessionState.start(SessionState.java:522)&lt;/span&gt;
&lt;span class="x"&gt;  at org.apache.spark.sql.hive.client.ClientWrapper.&amp;lt;init&amp;gt;(ClientWrapper.scala:204)&lt;/span&gt;
&lt;span class="x"&gt;  at org.apache.spark.sql.hive.client.IsolatedClientLoader.createClient(IsolatedClientLoader.scala:238)&lt;/span&gt;
&lt;span class="x"&gt;  at org.apache.spark.sql.hive.HiveContext.executionHive&lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;lzycompute&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;HiveContext.scala&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="m"&gt;218&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;span class="x"&gt;  at org.apache.spark.sql.hive.HiveContext.executionHive(HiveContext.scala:208)&lt;/span&gt;
&lt;span class="x"&gt;  at org.apache.spark.sql.hive.HiveContext.functionRegistry&lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;lzycompute&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;HiveContext.scala&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="m"&gt;462&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;span class="x"&gt;  at org.apache.spark.sql.hive.HiveContext.functionRegistry(HiveContext.scala:461)&lt;/span&gt;
&lt;span class="x"&gt;  at org.apache.spark.sql.UDFRegistration.&amp;lt;init&amp;gt;(UDFRegistration.scala:40)&lt;/span&gt;
&lt;span class="x"&gt;  at org.apache.spark.sql.SQLContext.&amp;lt;init&amp;gt;(SQLContext.scala:330)&lt;/span&gt;
&lt;span class="x"&gt;  at org.apache.spark.sql.hive.HiveContext.&amp;lt;init&amp;gt;(HiveContext.scala:97)&lt;/span&gt;
&lt;span class="x"&gt;  at org.apache.spark.sql.hive.HiveContext.&amp;lt;init&amp;gt;(HiveContext.scala:101)&lt;/span&gt;
&lt;span class="x"&gt;  at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)&lt;/span&gt;
&lt;span class="x"&gt;  at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)&lt;/span&gt;
&lt;span class="x"&gt;  at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)&lt;/span&gt;
&lt;span class="x"&gt;  at java.lang.reflect.Constructor.newInstance(Constructor.java:422)&lt;/span&gt;
&lt;span class="x"&gt;  at org.apache.spark.repl.Main&lt;/span&gt;&lt;span class="p"&gt;$.&lt;/span&gt;&lt;span class="nv"&gt;createSQLContext&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;Main.scala&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="m"&gt;89&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;span class="x"&gt;  ... 47 elided&lt;/span&gt;
&lt;span class="x"&gt;Caused by: java.lang.RuntimeException: The root scratch dir: /tmp/hive on HDFS should be writable. Current permissions are: rwx------&lt;/span&gt;
&lt;span class="x"&gt;  at org.apache.hadoop.hive.ql.session.SessionState.createRootHDFSDir(SessionState.java:612)&lt;/span&gt;
&lt;span class="x"&gt;  at org.apache.hadoop.hive.ql.session.SessionState.createSessionDirs(SessionState.java:554)&lt;/span&gt;
&lt;span class="x"&gt;  at org.apache.hadoop.hive.ql.session.SessionState.start(SessionState.java:508)&lt;/span&gt;
&lt;span class="x"&gt;  ... 62 more&lt;/span&gt;
&lt;span class="x"&gt;&amp;lt;console&amp;gt;:13: error: not found: value sqlContext&lt;/span&gt;
&lt;span class="x"&gt;       import sqlContext.implicits._&lt;/span&gt;
&lt;span class="x"&gt;              ^&lt;/span&gt;
&lt;span class="x"&gt;&amp;lt;console&amp;gt;:13: error: not found: value sqlContext&lt;/span&gt;
&lt;span class="x"&gt;       import sqlContext.sql&lt;/span&gt;
&lt;span class="x"&gt;              ^&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;이번에는 그래도 쉽게 이유를 알 수 있었다. 에러 메시지를 보면 다음과 같다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;The root scratch dir: /tmp/hive on HDFS should be writable. Current permissions are: rwx------
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;즉, 권한 문제다. 그런데 원래 위의 내용대로 하면 위 문제가 해결되어야 한다. 뭐가 문제인가.&lt;/p&gt;
&lt;p&gt;문제는 내가 C 드라이브가 아니라 E 드라이브에서 spark-shell 을 실행해서 였다. 위의 내용대로 해서 &lt;code&gt;C:\tmp\hive&lt;/code&gt; 를 생성하고 권한 설정했는데, spark-shell 은 E 드라이브에서 실행해서 실제로는 &lt;code&gt;E:\tmp\hive&lt;/code&gt; 에 접근했던 거였다. 그래서 &lt;code&gt;E:\tmp\hive&lt;/code&gt; 로 다시 권한을 설정하고 실행하니 잘 되었다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;code&gt;HADOOP_HOME&lt;/code&gt; 을 환경변수로 해주기 귀찮아서 더 해보니까 conf/spark-env.cmd 파일에 아래처럼 추가해줘도 동작한다.&lt;/p&gt;
&lt;p&gt;set HADOOP_HOME=C:\hadoop\hadoop-2.6.4&lt;/p&gt;
&lt;h1&gt;참고&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://blogs.msdn.microsoft.com/arsen/2016/02/09/resolving-spark-1-6-0-java-lang-nullpointerexception-not-found-value-sqlcontext-error-when-running-spark-shell-on-windows-10-64-bit/"&gt;Resolving Spark 1.6.0 "java.lang.NullPointerException, not found: value sqlContext" error when running spark-shell on Windows 10 (64-bit)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/steveloughran/winutils/tree/master/hadoop-2.6.4/bin"&gt;hadoop 2.6.4 winutils github&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="spark"></category></entry><entry><title>Java version 을 체크하는 bash script</title><link href="https://imjang57.github.io/garret/bash-script-checking-java-version.html" rel="alternate"></link><published>2016-12-30T00:00:00+09:00</published><updated>2016-12-30T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2016-12-30:/garret/bash-script-checking-java-version.html</id><summary type="html">&lt;p&gt;Java version 을 체크하기 위한 bash script&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Check Java version from bash script&lt;/h1&gt;
&lt;p&gt;리눅스에서 자바 버전을 체크하기 위한 꼼수 스크립트를 간단하게 작성해서 저장하기 위한 글입니다.&lt;/p&gt;
&lt;p&gt;java -version 명령의 결과:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ java -version
java version &lt;span class="s2"&gt;&amp;quot;1.8.0_73&amp;quot;&lt;/span&gt;
Java&lt;span class="o"&gt;(&lt;/span&gt;TM&lt;span class="o"&gt;)&lt;/span&gt; SE Runtime Environment &lt;span class="o"&gt;(&lt;/span&gt;build 1.8.0_73-b02&lt;span class="o"&gt;)&lt;/span&gt;
Java HotSpot&lt;span class="o"&gt;(&lt;/span&gt;TM&lt;span class="o"&gt;)&lt;/span&gt; 64-Bit Server VM &lt;span class="o"&gt;(&lt;/span&gt;build 25.73-b02, mixed mode&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;환경변수 $JAVA_HOME을 찾아서 하는 bash script:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/bin/bash&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; -n &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$JAVA_HOME&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;then&lt;/span&gt;
  &lt;span class="nv"&gt;JAVA_CMD&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$JAVA_HOME&lt;/span&gt;&lt;span class="s2"&gt;/bin/java&amp;quot;&lt;/span&gt;
  &lt;span class="nv"&gt;JAVA_VERSION&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;$JAVA_CMD&lt;/span&gt; -version 2&amp;gt;&lt;span class="p"&gt;&amp;amp;&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; awk -F&lt;span class="s1"&gt;&amp;#39;&amp;quot;&amp;#39;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;/version/ {print $2}&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; awk -F&lt;span class="s1"&gt;&amp;#39;_&amp;#39;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;{print $1}&amp;#39;&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;
  &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Run using java version &lt;/span&gt;&lt;span class="nv"&gt;$JAVA_VERSION&lt;/span&gt;&lt;span class="s2"&gt; (JAVA_HOME is &lt;/span&gt;&lt;span class="nv"&gt;$JAVA_HOME&lt;/span&gt;&lt;span class="s2"&gt;)&amp;quot;&lt;/span&gt;
  &lt;span class="o"&gt;[[&lt;/span&gt; &lt;span class="nv"&gt;$JAVA_VERSION&lt;/span&gt; &amp;gt; 1.8 &lt;span class="o"&gt;]]&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="nv"&gt;$?&lt;/span&gt; -eq &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
  &lt;span class="k"&gt;then&lt;/span&gt;
    &lt;span class="nb"&gt;echo&lt;/span&gt; This java version is greater than 1.8.
  &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="nb"&gt;echo&lt;/span&gt; This java version is not supported.
  &lt;span class="k"&gt;fi&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;
  &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Java doesn&amp;#39;t exists.&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;fi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;자바 실행 파일 위치를 찾아서 하는 bash script:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/bin/bash&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;which java&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;then&lt;/span&gt;
  &lt;span class="nv"&gt;JAVA_PATH&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;whereis java&lt;span class="k"&gt;)&lt;/span&gt;
  &lt;span class="nv"&gt;JAVA_VERSION&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;java -version 2&amp;gt;&lt;span class="p"&gt;&amp;amp;&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; awk -F&lt;span class="s1"&gt;&amp;#39;&amp;quot;&amp;#39;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;/version/ {print $2}&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; awk -F&lt;span class="s1"&gt;&amp;#39;_&amp;#39;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;{print $1}&amp;#39;&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;
  &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Run using java version &lt;/span&gt;&lt;span class="nv"&gt;$JAVA_VERSION&lt;/span&gt;&lt;span class="s2"&gt; (&lt;/span&gt;&lt;span class="nv"&gt;$JAVA_PATH&lt;/span&gt;&lt;span class="s2"&gt;)&amp;quot;&lt;/span&gt;
  &lt;span class="o"&gt;[[&lt;/span&gt; &lt;span class="nv"&gt;$JAVA_VERSION&lt;/span&gt; &amp;gt; 1.8 &lt;span class="o"&gt;]]&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="nv"&gt;$?&lt;/span&gt; -eq &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
  &lt;span class="k"&gt;then&lt;/span&gt;
    &lt;span class="nb"&gt;echo&lt;/span&gt; This java version is greater than 1.8.
  &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="nb"&gt;echo&lt;/span&gt; This java version is not supported.
  &lt;span class="k"&gt;fi&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;
  &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Java doesn&amp;#39;t exists.&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;fi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;두 방법이 사실 거의 똑같다. 그냥 whereis 명령을 이용하느냐, JAVA_HOME 이라는 환경변수를 이용하느냐만 다르다.&lt;/p&gt;
&lt;p&gt;다른 방법으로는 sort 명령을 이용해서 가장 앞에 위치하는 녀석을 비교하는 방법도 있다.&lt;/p&gt;
&lt;p&gt;처음에는 bc 명령을 사용하려 했는데 버전은 보통 여러 개의 comma(.)로 되어있어서 bc 로 사용은 불가능했다. 사실 comma(.) 단위로 나눠서 각각 비교하는 로직 구현하면 되는데 귀찮음이 커서..&lt;/p&gt;
&lt;p&gt;이 방법은 사실 완벽한 방법은 아니다. awk 로 추출한 문자열이 x.y.z 형태라는 걸 알고 있기 때문에 가능한 방법이다. 만약 1.8 로 버전이 추출되면 제대로 동작 안할 것이다. 제대로 하려면 comma(.) 단위로 나눠서 제대로 비교하는 함수를 만들어야 겠지..&lt;/p&gt;</content><category term="bash"></category></entry><entry><title>자바에서 % 출력하기</title><link href="https://imjang57.github.io/garret/print-percent-sign-in-java.html" rel="alternate"></link><published>2016-12-30T00:00:00+09:00</published><updated>2016-12-30T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2016-12-30:/garret/print-percent-sign-in-java.html</id><summary type="html">&lt;p&gt;자바에서 % 문자 출력하기&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Java String 에서 % 문자 출력하기&lt;/h1&gt;
&lt;p&gt;오늘 개발하다가 &lt;code&gt;%&lt;/code&gt; 문자가 들어가는 문자열을 처리할 일이 있었다. 처음에 아무 생각없이 아래처럼 작성했다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;str1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;test&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;str2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;format&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;string is \&amp;quot;%%s%\&amp;quot;.&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;str1&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;원하는 결과는 아래와 같이 나오는 것이었다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;string is &amp;quot;%test%&amp;quot;.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;당연히 String.format 에서 에러가 발생했다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Exception in thread &amp;quot;main&amp;quot; java.util.UnknownFormatConversionException: Conversion = &amp;#39;&amp;quot;&amp;#39;
 at java.util.Formatter.checkText(Formatter.java:2579)
 at java.util.Formatter.parse(Formatter.java:2565)
 at java.util.Formatter.format(Formatter.java:2501)
 at java.util.Formatter.format(Formatter.java:2455)
 at java.lang.String.format(String.java:2940)
 at StringTest.main(StringTest.java:7)
 at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
 at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
 at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
 at java.lang.reflect.Method.invoke(Method.java:497)
 at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;\&lt;/code&gt; 는 특정 &lt;em&gt;espace character&lt;/em&gt; 로 이미 약속된 문자들과 사용돼야 한다. 그런데 그 문자들 중에 &lt;code&gt;%&lt;/code&gt; 는 없다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;%&lt;/code&gt; 는 &lt;em&gt;Formatting&lt;/em&gt; 을 위한 문자로, &lt;code&gt;String.format("%d", 123);&lt;/code&gt; 과 같이 사용된다. 이 때 &lt;code&gt;%&lt;/code&gt; 자체를 출력하기 위해서도 &lt;code&gt;%&lt;/code&gt; 를 prefix 로 사용하여 &lt;code&gt;%%&lt;/code&gt; 와 같이 처리해야 한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;str1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;test&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;str2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;format&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;string is %%%s%%.&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;str1&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;%&lt;/code&gt; 는 그냥 문자가 아니라 포맷을 지정하기 위한 포맷 지시자 (format specifier 또는 format string) 역할을 하는 특수한 문자이기 때문이다.&lt;/p&gt;
&lt;p&gt;알고 있던 거였는데.. 역시 오래동안 안쓰면 머리에서 삭제되어 버린다. ㅠㅠ&lt;/p&gt;</content></entry><entry><title>SSH Host-key identification</title><link href="https://imjang57.github.io/garret/ssh-host-key-identification.html" rel="alternate"></link><published>2016-12-30T00:00:00+09:00</published><updated>2016-12-30T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2016-12-30:/garret/ssh-host-key-identification.html</id><summary type="html">&lt;p&gt;This is about SSH Host-key identification.&lt;/p&gt;</summary><content type="html">&lt;h1&gt;SSH host key&lt;/h1&gt;
&lt;p&gt;가끔 SSH Client 로 Remote 에 있는 SSH Server 에 접속할 때 아래와 같은 에러를 볼 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;imjang57@myserver:~$ ssh administrator@192.168.0.5
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!              @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now &lt;span class="o"&gt;(&lt;/span&gt;man-in-the-middle
attack&lt;span class="o"&gt;)&lt;/span&gt;!
It is also possible that a host key has just been changed.
The fingerprint &lt;span class="k"&gt;for&lt;/span&gt; the ECDSA key sent by the remote host is
bf:e3:d3:21:c4:3c:60:cd:d9:2b:bb:a4:d1:6e:1f:df.
Please contact your system administrator.
Add correct host key in /home/imjang57/.ssh/known_hosts to get rid of
this message.
Offending ECDSA key in /home/imjang57/.ssh/known_hosts:8
  remove with: ssh-keygen -f &lt;span class="s2"&gt;&amp;quot;/home/imjang57/.ssh/known_hosts&amp;quot;&lt;/span&gt; -R
192.168.0.5
ECDSA host key &lt;span class="k"&gt;for&lt;/span&gt; 192.168.0.5 has changed and you have
requested strict checking.
Host key verification failed.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;em&gt;Host Key&lt;/em&gt; 가 달라서 발생하는 문제다. 자세히 말하면, 클라이언트 측에 등록된 SSH 서버의 호스트 키가 현재 접속 시도하면서 새롭게 받은 호스크 키와 달라서 발생한 문제이다.&lt;/p&gt;
&lt;p&gt;SSH 서버에서 호스트 키를 새롭게 생성했거나, 클라이언트 측에서 SSH 서버의 호스트 키를 수동으로 입력했는데 잘못입력했거나, 서버를 재설치했거나, 기타 등등의 이유로 기존에 저장된 호스트 키와 연결시도하면서 새롭게 받은 호스트 키가 다를 수 있다.&lt;/p&gt;
&lt;p&gt;이는 SSH 연결을 시도하는 서버가 정말 내가 연결하려는 서버가 맞는지를 체크할 수 있는 기능이다. HTTPS 를 사용할 때 신뢰할 수 있는 사이트인지 확인하는 것과 비슷한 이유로 제공되는 기능이다.&lt;/p&gt;
&lt;h2&gt;해결 방법&lt;/h2&gt;
&lt;p&gt;해결하는 방법은 여러개가 있다.&lt;/p&gt;
&lt;h3&gt;known_host 삭제하여 해결&lt;/h3&gt;
&lt;p&gt;보통 사용자의 홈 디렉터리에 .ssh 라는 디렉터리가 있고, 여기에 사용자를 위한 SSH 설정이나 사용자 인증을 위한 키 파일이 저장된다. 그리고 &lt;user_home&gt;/.ssh 디렉터리 밑에 known_hosts 라는 파일이 있는데 여기에 SSH 서버의 호스트 키들이 저장되어 있다. 여기서 에러가 나는 SSH 서버의 호스트 키를 삭제하면 다시 연결할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ssh-keygen -f &lt;span class="s2"&gt;&amp;quot;/home/imjang57/.ssh/known_hosts&amp;quot;&lt;/span&gt; -R 192.168.0.5
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;위 명령으로 저장된 서버의 호스트 키를 삭제한 후 SSH 서버에 다시 접속하면 아래와 같이 호스트 키를 등록하냐고 물어보는 메시지가 나타난다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;imjang57@myserver:~$ ssh administrator@192.168.0.5
The authenticity of host &lt;span class="s1"&gt;&amp;#39;192.168.0.5&amp;#39;&lt;/span&gt; can&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;t be established.
ECDSA key fingerprint is
bf:e3:d3:21:c4:3c:60:cd:d9:2b:bb:a4:d1:6e:1f:df.
Are you sure you want to &lt;span class="k"&gt;continue&lt;/span&gt; connecting &lt;span class="o"&gt;(&lt;/span&gt;yes/no&lt;span class="o"&gt;)&lt;/span&gt;?
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;yes 를 입력하면 호스트 키를 &lt;user_home&gt;/.ssh/known_hosts 파일에 저장하고 SSH 접속하게 된다.&lt;/p&gt;
&lt;p&gt;만약 명령어 치는게 귀찮으면 그냥 known_hosts 파일 삭제하면 된다.&lt;/p&gt;
&lt;h3&gt;StrictHostKeyChecking 설정을 off 하여 해결&lt;/h3&gt;
&lt;p&gt;리눅스에서 ssh 설정은 보통 &lt;code&gt;/etc/ssh&lt;/code&gt; 디렉터리에 있다. &lt;code&gt;ssh_config&lt;/code&gt; 파일은 클라이언트 설정 파일, &lt;code&gt;sshd_config&lt;/code&gt; 는 서버(데몬) 설정 파일이다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ssh_config&lt;/code&gt; 파일에서 아래 내용을 찾아서 호스트 키 검사를 하지 않도록 설정하면 된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;StrictHostKeyChecking no
&lt;span class="nv"&gt;UserKnownHostsFile&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/dev/null
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;호스트 키 새로 생성하는 방법&lt;/h2&gt;
&lt;p&gt;서버를 운영하는 입장에서 서버를 추가할 때 기존 서버의 이미지를 사용해서 새로운 서버를 구성할 수 있다. 이 때 호스트 키를 새롭게 생성해야 한다.&lt;/p&gt;
&lt;p&gt;호스트 키는 보통 &lt;code&gt;/etc/ssh&lt;/code&gt; 에 저장되어 있다. &lt;em&gt;RSA&lt;/em&gt;, &lt;em&gt;DSA&lt;/em&gt;, &lt;em&gt;ECDSA&lt;/em&gt; 세 가지 종류의 키 파일들이 보통 생성되어 있다.&lt;/p&gt;
&lt;p&gt;새로 호스트 키를 생성하기 위해 아래 명령을 실행해서 세 가지 종류의 호스트 키 파일들을 생성하면 된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo ssh-keygen -f /etc/ssh/ssh_host_rsa_key -N &lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt; -t rsa
sudo ssh-keygen -f /etc/ssh/ssh_host_dsa_key -N &lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt; -t dsa
sudo ssh-keygen -f /etc/ssh/ssh_host_ecdsa_key -N &lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt; -t ecdsa -b 521
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;기존에 파일들이 있으면 overwrite 할 거냐고 묻는데 당연히 &lt;code&gt;y&lt;/code&gt; 를 입력하자.&lt;/p&gt;</content><category term="SSH"></category></entry></feed>