<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>garret - dev-issues</title><link href="https://imjang57.github.io/garret/" rel="alternate"></link><link href="https://imjang57.github.io/garret/feeds/dev-issues.atom.xml" rel="self"></link><id>https://imjang57.github.io/garret/</id><updated>2017-01-03T00:00:00+09:00</updated><entry><title>Function, Method, Procedure</title><link href="https://imjang57.github.io/garret/function-and-method.html" rel="alternate"></link><published>2017-01-03T00:00:00+09:00</published><updated>2017-01-03T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-03:/garret/function-and-method.html</id><summary type="html">&lt;p&gt;Function, Method, Procedure 의 차이점&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Function and Method&lt;/h1&gt;
&lt;p&gt;보통 function 과 method 를 구분 없이 사용한다. 하지만 이들은 엄연히 다른 개념이다. 서브루틴, 함수, 메서드, 프로시저 모두 비슷하지만 각자 의미가 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Sub-routine : A sub-routne is A repeatable piece of procedural code you can call by name.&lt;/li&gt;
&lt;li&gt;Function : A function is a sub-routine that returns one or more values. A function should calculate its return value based on its input.&lt;/li&gt;
&lt;li&gt;Procedure : A procedure is a sub-routine that doesn not return a value, but does have side-effects. (such as writing to a file, printing to the screen, or modifying the value of its input)&lt;/li&gt;
&lt;li&gt;Method : A method is a function or procedure that is executed in the context of an object. A Method calculates a new value or trigger side-effect based on the values of its inputs and/or the scope of the object instance&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;보통 개발자들은 이들 단어에 대해 별 다른 구분없이 비슷한 의미로 사용한다. 하지만 Programming Language Theory 에서는 확실히 다르다.&lt;/p&gt;
&lt;p&gt;이런 단어들의 의미를 무시해도 상관없을까? 사실 대부분의 경우 무시해도 큰 상관은 없다고 생각된다. 하지만 어떤 로직을 모듈화하여 서브루틴으로 만들 때 이것들을 고려하면 더 좋다고 생각한다. 이 서브루틴은 어떤 타입의 서브루틴으로 구현해야 하는지 고민하면 그 서브루틴의 역할이나 목적을 더 명확해질 것이다. 서브루틴의 역할이나 목적이 명확해지면, 하나의 서브루틴이 과도하게 많은 역할을 하게 되는 현상을 방지할 수 있을 것이다. 프로그래밍에서 중요한 중복 제거, 모듈화에 대한 자연스러운 의식의 흐름이 생기게 되고 결과적으로 코드가 단순하지고 관리하기 좋아질 것이다. 어쨌든 좋은 함수를 만들기 위한 고민은 항상 필요하다고 생각한다.&lt;/p&gt;
&lt;p&gt;물론, 실제 개발할 때 시간에 쫓겨 항상 이런 고민을 하지 못한다..ㅠㅠ.. 그래도 항상 고민하려고 노력하자. 개발은 사람이 하는 일이라 의식의 흐름에 영향을 받으니, 의식의 흐름을 항상 올바로 하려고 노력하자.&lt;/p&gt;</content><category term="function"></category><category term="method"></category><category term="procedure"></category><category term="sub-routine"></category></entry><entry><title>Parameter and Argument</title><link href="https://imjang57.github.io/garret/parameter-and-argument.html" rel="alternate"></link><published>2017-01-03T00:00:00+09:00</published><updated>2017-01-03T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-03:/garret/parameter-and-argument.html</id><summary type="html">&lt;p&gt;Parameter 와 Argument 의 정확한 의미&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Parameter and Argument&lt;/h1&gt;
&lt;p&gt;많은 개발자들이 Parameter 와 Argument 를 딱히 구분하지 않고 사용한다. 그런데 이 둘은 엄연히 다르며, 그러다 보니 논쟁하다보면 맥락이 어긋나는 경우가 발생한다.&lt;/p&gt;
&lt;p&gt;K&amp;amp;R 의 C Programming Language Second Edition 에 다음과 같이 언급한다.&lt;/p&gt;
&lt;p&gt;We well generally use parameter for a variable named in the parenthesized list in a function definition, and argument for the value used in a call of the function.&lt;/p&gt;
&lt;p&gt;즉, Parameter(파라미터, 매개변수)는 함수 선언에서 사용되는 변수의 이름을 뜻하며, Argument(인자, 전달인자)는 함수를 호출할 때 전달되는 값을 의미한다.&lt;/p&gt;</content><category term="parameter"></category><category term="argument"></category></entry><entry><title>Java version 을 체크하는 bash script</title><link href="https://imjang57.github.io/garret/bash-script-checking-java-version.html" rel="alternate"></link><published>2016-12-30T00:00:00+09:00</published><updated>2016-12-30T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2016-12-30:/garret/bash-script-checking-java-version.html</id><summary type="html">&lt;p&gt;Java version 을 체크하기 위한 bash script&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Check Java version from bash script&lt;/h1&gt;
&lt;p&gt;리눅스에서 자바 버전을 체크하기 위한 꼼수 스크립트를 간단하게 작성해서 저장하기 위한 글입니다.&lt;/p&gt;
&lt;p&gt;java -version 명령의 결과:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ java -version
java version &lt;span class="s2"&gt;&amp;quot;1.8.0_73&amp;quot;&lt;/span&gt;
Java&lt;span class="o"&gt;(&lt;/span&gt;TM&lt;span class="o"&gt;)&lt;/span&gt; SE Runtime Environment &lt;span class="o"&gt;(&lt;/span&gt;build 1.8.0_73-b02&lt;span class="o"&gt;)&lt;/span&gt;
Java HotSpot&lt;span class="o"&gt;(&lt;/span&gt;TM&lt;span class="o"&gt;)&lt;/span&gt; 64-Bit Server VM &lt;span class="o"&gt;(&lt;/span&gt;build 25.73-b02, mixed mode&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;환경변수 $JAVA_HOME을 찾아서 하는 bash script:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/bin/bash&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; -n &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$JAVA_HOME&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;then&lt;/span&gt;
  &lt;span class="nv"&gt;JAVA_CMD&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$JAVA_HOME&lt;/span&gt;&lt;span class="s2"&gt;/bin/java&amp;quot;&lt;/span&gt;
  &lt;span class="nv"&gt;JAVA_VERSION&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;$JAVA_CMD&lt;/span&gt; -version 2&amp;gt;&lt;span class="p"&gt;&amp;amp;&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; awk -F&lt;span class="s1"&gt;&amp;#39;&amp;quot;&amp;#39;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;/version/ {print $2}&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; awk -F&lt;span class="s1"&gt;&amp;#39;_&amp;#39;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;{print $1}&amp;#39;&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;
  &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Run using java version &lt;/span&gt;&lt;span class="nv"&gt;$JAVA_VERSION&lt;/span&gt;&lt;span class="s2"&gt; (JAVA_HOME is &lt;/span&gt;&lt;span class="nv"&gt;$JAVA_HOME&lt;/span&gt;&lt;span class="s2"&gt;)&amp;quot;&lt;/span&gt;
  &lt;span class="o"&gt;[[&lt;/span&gt; &lt;span class="nv"&gt;$JAVA_VERSION&lt;/span&gt; &amp;gt; 1.8 &lt;span class="o"&gt;]]&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="nv"&gt;$?&lt;/span&gt; -eq &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
  &lt;span class="k"&gt;then&lt;/span&gt;
    &lt;span class="nb"&gt;echo&lt;/span&gt; This java version is greater than 1.8.
  &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="nb"&gt;echo&lt;/span&gt; This java version is not supported.
  &lt;span class="k"&gt;fi&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;
  &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Java doesn&amp;#39;t exists.&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;fi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;자바 실행 파일 위치를 찾아서 하는 bash script:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/bin/bash&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;which java&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;then&lt;/span&gt;
  &lt;span class="nv"&gt;JAVA_PATH&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;whereis java&lt;span class="k"&gt;)&lt;/span&gt;
  &lt;span class="nv"&gt;JAVA_VERSION&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;java -version 2&amp;gt;&lt;span class="p"&gt;&amp;amp;&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; awk -F&lt;span class="s1"&gt;&amp;#39;&amp;quot;&amp;#39;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;/version/ {print $2}&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; awk -F&lt;span class="s1"&gt;&amp;#39;_&amp;#39;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;{print $1}&amp;#39;&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;
  &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Run using java version &lt;/span&gt;&lt;span class="nv"&gt;$JAVA_VERSION&lt;/span&gt;&lt;span class="s2"&gt; (&lt;/span&gt;&lt;span class="nv"&gt;$JAVA_PATH&lt;/span&gt;&lt;span class="s2"&gt;)&amp;quot;&lt;/span&gt;
  &lt;span class="o"&gt;[[&lt;/span&gt; &lt;span class="nv"&gt;$JAVA_VERSION&lt;/span&gt; &amp;gt; 1.8 &lt;span class="o"&gt;]]&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="nv"&gt;$?&lt;/span&gt; -eq &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
  &lt;span class="k"&gt;then&lt;/span&gt;
    &lt;span class="nb"&gt;echo&lt;/span&gt; This java version is greater than 1.8.
  &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="nb"&gt;echo&lt;/span&gt; This java version is not supported.
  &lt;span class="k"&gt;fi&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;
  &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Java doesn&amp;#39;t exists.&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;fi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;두 방법이 사실 거의 똑같다. 그냥 whereis 명령을 이용하느냐, JAVA_HOME 이라는 환경변수를 이용하느냐만 다르다.&lt;/p&gt;
&lt;p&gt;다른 방법으로는 sort 명령을 이용해서 가장 앞에 위치하는 녀석을 비교하는 방법도 있다.&lt;/p&gt;
&lt;p&gt;처음에는 bc 명령을 사용하려 했는데 버전은 보통 여러 개의 comma(.)로 되어있어서 bc 로 사용은 불가능했다. 사실 comma(.) 단위로 나눠서 각각 비교하는 로직 구현하면 되는데 귀찮음이 커서..&lt;/p&gt;
&lt;p&gt;이 방법은 사실 완벽한 방법은 아니다. awk 로 추출한 문자열이 x.y.z 형태라는 걸 알고 있기 때문에 가능한 방법이다. 만약 1.8 로 버전이 추출되면 제대로 동작 안할 것이다. 제대로 하려면 comma(.) 단위로 나눠서 제대로 비교하는 함수를 만들어야 겠지..&lt;/p&gt;</content><category term="bash"></category></entry><entry><title>자바에서 % 출력하기</title><link href="https://imjang57.github.io/garret/print-percent-sign-in-java.html" rel="alternate"></link><published>2016-12-30T00:00:00+09:00</published><updated>2016-12-30T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2016-12-30:/garret/print-percent-sign-in-java.html</id><summary type="html">&lt;p&gt;자바에서 % 문자 출력하기&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Java String 에서 % 문자 출력하기&lt;/h1&gt;
&lt;p&gt;오늘 개발하다가 &lt;code&gt;%&lt;/code&gt; 문자가 들어가는 문자열을 처리할 일이 있었다. 처음에 아무 생각없이 아래처럼 작성했다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;str1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;test&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;str2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;format&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;string is \&amp;quot;%%s%\&amp;quot;.&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;str1&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;원하는 결과는 아래와 같이 나오는 것이었다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;string is &amp;quot;%test%&amp;quot;.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;당연히 String.format 에서 에러가 발생했다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Exception in thread &amp;quot;main&amp;quot; java.util.UnknownFormatConversionException: Conversion = &amp;#39;&amp;quot;&amp;#39;
 at java.util.Formatter.checkText(Formatter.java:2579)
 at java.util.Formatter.parse(Formatter.java:2565)
 at java.util.Formatter.format(Formatter.java:2501)
 at java.util.Formatter.format(Formatter.java:2455)
 at java.lang.String.format(String.java:2940)
 at StringTest.main(StringTest.java:7)
 at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
 at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
 at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
 at java.lang.reflect.Method.invoke(Method.java:497)
 at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;\&lt;/code&gt; 는 특정 &lt;em&gt;espace character&lt;/em&gt; 로 이미 약속된 문자들과 사용돼야 한다. 그런데 그 문자들 중에 &lt;code&gt;%&lt;/code&gt; 는 없다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;%&lt;/code&gt; 는 &lt;em&gt;Formatting&lt;/em&gt; 을 위한 문자로, &lt;code&gt;String.format("%d", 123);&lt;/code&gt; 과 같이 사용된다. 이 때 &lt;code&gt;%&lt;/code&gt; 자체를 출력하기 위해서도 &lt;code&gt;%&lt;/code&gt; 를 prefix 로 사용하여 &lt;code&gt;%%&lt;/code&gt; 와 같이 처리해야 한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;str1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;test&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;str2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;format&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;string is %%%s%%.&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;str1&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;%&lt;/code&gt; 는 그냥 문자가 아니라 포맷을 지정하기 위한 포맷 지시자 (format specifier 또는 format string) 역할을 하는 특수한 문자이기 때문이다.&lt;/p&gt;
&lt;p&gt;알고 있던 거였는데.. 역시 오래동안 안쓰면 머리에서 삭제되어 버린다. ㅠㅠ&lt;/p&gt;</content></entry><entry><title>SSH Host-key identification</title><link href="https://imjang57.github.io/garret/ssh-host-key-identification.html" rel="alternate"></link><published>2016-12-30T00:00:00+09:00</published><updated>2016-12-30T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2016-12-30:/garret/ssh-host-key-identification.html</id><summary type="html">&lt;p&gt;This is about SSH Host-key identification.&lt;/p&gt;</summary><content type="html">&lt;h1&gt;SSH host key&lt;/h1&gt;
&lt;p&gt;가끔 SSH Client 로 Remote 에 있는 SSH Server 에 접속할 때 아래와 같은 에러를 볼 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;imjang57@myserver:~$ ssh administrator@192.168.0.5
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!              @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now &lt;span class="o"&gt;(&lt;/span&gt;man-in-the-middle
attack&lt;span class="o"&gt;)&lt;/span&gt;!
It is also possible that a host key has just been changed.
The fingerprint &lt;span class="k"&gt;for&lt;/span&gt; the ECDSA key sent by the remote host is
bf:e3:d3:21:c4:3c:60:cd:d9:2b:bb:a4:d1:6e:1f:df.
Please contact your system administrator.
Add correct host key in /home/imjang57/.ssh/known_hosts to get rid of
this message.
Offending ECDSA key in /home/imjang57/.ssh/known_hosts:8
  remove with: ssh-keygen -f &lt;span class="s2"&gt;&amp;quot;/home/imjang57/.ssh/known_hosts&amp;quot;&lt;/span&gt; -R
192.168.0.5
ECDSA host key &lt;span class="k"&gt;for&lt;/span&gt; 192.168.0.5 has changed and you have
requested strict checking.
Host key verification failed.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;em&gt;Host Key&lt;/em&gt; 가 달라서 발생하는 문제다. 자세히 말하면, 클라이언트 측에 등록된 SSH 서버의 호스트 키가 현재 접속 시도하면서 새롭게 받은 호스크 키와 달라서 발생한 문제이다.&lt;/p&gt;
&lt;p&gt;SSH 서버에서 호스트 키를 새롭게 생성했거나, 클라이언트 측에서 SSH 서버의 호스트 키를 수동으로 입력했는데 잘못입력했거나, 서버를 재설치했거나, 기타 등등의 이유로 기존에 저장된 호스트 키와 연결시도하면서 새롭게 받은 호스트 키가 다를 수 있다.&lt;/p&gt;
&lt;p&gt;이는 SSH 연결을 시도하는 서버가 정말 내가 연결하려는 서버가 맞는지를 체크할 수 있는 기능이다. HTTPS 를 사용할 때 신뢰할 수 있는 사이트인지 확인하는 것과 비슷한 이유로 제공되는 기능이다.&lt;/p&gt;
&lt;h2&gt;해결 방법&lt;/h2&gt;
&lt;p&gt;해결하는 방법은 여러개가 있다.&lt;/p&gt;
&lt;h3&gt;known_host 삭제하여 해결&lt;/h3&gt;
&lt;p&gt;보통 사용자의 홈 디렉터리에 .ssh 라는 디렉터리가 있고, 여기에 사용자를 위한 SSH 설정이나 사용자 인증을 위한 키 파일이 저장된다. 그리고 &lt;user_home&gt;/.ssh 디렉터리 밑에 known_hosts 라는 파일이 있는데 여기에 SSH 서버의 호스트 키들이 저장되어 있다. 여기서 에러가 나는 SSH 서버의 호스트 키를 삭제하면 다시 연결할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ssh-keygen -f &lt;span class="s2"&gt;&amp;quot;/home/imjang57/.ssh/known_hosts&amp;quot;&lt;/span&gt; -R 192.168.0.5
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;위 명령으로 저장된 서버의 호스트 키를 삭제한 후 SSH 서버에 다시 접속하면 아래와 같이 호스트 키를 등록하냐고 물어보는 메시지가 나타난다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;imjang57@myserver:~$ ssh administrator@192.168.0.5
The authenticity of host &lt;span class="s1"&gt;&amp;#39;192.168.0.5&amp;#39;&lt;/span&gt; can&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;t be established.
ECDSA key fingerprint is
bf:e3:d3:21:c4:3c:60:cd:d9:2b:bb:a4:d1:6e:1f:df.
Are you sure you want to &lt;span class="k"&gt;continue&lt;/span&gt; connecting &lt;span class="o"&gt;(&lt;/span&gt;yes/no&lt;span class="o"&gt;)&lt;/span&gt;?
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;yes 를 입력하면 호스트 키를 &lt;user_home&gt;/.ssh/known_hosts 파일에 저장하고 SSH 접속하게 된다.&lt;/p&gt;
&lt;p&gt;만약 명령어 치는게 귀찮으면 그냥 known_hosts 파일 삭제하면 된다.&lt;/p&gt;
&lt;h3&gt;StrictHostKeyChecking 설정을 off 하여 해결&lt;/h3&gt;
&lt;p&gt;리눅스에서 ssh 설정은 보통 &lt;code&gt;/etc/ssh&lt;/code&gt; 디렉터리에 있다. &lt;code&gt;ssh_config&lt;/code&gt; 파일은 클라이언트 설정 파일, &lt;code&gt;sshd_config&lt;/code&gt; 는 서버(데몬) 설정 파일이다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ssh_config&lt;/code&gt; 파일에서 아래 내용을 찾아서 호스트 키 검사를 하지 않도록 설정하면 된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;StrictHostKeyChecking no
&lt;span class="nv"&gt;UserKnownHostsFile&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/dev/null
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;호스트 키 새로 생성하는 방법&lt;/h2&gt;
&lt;p&gt;서버를 운영하는 입장에서 서버를 추가할 때 기존 서버의 이미지를 사용해서 새로운 서버를 구성할 수 있다. 이 때 호스트 키를 새롭게 생성해야 한다.&lt;/p&gt;
&lt;p&gt;호스트 키는 보통 &lt;code&gt;/etc/ssh&lt;/code&gt; 에 저장되어 있다. &lt;em&gt;RSA&lt;/em&gt;, &lt;em&gt;DSA&lt;/em&gt;, &lt;em&gt;ECDSA&lt;/em&gt; 세 가지 종류의 키 파일들이 보통 생성되어 있다.&lt;/p&gt;
&lt;p&gt;새로 호스트 키를 생성하기 위해 아래 명령을 실행해서 세 가지 종류의 호스트 키 파일들을 생성하면 된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo ssh-keygen -f /etc/ssh/ssh_host_rsa_key -N &lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt; -t rsa
sudo ssh-keygen -f /etc/ssh/ssh_host_dsa_key -N &lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt; -t dsa
sudo ssh-keygen -f /etc/ssh/ssh_host_ecdsa_key -N &lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt; -t ecdsa -b 521
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;기존에 파일들이 있으면 overwrite 할 거냐고 묻는데 당연히 &lt;code&gt;y&lt;/code&gt; 를 입력하자.&lt;/p&gt;</content><category term="SSH"></category></entry></feed>