<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>garret - programming</title><link href="https://imjang57.github.io/garret/" rel="alternate"></link><link href="https://imjang57.github.io/garret/feeds/programming.atom.xml" rel="self"></link><id>https://imjang57.github.io/garret/</id><updated>2017-01-18T00:00:00+09:00</updated><entry><title>NPE (NullPointerException) 을 피하자</title><link href="https://imjang57.github.io/garret/avoid-null-pointer-exception-in-java.html" rel="alternate"></link><published>2017-01-18T00:00:00+09:00</published><updated>2017-01-18T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-18:/garret/avoid-null-pointer-exception-in-java.html</id><summary type="html">&lt;p&gt;Java 에서 NPE (NullPointerException) 을 피하면서 코딩하기 위한 습관들&lt;/p&gt;</summary><content type="html">&lt;h1&gt;NPE(NullPointerException) 을 피하자.&lt;/h1&gt;
&lt;p&gt;자바 개발을 하다보면 가장 많이 만나고 영향이 큰 예외 중 하나가 &lt;em&gt;NPE&lt;/em&gt; 이다. NPE 는 개발자의 습관이나 부주의 등이 대부분 원인이다. 이를 예방하는 가장 좋은 방법은 NPE 를 피하는 코딩 습관을 갖는 것이다.&lt;/p&gt;
&lt;h2&gt;null 의 의미&lt;/h2&gt;
&lt;p&gt;자바에서 &lt;code&gt;null&lt;/code&gt; 이란 아래와 같은 상태를 의미한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;아직 object 가 생성되지 않은 상태, 즉 아직 memory 할당이 되지 않은 object 상태&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;NPE 는 null 상태인 object 를 참조하여 어떠한 행위(method 실행)를 하려할 때 발생하는 예외이다.&lt;/p&gt;
&lt;h2&gt;NPE가 발생하는 상황&lt;/h2&gt;
&lt;p&gt;NPE 는 아래와 같은 상황에서 발생할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;null object 의 method 를 호출&lt;/li&gt;
&lt;li&gt;null object 의 instance member 에 접근&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Avoid NPE in source code&lt;/h1&gt;
&lt;p&gt;NPE 는 대부분 개발자의 부주의로 발생하므로, 개발할 때 조금만 신경쓰면 대부분의 NPE 를 예방할 수 있다.&lt;/p&gt;
&lt;h2&gt;String 객체를 비교할 경우&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;equals()&lt;/code&gt;, &lt;code&gt;equalsIgnoreCase()&lt;/code&gt; 등을 사용할 때 null 이 아닌 것이 확실한 객체가 있다면 해당 객체의 method 를 호출하자.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt; &lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="n"&gt;Compare&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;equals&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;testStr&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
 &lt;span class="c1"&gt;// logic&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;String.valueOf() 사용&lt;/h2&gt;
&lt;p&gt;로그 등을 남길 때 객체의 상태를 확인하기 위해 객체의 &lt;code&gt;toString()&lt;/code&gt; 을 호출하는 경우가 있는데, 객체가 null 일 경우 NPE 가 발생한다. 로그를 위해 null 을 체크하는 로직을 추가하는 것은 불필요한 코드가 될 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;toString()&lt;/code&gt; method 보다는 &lt;code&gt;String.valueOf()&lt;/code&gt; 를 사용하자.&lt;/p&gt;
&lt;h2&gt;Primitive type 사용&lt;/h2&gt;
&lt;p&gt;꼭 필요한 경우가 아니라면 Primitive type data 를 사용하자. NPE 를 줄이고 memory 도 더 효율적으로 사용할 수 있다.&lt;/p&gt;
&lt;h2&gt;return empty collection&lt;/h2&gt;
&lt;p&gt;List, Set, Map 등과 같은 Collection 을 return 하는 method 를 구현할 때, null 을 return 하지 말자. 대신 empty collection 을 return 하자. 그러면 함수를 사용하는 개발자는 불필요한 null 체크를 하지 않아도 된다.&lt;/p&gt;
&lt;h2&gt;Use null-safe stuffs&lt;/h2&gt;
&lt;p&gt;null 에 안전한 자바 내장 함수나 commons-lang 과 같은 helper class 를 사용하자. Apache Commons 도 좋고, 요즘은 Googld guava 가 매우 유용한 라이브러리들을 많이 제공한다.&lt;/p&gt;
&lt;h2&gt;Unit Test&lt;/h2&gt;
&lt;p&gt;Java assert, Unit test (JUnit) 등을 활용하여 사전 확인 및 다양한 상황에서의 테스트를 수행하자.&lt;/p&gt;
&lt;h2&gt;협업할 때는 기능 및 제약사항 등을 확실히 명시하자.&lt;/h2&gt;
&lt;p&gt;NPE 는 개발자의 부주의에 의해 대부분 발생하고, 개발자의 부주의는 정보가 없어서 발생하는 경우가 많다. 아래의 내용들은 명확하게 공유하자.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Method parameter 와 return value 에 대한 명세&lt;/li&gt;
&lt;li&gt;Method 에서 수행하는 validation 으로 인해 발생가능한 Exception 들&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="https://github.com/google/guava"&gt;Google guava&lt;/a&gt; 의 &lt;em&gt;Preconditions&lt;/em&gt; 등을 사용하면 parameter 에 대한 validation 을 쉽게 처리할 수 있다.&lt;/p&gt;
&lt;p&gt;또한 &lt;em&gt;Java Doc&lt;/em&gt; 등의 문서를 적절히 사용하자. 자동으로 Java doc 을 생성해주는 프로그램도 많다. 또는 &lt;a href="http://swagger.io"&gt;swagger&lt;/a&gt; 등을 이용하여 RestAPI 서비스의 API 에 대한 명세를 공유할 수도 있다.&lt;/p&gt;
&lt;p&gt;문서의 내용을 자세하게 채우지 않아도 된다. 위의 내용들에 대해서만이라도 명확하게 작성하자.&lt;/p&gt;
&lt;h2&gt;Optional class&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Optional&lt;/em&gt; 을 사용하면 null check 를 위한 코드를 상당히 줄일 수 있으며 코드의 Readability 를 높일 수 있다.&lt;/p&gt;
&lt;p&gt;Optional 은 원래 google guava 라이브러리에서 제공되었었는데 java 8 로 버전 업하면서 자바에서도 지원(&lt;code&gt;java.util.Optional&amp;lt;T&amp;gt;&lt;/code&gt;)하게 되었다.&lt;/p&gt;
&lt;p&gt;Optional object 생성:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;nStr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="n"&gt;Test&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;Optional&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;eOp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Optional&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;empty&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// empty Optional 객체 생성&lt;/span&gt;
&lt;span class="n"&gt;Optional&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;nullableOp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Optional&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ofNullable&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nStr&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// null 을 허용하는 Optional 객체 생성&lt;/span&gt;
&lt;span class="n"&gt;Optional&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;notNullableOp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Optional&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;of&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// str 에 접근하는 시점이 아니라 Optional 객체를 생성하는 이 순간 parameter 의 null 여부를 체크하여 NPE 가 발생&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt; &lt;span class="n"&gt;notNullableOp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;isPresent&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
 &lt;span class="c1"&gt;// Optional 객체에 값이 있는지 확인 후 아래 코드를 실행&lt;/span&gt;
 &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;notNullableOp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;get&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;notNullableOp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ifPresent&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Optional 객체에 값이 있는지 확인 후 전달받은 function 을 실행&lt;/span&gt;
&lt;span class="n"&gt;notNullableOp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ifPresent&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;});&lt;/span&gt;
&lt;span class="n"&gt;nullableOp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ifPresent&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// null 이므로 실행되지 않는다.&lt;/span&gt;
&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;emtpyStr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;eOp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;orElse&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="n"&gt;Empty&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Optional 객체가 empty 일 경우 (null 일 경우) “Empty String” 의 reference 를 return.&lt;/span&gt;
&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;exStr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;eOp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;orElseThrow&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Exception&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Optional 객체가 empty 일 경우 (null 일 경우) 지정된 Exception 을 throw.&lt;/span&gt;
&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;notNullableOp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;filter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;length&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="na"&gt;orElse&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="n"&gt;Too&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Optional 과 map 을 이용하여 null check 없이 jsonNode 접근하기:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Optional&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;of&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rootNode&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
 &lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;map&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;get&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="n"&gt;secondNode&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
 &lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;map&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;get&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="n"&gt;thirdNode&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
 &lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ifPresent&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
 &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;get&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;
 &lt;span class="o"&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;if else 를 이용한 null 체크는 source code readability 를 떨어뜨린다. Optional 과 Java doc 을 이용한 직관적인 코드 작성을 하자.&lt;/p&gt;</content><category term="java"></category><category term="NPE"></category><category term="NullPointerException"></category><category term="null"></category></entry><entry><title>Granularity (Coarse-grained V.S. Fine-grained)</title><link href="https://imjang57.github.io/garret/granularity-coarse-grained-and-fine-grained.html" rel="alternate"></link><published>2017-01-04T00:00:00+09:00</published><updated>2017-01-04T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-04:/garret/granularity-coarse-grained-and-fine-grained.html</id><summary type="html">&lt;p&gt;Granularity (Coarse-grained V.S. Fine-grained) 의 의미&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Coarse-grained V.S. Fine-grained in Spark&lt;/h1&gt;
&lt;p&gt;Coarse-grained 와 Fine-grained 는 한국말로 번역하기가 참 애매한 단어이다. 그래서 의미도 잘 와닿지 않는다.&lt;/p&gt;
&lt;p&gt;Quora 에 누군가가 &lt;a href="https://www.quora.com/What-does-coarse-grained-mean-in-Spark-RDD"&gt;Spark RDD 에서 사용되는 Coarse-grained 의 개념에 대해 질문&lt;/a&gt;하였는데, 누군가가 coarse-grained 에 대해 아래와 같이 설명한다.:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Basically, it means that you can write you transformations to be applied to the while dataset, but not individual elements on the dataset. Operations like map, filter, group reduce, but not get(index) or set(index).&lt;/p&gt;
&lt;p&gt;By restricting RDD operations to coarse-grained immutable transformations, Spark is able to provide powerful distributed data processing, while keeping the system fairly simple to understand and operate.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Coarse-grained 와 Fine-grained 는 원래 곡식을 낟알로 만들 때 대충 작업하여 낟알을 거칠하는 것과 세심하게 하여 낟알을 부드럽게 하는 것을 의미한다. 소프트웨어 공학에서 Coarse-grained 와 Fine-grained 는 어떤 작업(Process, Wordload)의 분할 단위가 큰가 작은가를 구분하는 상대적인 의미로 사용된다.&lt;/p&gt;
&lt;p&gt;얼마나 세분화 되었는가? 모듈화 되었는가? 한국말로 표현하기가 좀 애매한데, 여튼 어느 정도 grain 되었는지를 나타내는 것을 granularity 라고 한다. 이 &lt;a href="https://en.wikipedia.org/wiki/Granularity"&gt;Granularity&lt;/a&gt;에 대한 위키피디아 페이지에 다음과 같은 언급이 있다.:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Coarse-grained materials or systems have fewer, larger discrete components than fine-grained materials or systems.&lt;/p&gt;
&lt;p&gt;The concepts granularity, coarseness, and fineness are relative, used when comparing systems or descriptions of systems.&lt;/p&gt;
&lt;/blockquote&gt;</content><category term="granularity"></category><category term="coarse-grained"></category><category term="fine-grained"></category><category term="programming"></category></entry><entry><title>Function, Method, Procedure</title><link href="https://imjang57.github.io/garret/function-and-method.html" rel="alternate"></link><published>2017-01-03T00:00:00+09:00</published><updated>2017-01-03T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-03:/garret/function-and-method.html</id><summary type="html">&lt;p&gt;Function, Method, Procedure 의 차이점&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Function, Method, Procedure&lt;/h1&gt;
&lt;p&gt;보통 function 과 method 를 구분 없이 사용한다. 하지만 이들은 엄연히 다른 개념이다. 서브루틴, 함수, 메서드, 프로시저 모두 비슷하지만 각자 의미가 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Sub-routine : A sub-routne is A repeatable piece of procedural code you can call by name.&lt;/li&gt;
&lt;li&gt;Function : A function is a sub-routine that returns one or more values. A function should calculate its return value based on its input.&lt;/li&gt;
&lt;li&gt;Procedure : A procedure is a sub-routine that doesn not return a value, but does have side-effects. (such as writing to a file, printing to the screen, or modifying the value of its input)&lt;/li&gt;
&lt;li&gt;Method : A method is a function or procedure that is executed in the context of an object. A Method calculates a new value or trigger side-effect based on the values of its inputs and/or the scope of the object instance&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;보통 개발자들은 이들 단어에 대해 별 다른 구분없이 비슷한 의미로 사용한다. 하지만 Programming Language Theory 에서는 확실히 다르다.&lt;/p&gt;
&lt;p&gt;이런 단어들의 의미를 무시해도 상관없을까? 사실 대부분의 경우 무시해도 큰 상관은 없다고 생각된다. 하지만 어떤 로직을 모듈화하여 서브루틴으로 만들 때 이것들을 고려하면 더 좋다고 생각한다. 이 서브루틴은 어떤 타입의 서브루틴으로 구현해야 하는지 고민하면 그 서브루틴의 역할이나 목적을 더 명확해질 것이다. 서브루틴의 역할이나 목적이 명확해지면, 하나의 서브루틴이 과도하게 많은 역할을 하게 되는 현상을 방지할 수 있을 것이다. 프로그래밍에서 중요한 중복 제거, 모듈화에 대한 자연스러운 의식의 흐름이 생기게 되고 결과적으로 코드가 단순하지고 관리하기 좋아질 것이다. 어쨌든 좋은 함수를 만들기 위한 고민은 항상 필요하다고 생각한다.&lt;/p&gt;
&lt;p&gt;물론, 실제 개발할 때 시간에 쫓겨 항상 이런 고민을 하지 못한다..ㅠㅠ.. 그래도 항상 고민하려고 노력하자. 개발은 사람이 하는 일이라 의식의 흐름에 영향을 받으니, 의식의 흐름을 항상 올바로 하려고 노력하자.&lt;/p&gt;</content><category term="function"></category><category term="method"></category><category term="procedure"></category><category term="sub-routine"></category><category term="programming"></category></entry><entry><title>Parameter and Argument</title><link href="https://imjang57.github.io/garret/parameter-and-argument.html" rel="alternate"></link><published>2017-01-03T00:00:00+09:00</published><updated>2017-01-03T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-03:/garret/parameter-and-argument.html</id><summary type="html">&lt;p&gt;Parameter 와 Argument 의 정확한 의미&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Parameter and Argument&lt;/h1&gt;
&lt;p&gt;많은 개발자들이 Parameter 와 Argument 를 딱히 구분하지 않고 사용한다. 그런데 이 둘은 엄연히 다르며, 그러다 보니 논쟁하다보면 맥락이 어긋나는 경우가 발생한다.&lt;/p&gt;
&lt;p&gt;K&amp;amp;R 의 C Programming Language Second Edition 에 다음과 같이 언급한다.&lt;/p&gt;
&lt;p&gt;We well generally use parameter for a variable named in the parenthesized list in a function definition, and argument for the value used in a call of the function.&lt;/p&gt;
&lt;p&gt;즉, Parameter(파라미터, 매개변수)는 함수 선언에서 사용되는 변수의 이름을 뜻하며, Argument(인자, 전달인자)는 함수를 호출할 때 전달되는 값을 의미한다.&lt;/p&gt;</content><category term="parameter"></category><category term="argument"></category><category term="programming"></category></entry><entry><title>자바에서 % 출력하기</title><link href="https://imjang57.github.io/garret/print-percent-sign-in-java.html" rel="alternate"></link><published>2016-12-30T00:00:00+09:00</published><updated>2016-12-30T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2016-12-30:/garret/print-percent-sign-in-java.html</id><summary type="html">&lt;p&gt;자바에서 % 문자 출력하기&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Java String 에서 % 문자 출력하기&lt;/h1&gt;
&lt;p&gt;오늘 개발하다가 &lt;code&gt;%&lt;/code&gt; 문자가 들어가는 문자열을 처리할 일이 있었다. 처음에 아무 생각없이 아래처럼 작성했다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;str1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;test&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;str2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;format&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;string is \&amp;quot;%%s%\&amp;quot;.&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;str1&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;원하는 결과는 아래와 같이 나오는 것이었다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;string is &amp;quot;%test%&amp;quot;.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;당연히 String.format 에서 에러가 발생했다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Exception in thread &amp;quot;main&amp;quot; java.util.UnknownFormatConversionException: Conversion = &amp;#39;&amp;quot;&amp;#39;
 at java.util.Formatter.checkText(Formatter.java:2579)
 at java.util.Formatter.parse(Formatter.java:2565)
 at java.util.Formatter.format(Formatter.java:2501)
 at java.util.Formatter.format(Formatter.java:2455)
 at java.lang.String.format(String.java:2940)
 at StringTest.main(StringTest.java:7)
 at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
 at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
 at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
 at java.lang.reflect.Method.invoke(Method.java:497)
 at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;\&lt;/code&gt; 는 특정 &lt;em&gt;espace character&lt;/em&gt; 로 이미 약속된 문자들과 사용돼야 한다. 그런데 그 문자들 중에 &lt;code&gt;%&lt;/code&gt; 는 없다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;%&lt;/code&gt; 는 &lt;em&gt;Formatting&lt;/em&gt; 을 위한 문자로, &lt;code&gt;String.format("%d", 123);&lt;/code&gt; 과 같이 사용된다. 이 때 &lt;code&gt;%&lt;/code&gt; 자체를 출력하기 위해서도 &lt;code&gt;%&lt;/code&gt; 를 prefix 로 사용하여 &lt;code&gt;%%&lt;/code&gt; 와 같이 처리해야 한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;str1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;test&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;str2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;format&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;string is %%%s%%.&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;str1&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;%&lt;/code&gt; 는 그냥 문자가 아니라 포맷을 지정하기 위한 포맷 지시자 (format specifier 또는 format string) 역할을 하는 특수한 문자이기 때문이다.&lt;/p&gt;
&lt;p&gt;알고 있던 거였는데.. 역시 오래동안 안쓰면 머리에서 삭제되어 버린다. ㅠㅠ&lt;/p&gt;</content></entry><entry><title>Integer types header file (stdint.h)</title><link href="https://imjang57.github.io/garret/integer-types-header-file-stdint.html" rel="alternate"></link><published>2016-01-02T00:00:00+09:00</published><updated>2016-01-02T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2016-01-02:/garret/integer-types-header-file-stdint.html</id><summary type="html">&lt;p&gt;C 언어의 Integer data type 의 크기를 정의한 stdint.h 헤더파일&lt;/p&gt;</summary><content type="html">&lt;h1&gt;uintXX_t data types in stdint.h&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;_t&lt;/code&gt; 는 구조체에 붙이는 것이라기 보다는 user-defined type 에 붙이는 것이다. &lt;code&gt;uint8_t&lt;/code&gt;, &lt;code&gt;uint32_t&lt;/code&gt; 등은 &lt;code&gt;stdint.h&lt;/code&gt; 헤더파일에 정의되어 있으며 C99 표준에서 도입되었다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;stdint.h&lt;/code&gt; : This header defines a set of integral type aliases with specific width requirements, along with macros specifying their limits and macro functions to create values of these types.&lt;/p&gt;
&lt;p&gt;C 언어 표준에는 &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt; 등과 같은 Primitive data type 을 지원한다. 하지만 표준에서 이런 type 들이 몇 bytes 를 필요로 하는지 정확한 정의를 하지 않았다. 때문에 Machine (CPU) 의 종류에 따라 &lt;code&gt;int&lt;/code&gt; 나 &lt;code&gt;long&lt;/code&gt; 등의 크기가 달라지게 되었다. (대부분은 &lt;code&gt;char&lt;/code&gt; 1 byte, &lt;code&gt;short&lt;/code&gt; 2 bytes, &lt;code&gt;int&lt;/code&gt; 4 bytes 로 알고 가르치지만 대부분의 machine 에서 이렇게 사용할 뿐이지 다 똑같은 건 아니다. 표준은 &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt; 에 대해 &lt;code&gt;short&lt;/code&gt; 은 최소 &lt;code&gt;int&lt;/code&gt; 보다 같거나 작아야 한다고 정의되어 있으며, &lt;code&gt;long&lt;/code&gt; 은 &lt;code&gt;int&lt;/code&gt; 보다 같거나 커야 한다고 정의되어 있을 뿐이다.) 이는 C 언어로 작성된 프로그램의 호환성(Portability) 에 매우 큰 악영향을 미칠 수 있는 요소였다.&lt;/p&gt;
&lt;p&gt;이러한 machine 에 따른 호환성 문제를 해결하기 위해 C99 표준에서는 &lt;code&gt;int8_t&lt;/code&gt;, &lt;code&gt;uint8_t&lt;/code&gt;, &lt;code&gt;int16_t&lt;/code&gt;, &lt;code&gt;uint16_t&lt;/code&gt;, &lt;code&gt;int32_t&lt;/code&gt;, &lt;code&gt;uint32_t&lt;/code&gt;, &lt;code&gt;int64_t&lt;/code&gt;, &lt;code&gt;uint64_t&lt;/code&gt; 등을 도입하였다.&lt;/p&gt;
&lt;p&gt;C99 에서 도입된 &lt;code&gt;stdint.h&lt;/code&gt; 는 이전에 존재하던 &lt;code&gt;limits.h&lt;/code&gt; 와는 성격이 다르다. 기존의 &lt;code&gt;limits.h&lt;/code&gt; 가 machine-dependent data type 의 크기를 서술한 것이라면, &lt;code&gt;stdint.h&lt;/code&gt; 는 data type 의 size 를 명확하게 정의한다. &lt;code&gt;limits.h&lt;/code&gt; 는 기계마다 다르게 정의되는 각 data type 의 크기만 알려줄 뿐이며, 원하는 크기의 자료형을 선언하는데는 크게 도움이 되지 않는다. 반면 &lt;code&gt;stdint.h&lt;/code&gt; 는 기존의 &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt; 과 같은 자료형을 보다 명확하게 수치로 나타낸다.&lt;/p&gt;
&lt;p&gt;32 비트 기계에서 16 비트 크기를 가지는 정수 자료형을 명확하게 선언하고 싶다면, &lt;code&gt;int16_t&lt;/code&gt; 를 사용하고, 32 비트 정수 자료형이라면 &lt;code&gt;int32_t&lt;/code&gt; 를 사용하여 선언한다. 기본 자료형을 다시 재정의하는 것은 쓸데없이 혼란을 가중시킬거라 생각할지도 모르지만, 이런 식으로 보다 명확하게 자료형을 재정의하는 것은 훨씬 명확한 코드를 작성하는데 도움이 된다. 부동소수점 자료형을 제외한 정수 자료형들은 모두 이런 &lt;code&gt;intN_t&lt;/code&gt; 스타일로 정의할 수 있는데, &lt;code&gt;char&lt;/code&gt; 도 &lt;code&gt;int8_t&lt;/code&gt; 와 같이 선언할 수 있다. C 에서 &lt;code&gt;char&lt;/code&gt; 타입은 정수형으로도 간주될 수 있기 때문이다. 자료형의 크기를 명확하게 밝혀준다는 장점 외에도, &lt;code&gt;unsigned int&lt;/code&gt; 와 같은 긴 문장을 간단하게 &lt;code&gt;uint32_t&lt;/code&gt; 로 표현할 수 있다는 장점도 있다. 호환성을 염두에 둔 코드를 작성한다면, &lt;code&gt;stdint.h&lt;/code&gt; 는 매우 편리한 존재가 아닐 수 없다. C99 에서 새롭게 도입된 &lt;code&gt;stdint.h&lt;/code&gt; 는 C++ 에도 &lt;code&gt;cstdint&lt;/code&gt; 헤더 파일로 포함되어 있다.&lt;/p&gt;</content><category term="c programming language"></category><category term="stdint.h"></category></entry></feed>