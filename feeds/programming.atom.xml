<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>garret - programming</title><link href="https://imjang57.github.io/garret/" rel="alternate"></link><link href="https://imjang57.github.io/garret/feeds/programming.atom.xml" rel="self"></link><id>https://imjang57.github.io/garret/</id><updated>2017-01-03T00:00:00+09:00</updated><entry><title>Function, Method, Procedure</title><link href="https://imjang57.github.io/garret/function-and-method.html" rel="alternate"></link><published>2017-01-03T00:00:00+09:00</published><updated>2017-01-03T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-03:/garret/function-and-method.html</id><summary type="html">&lt;p&gt;Function, Method, Procedure 의 차이점&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Function, Method, Procedure&lt;/h1&gt;
&lt;p&gt;보통 function 과 method 를 구분 없이 사용한다. 하지만 이들은 엄연히 다른 개념이다. 서브루틴, 함수, 메서드, 프로시저 모두 비슷하지만 각자 의미가 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Sub-routine : A sub-routne is A repeatable piece of procedural code you can call by name.&lt;/li&gt;
&lt;li&gt;Function : A function is a sub-routine that returns one or more values. A function should calculate its return value based on its input.&lt;/li&gt;
&lt;li&gt;Procedure : A procedure is a sub-routine that doesn not return a value, but does have side-effects. (such as writing to a file, printing to the screen, or modifying the value of its input)&lt;/li&gt;
&lt;li&gt;Method : A method is a function or procedure that is executed in the context of an object. A Method calculates a new value or trigger side-effect based on the values of its inputs and/or the scope of the object instance&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;보통 개발자들은 이들 단어에 대해 별 다른 구분없이 비슷한 의미로 사용한다. 하지만 Programming Language Theory 에서는 확실히 다르다.&lt;/p&gt;
&lt;p&gt;이런 단어들의 의미를 무시해도 상관없을까? 사실 대부분의 경우 무시해도 큰 상관은 없다고 생각된다. 하지만 어떤 로직을 모듈화하여 서브루틴으로 만들 때 이것들을 고려하면 더 좋다고 생각한다. 이 서브루틴은 어떤 타입의 서브루틴으로 구현해야 하는지 고민하면 그 서브루틴의 역할이나 목적을 더 명확해질 것이다. 서브루틴의 역할이나 목적이 명확해지면, 하나의 서브루틴이 과도하게 많은 역할을 하게 되는 현상을 방지할 수 있을 것이다. 프로그래밍에서 중요한 중복 제거, 모듈화에 대한 자연스러운 의식의 흐름이 생기게 되고 결과적으로 코드가 단순하지고 관리하기 좋아질 것이다. 어쨌든 좋은 함수를 만들기 위한 고민은 항상 필요하다고 생각한다.&lt;/p&gt;
&lt;p&gt;물론, 실제 개발할 때 시간에 쫓겨 항상 이런 고민을 하지 못한다..ㅠㅠ.. 그래도 항상 고민하려고 노력하자. 개발은 사람이 하는 일이라 의식의 흐름에 영향을 받으니, 의식의 흐름을 항상 올바로 하려고 노력하자.&lt;/p&gt;</content><category term="function"></category><category term="method"></category><category term="procedure"></category><category term="sub-routine"></category><category term="programming"></category></entry><entry><title>Parameter and Argument</title><link href="https://imjang57.github.io/garret/parameter-and-argument.html" rel="alternate"></link><published>2017-01-03T00:00:00+09:00</published><updated>2017-01-03T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-03:/garret/parameter-and-argument.html</id><summary type="html">&lt;p&gt;Parameter 와 Argument 의 정확한 의미&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Parameter and Argument&lt;/h1&gt;
&lt;p&gt;많은 개발자들이 Parameter 와 Argument 를 딱히 구분하지 않고 사용한다. 그런데 이 둘은 엄연히 다르며, 그러다 보니 논쟁하다보면 맥락이 어긋나는 경우가 발생한다.&lt;/p&gt;
&lt;p&gt;K&amp;amp;R 의 C Programming Language Second Edition 에 다음과 같이 언급한다.&lt;/p&gt;
&lt;p&gt;We well generally use parameter for a variable named in the parenthesized list in a function definition, and argument for the value used in a call of the function.&lt;/p&gt;
&lt;p&gt;즉, Parameter(파라미터, 매개변수)는 함수 선언에서 사용되는 변수의 이름을 뜻하며, Argument(인자, 전달인자)는 함수를 호출할 때 전달되는 값을 의미한다.&lt;/p&gt;</content><category term="parameter"></category><category term="argument"></category><category term="programming"></category></entry><entry><title>Integer types header file (stdint.h)</title><link href="https://imjang57.github.io/garret/integer-types-header-file-stdint.html" rel="alternate"></link><published>2016-01-02T00:00:00+09:00</published><updated>2016-01-02T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2016-01-02:/garret/integer-types-header-file-stdint.html</id><summary type="html">&lt;p&gt;C 언어의 Integer data type 의 크기를 정의한 stdint.h 헤더파일&lt;/p&gt;</summary><content type="html">&lt;h1&gt;uintXX_t data types in stdint.h&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;_t&lt;/code&gt; 는 구조체에 붙이는 것이라기 보다는 user-defined type 에 붙이는 것이다. &lt;code&gt;uint8_t&lt;/code&gt;, &lt;code&gt;uint32_t&lt;/code&gt; 등은 &lt;code&gt;stdint.h&lt;/code&gt; 헤더파일에 정의되어 있으며 C99 표준에서 도입되었다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;stdint.h&lt;/code&gt; : This header defines a set of integral type aliases with specific width requirements, along with macros specifying their limits and macro functions to create values of these types.&lt;/p&gt;
&lt;p&gt;C 언어 표준에는 &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt; 등과 같은 Primitive data type 을 지원한다. 하지만 표준에서 이런 type 들이 몇 bytes 를 필요로 하는지 정확한 정의를 하지 않았다. 때문에 Machine (CPU) 의 종류에 따라 &lt;code&gt;int&lt;/code&gt; 나 &lt;code&gt;long&lt;/code&gt; 등의 크기가 달라지게 되었다. (대부분은 &lt;code&gt;char&lt;/code&gt; 1 byte, &lt;code&gt;short&lt;/code&gt; 2 bytes, &lt;code&gt;int&lt;/code&gt; 4 bytes 로 알고 가르치지만 대부분의 machine 에서 이렇게 사용할 뿐이지 다 똑같은 건 아니다. 표준은 &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt; 에 대해 &lt;code&gt;short&lt;/code&gt; 은 최소 &lt;code&gt;int&lt;/code&gt; 보다 같거나 작아야 한다고 정의되어 있으며, &lt;code&gt;long&lt;/code&gt; 은 &lt;code&gt;int&lt;/code&gt; 보다 같거나 커야 한다고 정의되어 있을 뿐이다.) 이는 C 언어로 작성된 프로그램의 호환성(Portability) 에 매우 큰 악영향을 미칠 수 있는 요소였다.&lt;/p&gt;
&lt;p&gt;이러한 machine 에 따른 호환성 문제를 해결하기 위해 C99 표준에서는 &lt;code&gt;int8_t&lt;/code&gt;, &lt;code&gt;uint8_t&lt;/code&gt;, &lt;code&gt;int16_t&lt;/code&gt;, &lt;code&gt;uint16_t&lt;/code&gt;, &lt;code&gt;int32_t&lt;/code&gt;, &lt;code&gt;uint32_t&lt;/code&gt;, &lt;code&gt;int64_t&lt;/code&gt;, &lt;code&gt;uint64_t&lt;/code&gt; 등을 도입하였다.&lt;/p&gt;
&lt;p&gt;C99 에서 도입된 &lt;code&gt;stdint.h&lt;/code&gt; 는 이전에 존재하던 &lt;code&gt;limits.h&lt;/code&gt; 와는 성격이 다르다. 기존의 &lt;code&gt;limits.h&lt;/code&gt; 가 machine-dependent data type 의 크기를 서술한 것이라면, &lt;code&gt;stdint.h&lt;/code&gt; 는 data type 의 size 를 명확하게 정의한다. &lt;code&gt;limits.h&lt;/code&gt; 는 기계마다 다르게 정의되는 각 data type 의 크기만 알려줄 뿐이며, 원하는 크기의 자료형을 선언하는데는 크게 도움이 되지 않는다. 반면 &lt;code&gt;stdint.h&lt;/code&gt; 는 기존의 &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt; 과 같은 자료형을 보다 명확하게 수치로 나타낸다.&lt;/p&gt;
&lt;p&gt;32 비트 기계에서 16 비트 크기를 가지는 정수 자료형을 명확하게 선언하고 싶다면, &lt;code&gt;int16_t&lt;/code&gt; 를 사용하고, 32 비트 정수 자료형이라면 &lt;code&gt;int32_t&lt;/code&gt; 를 사용하여 선언한다. 기본 자료형을 다시 재정의하는 것은 쓸데없이 혼란을 가중시킬거라 생각할지도 모르지만, 이런 식으로 보다 명확하게 자료형을 재정의하는 것은 훨씬 명확한 코드를 작성하는데 도움이 된다. 부동소수점 자료형을 제외한 정수 자료형들은 모두 이런 &lt;code&gt;intN_t&lt;/code&gt; 스타일로 정의할 수 있는데, &lt;code&gt;char&lt;/code&gt; 도 &lt;code&gt;int8_t&lt;/code&gt; 와 같이 선언할 수 있다. C 에서 &lt;code&gt;char&lt;/code&gt; 타입은 정수형으로도 간주될 수 있기 때문이다. 자료형의 크기를 명확하게 밝혀준다는 장점 외에도, &lt;code&gt;unsigned int&lt;/code&gt; 와 같은 긴 문장을 간단하게 &lt;code&gt;uint32_t&lt;/code&gt; 로 표현할 수 있다는 장점도 있다. 호환성을 염두에 둔 코드를 작성한다면, &lt;code&gt;stdint.h&lt;/code&gt; 는 매우 편리한 존재가 아닐 수 없다. C99 에서 새롭게 도입된 &lt;code&gt;stdint.h&lt;/code&gt; 는 C++ 에도 &lt;code&gt;cstdint&lt;/code&gt; 헤더 파일로 포함되어 있다.&lt;/p&gt;</content><category term="c programming language"></category><category term="stdint.h"></category></entry></feed>