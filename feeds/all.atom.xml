<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>garret</title><link href="https://imjang57.github.io/garret/" rel="alternate"></link><link href="https://imjang57.github.io/garret/feeds/all.atom.xml" rel="self"></link><id>https://imjang57.github.io/garret/</id><updated>2017-05-07T00:00:00+09:00</updated><entry><title>Vim Configuration</title><link href="https://imjang57.github.io/garret/vim-configuration.html" rel="alternate"></link><published>2017-05-05T00:00:00+09:00</published><updated>2017-05-05T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-05-05:/garret/vim-configuration.html</id><summary type="html">&lt;p&gt;Vim 설정&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Vim Configuration&lt;/h1&gt;
&lt;p&gt;Vim 은 실행 중에 여러 설정들을 필요에따라 바꿔서 사용할 수 있다. 그리고 설정 파일을 생성하여 원하는 설정을 적용할 수도 있다.&lt;/p&gt;
&lt;p&gt;Vim 설정 파일은 보통 &lt;code&gt;.vimrc&lt;/code&gt; 라는 이름으로 생성되는데, 사용자의 Home 밑에 &lt;code&gt;~/.vimrc&lt;/code&gt; 로 생성하면 Vim 이 자동으로 이 파일을 찾아서 파일이 있으면 파일의 내용을 확인하여 설정을 적용한다.&lt;/p&gt;
&lt;h2&gt;Key mapping&lt;/h2&gt;
&lt;p&gt;Vim 에서 Key mapping 할 때 &lt;code&gt;map&lt;/code&gt; 또는 &lt;code&gt;noremap&lt;/code&gt; 을 사용하게 된다.&lt;/p&gt;
&lt;p&gt;Vim 에서 &lt;code&gt;:map j gg&lt;/code&gt; 를 실행하면 &lt;code&gt;j&lt;/code&gt; 가 &lt;code&gt;gg&lt;/code&gt; 로 mapping 되어서 &lt;em&gt;Normal mode&lt;/em&gt; 에서 &lt;code&gt;j&lt;/code&gt; 를 입력하면 &lt;code&gt;gg&lt;/code&gt; 가 실행된다.&lt;/p&gt;
&lt;p&gt;만약 &lt;code&gt;:map j gg&lt;/code&gt;, &lt;code&gt;:map Q j&lt;/code&gt; 를 실행하면 &lt;code&gt;j&lt;/code&gt; 를 눌러도, &lt;code&gt;Q&lt;/code&gt; 를 눌러도 &lt;code&gt;gg&lt;/code&gt; 가 실행된다. &lt;code&gt;Q&lt;/code&gt; 가 &lt;code&gt;j&lt;/code&gt; 로 mapping 되고, 다시 &lt;code&gt;j&lt;/code&gt; 가 &lt;code&gt;gg&lt;/code&gt; 로 mapping 되는 것이다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;:map j gg&lt;/code&gt;, &lt;code&gt;:map Q j&lt;/code&gt;, &lt;code&gt;:map gg Q&lt;/code&gt; 와 같이 무한으로 재귀적으로 참조하게 되면 오류가 발생한다. &lt;code&gt;map&lt;/code&gt; 은 recursive key mapping 을 하기 때문이다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;:map&lt;/code&gt; 과 반대로 &lt;code&gt;:noremap&lt;/code&gt; 은 non-recursive key mapping 이다. &lt;code&gt;:map j gg&lt;/code&gt;, &lt;code&gt;:map Q j&lt;/code&gt;, &lt;code&gt;:map gg Q&lt;/code&gt; 를 해도 오류가 발생하지 않는다. &lt;code&gt;Q&lt;/code&gt; 를 누르면 &lt;code&gt;j&lt;/code&gt; 를 누른 것과 같다. 한 번 key mapping 하여 변환되면 끝이다.&lt;/p&gt;
&lt;p&gt;Vim 은 또한 각 mode 별로 key mapping 을 설정할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;nmap&lt;/code&gt; : display normal mode maps&lt;/li&gt;
&lt;li&gt;&lt;code&gt;imap&lt;/code&gt; : display insert mode maps&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vmap&lt;/code&gt; : display visual and select mode maps&lt;/li&gt;
&lt;li&gt;&lt;code&gt;smap&lt;/code&gt; : display select mode maps&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xmap&lt;/code&gt; : display visual mode maps&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cmap&lt;/code&gt; : display command-line mode maps&lt;/li&gt;
&lt;li&gt;&lt;code&gt;omap&lt;/code&gt; : display operator pending mode maps&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;예를 들어, &lt;code&gt;:nnoremap g gg&lt;/code&gt; 를 실행하면 &lt;em&gt;Normal mode&lt;/em&gt; 에서 &lt;code&gt;g&lt;/code&gt; 를 누르면 &lt;code&gt;gg&lt;/code&gt; 로 non-recursive mapping 을 한다.&lt;/p&gt;
&lt;p&gt;key mapping 을 할 때 특수 기능 키에 대해 mapping 을 하려면 아래 내용을 참고하여 mapping 하자.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;BS&amp;gt;&lt;/code&gt; : Backspace&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Tab&amp;gt;&lt;/code&gt; : Tab&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;CR&amp;gt;&lt;/code&gt; : Enter&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Enter&amp;gt;&lt;/code&gt; : Enter&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Return&amp;gt;&lt;/code&gt; : Enter&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Esc&amp;gt;&lt;/code&gt; : Escape&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Space&amp;gt;&lt;/code&gt; : Space&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Up&amp;gt;&lt;/code&gt; : Up arrow&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Down&amp;gt;&lt;/code&gt; : Down arrow&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Left&amp;gt;&lt;/code&gt; : Left arrow&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Right&amp;gt;&lt;/code&gt; : Right arrow&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;F1&amp;gt;&lt;/code&gt; - &lt;code&gt;&amp;lt;F12&amp;gt;&lt;/code&gt; : Function keys 1 to 12&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#1&lt;/code&gt;, &lt;code&gt;#2&lt;/code&gt; .. &lt;code&gt;#9&lt;/code&gt;, &lt;code&gt;#0&lt;/code&gt; : Function keys F1 to F9, F10&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Insert&amp;gt;&lt;/code&gt; : Insert&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Del&amp;gt;&lt;/code&gt; : Delete&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Home&amp;gt;&lt;/code&gt; : Home&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;End&amp;gt;&lt;/code&gt; : End&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;PageUp&amp;gt;&lt;/code&gt; : Page-Up&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;PageDown&amp;gt;&lt;/code&gt; : Page-Down&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;만약 &lt;code&gt;:imap ,&amp;lt;Space&amp;gt; &amp;lt;Space&amp;gt;&amp;lt;Space&amp;gt;&amp;lt;Space&amp;gt;&amp;lt;Space&amp;gt;&lt;/code&gt; 와 같이 key mapping 을 하면, &lt;code&gt;,&amp;lt;Space&amp;gt;&lt;/code&gt; 를 입력할 때마다 4개의 Space 가 입력된다.&lt;/p&gt;
&lt;p&gt;key mapping 에 대한 자세한 내용은 &lt;code&gt;:help key-mapping&lt;/code&gt; 또는 &lt;a href="http://vim.wikia.com/wiki/Mapping_keys_in_Vim_-_Tutorial_%28Part_1%29"&gt;Mapping keys in Vim - Tutorial (Part 1)&lt;/a&gt; 을 참고하자.&lt;/p&gt;
&lt;h2&gt;&lt;leader&gt; key&lt;/h2&gt;
&lt;p&gt;Vim 에는 leader key 가 있다. Default 로 &lt;code&gt;\&lt;/code&gt; 가 leader key 로 되어 있는데, 설정에서 이 leader key 를 이용하여 많은 작업들에 대한 단축키를 생성할 수 있다.&lt;/p&gt;
&lt;p&gt;예를 들어, &lt;code&gt;:map &amp;lt;leader&amp;gt;A g&lt;/code&gt; 를 실행하면  &lt;code&gt;\A&lt;/code&gt; 를 입력했을 때 &lt;code&gt;g&lt;/code&gt; 를 실행한 것과 같은 결과를 얻을 수 있게 된다. 이때 leader key 를 누른 후 1초 내에 다음 key 를 입력해야 한다.&lt;/p&gt;
&lt;p&gt;leader key 를 &lt;code&gt;,&lt;/code&gt; 로 변경하려면 &lt;code&gt;:let mapleader=","&lt;/code&gt; 를 실행한다.&lt;/p&gt;
&lt;h1&gt;My &lt;code&gt;.vimrc&lt;/code&gt; file&lt;/h1&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="c"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;Belows are basic vim configurations&lt;/span&gt;
&lt;span class="c"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;Refer `:help quickref` (quickref.txt)&lt;/span&gt;
&lt;span class="nb"&gt;syntax&lt;/span&gt; &lt;span class="k"&gt;on&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="k"&gt;nu&lt;/span&gt;                   &lt;span class="c"&gt;&amp;quot;line numbers&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;tabstop&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="m"&gt;4&lt;/span&gt;            &lt;span class="c"&gt;&amp;quot;tab stop&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;softtabstop&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="m"&gt;4&lt;/span&gt;        &lt;span class="c"&gt;&amp;quot;soft tabstop&lt;/span&gt;
&lt;span class="c"&gt;&amp;quot;set expandtab            &amp;quot;soft tab: fill tab with blank characters(space)&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;shiftwidth&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="m"&gt;4&lt;/span&gt;         &lt;span class="c"&gt;&amp;quot;tab stop for &amp;#39;&amp;gt;&amp;#39; command&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;autoindent&lt;/span&gt;           &lt;span class="c"&gt;&amp;quot;Auto indentation&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;cindent&lt;/span&gt;              &lt;span class="c"&gt;&amp;quot;The C programming language indentation&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;smartindent&lt;/span&gt;          &lt;span class="c"&gt;&amp;quot;smart autoindenting for C programs&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="k"&gt;history&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="m"&gt;100&lt;/span&gt;          &lt;span class="c"&gt;&amp;quot;remember work history&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;hlsearch&lt;/span&gt;             &lt;span class="c"&gt;&amp;quot;hilighting search word&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;showmatch&lt;/span&gt;            &lt;span class="c"&gt;&amp;quot;hilighting matched parentheses : (),{}&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;ruler&lt;/span&gt;                &lt;span class="c"&gt;&amp;quot;show current cursor&amp;#39;s location at lower right side&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;showmode&lt;/span&gt;             &lt;span class="c"&gt;&amp;quot;To be able to see what mode you are in.&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;laststatus&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;         &lt;span class="c"&gt;&amp;quot;always show status bar&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;nobackup&lt;/span&gt;             &lt;span class="c"&gt;&amp;quot;don&amp;#39;t create backup file&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;relativenumber&lt;/span&gt;
&lt;span class="c"&gt;&amp;quot;&amp;quot;set backup               &amp;quot;create backup file&lt;/span&gt;
&lt;span class="c"&gt;&amp;quot;set backupdir=~/vim/backup &amp;quot;set directory where backup file is saved&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;nocompatible&lt;/span&gt;         &lt;span class="c"&gt;&amp;quot;be improved, required&lt;/span&gt;
&lt;span class="k"&gt;colorscheme&lt;/span&gt; evening


&lt;span class="c"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="c"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;belows are encoding configurations&lt;/span&gt;
&lt;span class="c"&gt;&amp;quot;auto detected file encoding list which is used when vim opens file&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;fencs&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;utf&lt;span class="m"&gt;-8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;euc&lt;span class="p"&gt;-&lt;/span&gt;kr&lt;span class="p"&gt;,&lt;/span&gt;cp949&lt;span class="p"&gt;,&lt;/span&gt;cp932&lt;span class="p"&gt;,&lt;/span&gt;euc&lt;span class="p"&gt;-&lt;/span&gt;jp&lt;span class="p"&gt;,&lt;/span&gt;shift&lt;span class="p"&gt;-&lt;/span&gt;jis&lt;span class="p"&gt;,&lt;/span&gt;big5&lt;span class="p"&gt;,&lt;/span&gt;latin1&lt;span class="p"&gt;,&lt;/span&gt;ucs&lt;span class="m"&gt;-2&lt;/span&gt;le
&lt;span class="c"&gt;&amp;quot;Use command :set fileencoding=utf-8 when you change current file&amp;#39;s encoding&lt;/span&gt;


&lt;span class="c"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="c"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;belows are key mappings&lt;/span&gt;
&lt;span class="nb"&gt;nnoremap&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;leader&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;&lt;span class="k"&gt;q&lt;/span&gt; :&lt;span class="k"&gt;bp&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nb"&gt;nnoremap&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;leader&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;&lt;span class="k"&gt;w&lt;/span&gt; :&lt;span class="k"&gt;bn&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Vim 일반 설정 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;set nocompatible&lt;/code&gt; : vi 호환성을 위한 기능을 사용하지 않는다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;syntax on&lt;/code&gt; : syntax highlighing 을 사용한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set nu&lt;/code&gt; : 왼쪽에 line number 를 보여준다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set tabstop=4&lt;/code&gt; : tab size 를 4로 지정한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set softtabstop=4&lt;/code&gt; : tab size 를 4로 지정한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set shiftwidth=4&lt;/code&gt; : tab size 를 4로 지정한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set expandtab&lt;/code&gt; : tag 을 space 로 사용하도록 한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set relativenumber&lt;/code&gt; : line number 를 현재 위치한 line 에서 상대적인 값으로 보여준다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set hlsearch&lt;/code&gt; : &lt;code&gt;/&lt;/code&gt; 로 검색할 때 검색된 문자열에 highlight 를 해준다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set ignorecase&lt;/code&gt; : &lt;code&gt;/&lt;/code&gt; 로 검색할 때 대소문자를 구분하지 않는다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set autoindent&lt;/code&gt; : 새로운 line 을 입력할 때 자동으로 indent 를 적용한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set cindent&lt;/code&gt; : 새로운 line 을 입력할 때 C style 의 indent 를 적용한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set smartindent&lt;/code&gt; : &lt;/li&gt;
&lt;li&gt;&lt;code&gt;set showmode&lt;/code&gt; : 현재 어떤 mode 인지를 status bar 에 보여준다.(NORMAL, INSERT, VISUAL, etc)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set nobackup&lt;/code&gt; : 파일을 열어서 buffer 를 생성할 때 backup 파일을 만들지 않는다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set ruler&lt;/code&gt; : 현재 cursor 의 위치를 하단에 있는 status bar 의 오른쪽에 보여준다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set history=100&lt;/code&gt; : 100 개의 work history 를 저장한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set showmatch&lt;/code&gt; : &lt;code&gt;(&lt;/code&gt; 와 &lt;code&gt;)&lt;/code&gt;, &lt;code&gt;{&lt;/code&gt; 와 &lt;code&gt;}&lt;/code&gt; 등 matched parentheses 에 hlghlight 적용한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set colorscheme evening&lt;/code&gt; : evening color theme 를 사용한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set fences=utf-8,euc-kr,cp949,latin1&lt;/code&gt; : vim 이 파일을 열 때 자동으로 인식할 file encoding 목록을 지정한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Vim key 설정 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;let mapleader = ","&lt;/code&gt; : leader key 를 '\' 에서 ',' 로 변경한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nnoremap &amp;lt;leader&amp;gt;q :bp&amp;lt;CR&amp;gt;&lt;/code&gt; : &lt;code&gt;&amp;lt;leader key&amp;gt; + q&lt;/code&gt; 를 누르면 previous buffer 로 이동한다. &lt;code&gt;:bp&lt;/code&gt; 명령과 같은 일을 한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nnoremap &amp;lt;leader&amp;gt;w :bn&amp;lt;CR&amp;gt;&lt;/code&gt; : &lt;code&gt;&amp;lt;leader key&amp;gt; + w&lt;/code&gt; 를 누르면 next buffer 로 이동한다. &lt;code&gt;:bn&lt;/code&gt; 명령과 같은 일을 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;References&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://jaeheeship.github.io/console/2013/11/15/vimrc-configuration.html"&gt;vim 설정파일 알아보기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://vim.wikia.com/wiki/Mapping_keys_in_Vim_-_Tutorial_%28Part_1%29"&gt;Mapping keys in Vim - Tutorial (Part 1)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="vim"></category></entry><entry><title>Vim Plugin</title><link href="https://imjang57.github.io/garret/vim-plugin.html" rel="alternate"></link><published>2017-05-05T00:00:00+09:00</published><updated>2017-05-05T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-05-05:/garret/vim-plugin.html</id><summary type="html">&lt;p&gt;Vim Plugin&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Vim Plugin&lt;/h1&gt;
&lt;p&gt;Vim 은 &lt;em&gt;Vim script&lt;/em&gt; 라는 자체 스크립트 언어를 제공하여 Plugin 을 만들 수 있게 한다. 이 스크립트들은 &lt;code&gt;plugin-name.vim&lt;/code&gt; 과 같이 vim 이라는 확장자(extension) 을 갖는다. &lt;em&gt;Vim script&lt;/em&gt; 는 &lt;a href="http://www.vim.org/scripts/index.php"&gt;Vim script page&lt;/a&gt; 에 많이 업로드되어 있다.&lt;/p&gt;
&lt;p&gt;환경 설정을 위해 사용되는 &lt;code&gt;.vimrc&lt;/code&gt; 파일도 사실은 &lt;em&gt;Vim script&lt;/em&gt; 이다.&lt;/p&gt;
&lt;p&gt;Vim plugin 은 2가지 종류가 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;filetype plugin : 특정 file type 에 대해서 동작하는 plugin. Default 로 &lt;code&gt;$VIMRUNTIME/ftplugin&lt;/code&gt; directory 에서 관리된다.&lt;/li&gt;
&lt;li&gt;global plugin : 모든 file type 에 대해서 동작하는 plugin. Default 로 &lt;code&gt;$VIMRUNTIME/plugin&lt;/code&gt; directory 에서 관리된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;각 plugin 의 위치가 &lt;code&gt;$VIMRUNTIME&lt;/code&gt; 밑에 꼭 있어야 하는 것은 아니다. Vim plugin 을 관리하는 plugin 을 설치하면 각자가 Runtime path 를 관리하여 &lt;code&gt;~/.vim/bundle&lt;/code&gt; 에 각 plugin 디렉터리를 생성하고 그 하위에 &lt;code&gt;ftplugin&lt;/code&gt; 과 &lt;code&gt;plugin&lt;/code&gt; 등 필요한 디렉터리들을 생성해서 사용하기도 한다.&lt;/p&gt;
&lt;h1&gt;Vundle&lt;/h1&gt;
&lt;p&gt;Vim plugin 을 관리하기 위한 여러 plugin 들이 있는데 나는 &lt;a href="https://github.com/VundleVim/Vundle.vim"&gt;Vundle&lt;/a&gt; 을 사용한다.&lt;/p&gt;
&lt;p&gt;자세한 내용은 &lt;a href="https://github.com/VundleVim/Vundle.vim"&gt;Vundle&lt;/a&gt; 에 가면 설치 방법부터 잘 나와있으니 참고하자.&lt;/p&gt;
&lt;p&gt;설치는 매우 쉽다. git clone 하여 &lt;code&gt;~/.vim/bundle/Vundle.vim&lt;/code&gt; 에 설치하겨 &lt;code&gt;~/.vimrc&lt;/code&gt; 파일에 Vundle 을 위한 설정과 설치하여 사용할 Plugin 목록을 입력해주기만 하면 된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Vundle 은 인터넷을 통해 각 plugin 들을 받아서 &lt;code&gt;~/.vim/bundle&lt;/code&gt; 에 설치한다.&lt;/p&gt;
&lt;h2&gt;My &lt;code&gt;.vimrc&lt;/code&gt; including Vundle&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;
&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;Belows are basic vim configurations
&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;Refer `:help quickref` (quickref.txt)
syntax on
set nu                   &amp;quot;line numbers
set tabstop=4            &amp;quot;tab stop
set softtabstop=4        &amp;quot;soft tabstop
&amp;quot;set expandtab            &amp;quot;soft tab: fill tab with blank characters(space)
set shiftwidth=4         &amp;quot;tab stop for &amp;#39;&amp;gt;&amp;#39; command
set autoindent           &amp;quot;Auto indentation
set cindent              &amp;quot;The C programming language indentation
set smartindent          &amp;quot;smart autoindenting for C programs
set history=100          &amp;quot;remember work history
set hlsearch             &amp;quot;hilighting search word
set showmatch            &amp;quot;hilighting matched parentheses : (),{}
set ruler                &amp;quot;show current cursor&amp;#39;s location at lower right side
set showmode             &amp;quot;To be able to see what mode you are in.
set laststatus=2         &amp;quot;always show status bar
set nobackup             &amp;quot;don&amp;#39;t create backup file
set relativenumber
&amp;quot;set backup               &amp;quot;create backup file
&amp;quot;set backupdir=~/vim/backup &amp;quot;set directory where backup file is saved
set nocompatible         &amp;quot;be improved, required
colorscheme evening


&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;
&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;belows are encoding configurations
&amp;quot;auto detected file encoding list which is used when vim opens file
set fencs=utf-8,euc-kr,cp949,cp932,euc-jp,shift-jis,big5,latin1,ucs-2le
&amp;quot;Use command :set fileencoding=utf-8 when you change current file&amp;#39;s encoding


&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;
&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;belows are key mappings
nnoremap &amp;lt;leader&amp;gt;q :bp&amp;lt;CR&amp;gt;
nnoremap &amp;lt;leader&amp;gt;w :bn&amp;lt;CR&amp;gt;

&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;
&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;Belows are Vundle Plugin configurations
filetype off

&amp;quot; set the runtime path to include Vundle and initialize
set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()
&amp;quot; alternatively, pass a path where Vundle should install plugins
&amp;quot;call vundle#begin(&amp;#39;~/some/path/here&amp;#39;)

&amp;quot; let Vundle manage Vundle, required
Plugin &amp;#39;VundleVim/Vundle.vim&amp;#39;

&amp;quot; The following are examples of different formats supported.
&amp;quot; Keep Plugin commands between vundle#begin/end.
&amp;quot; plugin on GitHub repo
&amp;quot;Plugin &amp;#39;tpope/vim-fugitive&amp;#39;
&amp;quot; plugin from http://vim-scripts.org/vim/scripts.html
&amp;quot;Plugin &amp;#39;L9&amp;#39;
&amp;quot; Git plugin not hosted on GitHub
&amp;quot;Plugin &amp;#39;git://git.wincent.com/command-t.git&amp;#39;
&amp;quot; git repos on your local machine (i.e. when working on your own plugin)
&amp;quot;Plugin &amp;#39;file:///home/gmarik/path/to/plugin&amp;#39;
&amp;quot; The sparkup vim script is in a subdirectory of this repo called vim.
&amp;quot; Pass the path to set the runtimepath properly.
&amp;quot;Plugin &amp;#39;rstacruz/sparkup&amp;#39;, {&amp;#39;rtp&amp;#39;: &amp;#39;vim/&amp;#39;}
&amp;quot; Install L9 and avoid a Naming conflict if you&amp;#39;ve already installed a
&amp;quot; different version somewhere else.
&amp;quot;Plugin &amp;#39;ascenator/L9&amp;#39;, {&amp;#39;name&amp;#39;: &amp;#39;newL9&amp;#39;}

Plugin &amp;#39;The-NERD-tree&amp;#39;
Plugin &amp;#39;AutoComplPop&amp;#39;
Plugin &amp;#39;majutsushi/tagbar&amp;#39;
Plugin &amp;#39;airblade/vim-gitgutter&amp;#39;
Plugin &amp;#39;vim-airline/vim-airline&amp;#39;
Plugin &amp;#39;vim-airline/vim-airline-themes&amp;#39;
Plugin &amp;#39;kien/ctrlp.vim&amp;#39;
Plugin &amp;#39;pathogen.vim&amp;#39;

let g:airline#extensions#tabline#enabled = 1

let NERDTreeWinPost = &amp;quot;left&amp;quot;

nmap &amp;lt;F7&amp;gt; :NERDTree&amp;lt;CR&amp;gt;
&amp;quot;nmap &amp;lt;F8&amp;gt; :TlistToggle&amp;lt;CR&amp;gt;
nmap &amp;lt;F8&amp;gt; :TagbarToggle&amp;lt;CR&amp;gt;
filetype on

let Tlist_Ctags_Cmd = &amp;quot;/usr/bin/ctags&amp;quot;
let Tlist_Inc_Winwidth = 0
let Tlist_Exit_OnlyWindow = 0
let Tlist_Auto_Open = 0
let Tlist_Use_Right_Window = 1

&amp;quot; All of your Plugins must be added before the following line
call vundle#end()            &amp;quot; required
filetype plugin indent on    &amp;quot; required
&amp;quot; To ignore plugin indent changes, instead use:
&amp;quot;filetype plugin on
&amp;quot;
&amp;quot; Brief help
&amp;quot; :PluginList       - lists configured plugins
&amp;quot; :PluginInstall    - installs plugins; append `!` to update or just
&amp;quot; :PluginUpdate
&amp;quot; :PluginSearch foo - searches for foo; append `!` to refresh local cache
&amp;quot; :PluginClean      - confirms removal of unused plugins; append `!` to
&amp;quot;auto-approve removal
&amp;quot;
&amp;quot; see :h vundle for more details or wiki for FAQ
&amp;quot; Put your non-Plugin stuff after this line

let g:ctrlp_custom_ignore = {
    \ &amp;#39;dir&amp;#39;: &amp;#39;\.git$\|vendor$&amp;#39;,
    \ &amp;#39;file&amp;#39;: &amp;#39;\v\.(exe|so|dll)$&amp;#39;
        \ }
&lt;/pre&gt;&lt;/div&gt;</content><category term="vim"></category></entry><entry><title>Vim Basic Regular Expression</title><link href="https://imjang57.github.io/garret/vim-basic-regular-expression.html" rel="alternate"></link><published>2017-05-04T00:00:00+09:00</published><updated>2017-05-07T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-05-04:/garret/vim-basic-regular-expression.html</id><summary type="html">&lt;p&gt;Vim 에서 사용가능한 정규표현식의 기본 사용법에 대한 글이다.&lt;/p&gt;</summary><content type="html">&lt;h1&gt;정규 표현식 (regular expression)&lt;/h1&gt;
&lt;p&gt;정규표현식이란 주로 문자열 내에서 검색이나 조작에 사용되는 표현식으로써 특정한 패턴을 가지고 그 패턴에 부합되는 문자열을 찾아내 원하는 일을 수행 할 수가 있다.&lt;/p&gt;
&lt;p&gt;정규표현식은 vim, sed, grep, emacs, perl 등 프로그램이나 프로그래밍 언어 등에서 문자열을 다루는 용도로 사용되고 있다.&lt;/p&gt;
&lt;p&gt;정규표현식이 쓰이는 모든 프로그램에서 동일한 문법으로 정규표현식을 규정하고 있지는 않는다. 기본적인 내용은 모두 같지만 약간의 표현 형식이 다르다. 즉, 이 글에 작성한 내용은 다른 프로그램이나 언어에서 사용하는 정규표현식과 다를 수 있다.&lt;/p&gt;
&lt;p&gt;Vim 의 &lt;code&gt;:help pattern&lt;/code&gt; 을 참고하자.&lt;/p&gt;
&lt;h1&gt;Basic Vim Regular Expression&lt;/h1&gt;
&lt;p&gt;여기에 나오는 정규표현식은 Vim 뿐만 아니라 Vim 의 전신인 Vi 에서도 사용되는 정규표현식이다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[ ]&lt;/code&gt; 안에는 알파벳이나 숫자가 올 수 있고 이 안에 나열되어 있는 문자 중 한 문자를 가리킨다. 즉 [abc] 는 검색에서 한 문자처럼 취급을 받는다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[abc]&lt;/code&gt; : a, b, c 문자 중 한 문자&lt;/li&gt;
&lt;li&gt;&lt;code&gt;b[abc]ll&lt;/code&gt; : ball, bbll, bcll 중 하나&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;[ ]&lt;/code&gt; 안에는 문자의 범위가 들어 갈 수도 있다. 대소문자를 구분하니 주의해야 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[a-z]&lt;/code&gt; : 소문자 a 부터 z 중 한 문자&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[a-f]&lt;/code&gt; : 소문자 a 부터 f 중 한 문자&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[0-9]&lt;/code&gt; : 숫자 0 부터 9 중 한 문자&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[A-Z0-9]&lt;/code&gt; : 대문자 A 부터 Z 와 숫자 0 부터 9 중 한 문자&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[A-Z][0-9][0-9]&lt;/code&gt; : 첫문자는 무조건 대문자로 시작하고 곧바로 숫자가 2자리 오는 패턴&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;정규표현식에서 &lt;code&gt;.&lt;/code&gt; 은 new line 을 제외한 모든 문자 하나를 가리킨다. 즉 알파벳, 공백과 같은 특수문자, 숫자 모두 &lt;code&gt;.&lt;/code&gt; 로 표현할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;a.d&lt;/code&gt; : &lt;code&gt;aad&lt;/code&gt;, &lt;code&gt;abd&lt;/code&gt;, &lt;code&gt;acd&lt;/code&gt;, &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;aed&lt;/code&gt;, ..., &lt;code&gt;a1d&lt;/code&gt;, &lt;code&gt;a2d&lt;/code&gt;, &lt;code&gt;a3d&lt;/code&gt;, ..., &lt;code&gt;a d&lt;/code&gt;, etc&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;^&lt;/code&gt; 가 &lt;code&gt;[ ]&lt;/code&gt; 안에 들어오면 안에 나열되어 있는 문자를 제외한 다른 모든 문자를 나타낸다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[^a-z]&lt;/code&gt; : 알파벳 소문자를 제외한 모든 문자&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;특수문자는 항상 &lt;code&gt;\&lt;/code&gt; 와 같이 쓰여야 문자 그대로의 의미를 나타낸다. 예를 들어, 공백(Space)는 &lt;code&gt;\&lt;/code&gt; 로 Space 앞에 &lt;code&gt;\&lt;/code&gt; 를 붙여주면 된다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;^&lt;/code&gt; 는 문자열의 가장 처음을 의미한다. Vim 에서 &lt;code&gt;/^The&lt;/code&gt; 로 검색을 하게 되면 줄의 맨 처음에 위치한 The 만 찾게 된다. &lt;code&gt;[ ]&lt;/code&gt; 내에 있던 &lt;code&gt;^&lt;/code&gt; 과 다른 의미이다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$&lt;/code&gt; 는 문자열의 가장 마지막을 의미한다. &lt;code&gt;/today$&lt;/code&gt; 로 검색하면 줄의 마지막에 위치한 today 만 찾게 된다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;*&lt;/code&gt; 는 0번 이상의 반복을 의미한다. 만약 단순히 &lt;code&gt;[a-z]*&lt;/code&gt; 라고 검색하게 되면 전체 문서가 선택된다. &lt;code&gt;*&lt;/code&gt; 는 0번 이상을 뜻하기 때문에 모든 문자들이 이 조건을 만족하게 된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;a*&lt;/code&gt; : null string, a, aa, aaa, aaaa, etc&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ab*&lt;/code&gt; : b 라는 문자가 없을 수도 있고 한번 이상 올 수도 있다. &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;ab&lt;/code&gt;, &lt;code&gt;abb&lt;/code&gt;, &lt;code&gt;abbb&lt;/code&gt;, &lt;code&gt;abbbb&lt;/code&gt;, etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Extended Vim Regular Expression&lt;/h1&gt;
&lt;p&gt;기존의 Vi 정규표현식만으로는 표현할 수 있는 패턴에 한계가 있어서 Vim 에서는 몇가지 패턴이 추가되었다. 사실 이 추가된 내용도 다른 대부분의 프로그램이나 언어에서 지원하는 정규표현식이다. 다만, 이 추가적인 정규표현식을 Vim 에서 사용하려면 정규표현식 문법을 위한 각 문자 앞에 &lt;code&gt;\&lt;/code&gt; 을 붙여야 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;+&lt;/code&gt; : 1번 이상&lt;/li&gt;
&lt;li&gt;&lt;code&gt;?&lt;/code&gt; : 0번 혹은 1번&lt;/li&gt;
&lt;li&gt;&lt;code&gt;( )&lt;/code&gt; : 여러 문자들을 group 으로 만듬&lt;/li&gt;
&lt;li&gt;&lt;code&gt;|&lt;/code&gt; : 논리연산자 or 와 같은 역할&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt; &amp;gt;&lt;/code&gt; : 문자열의 범위를 한정&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{n,m}&lt;/code&gt; : n번 이상 m 번 이하 반복 (matching 되는 가능한 긴 길이의 문자열을 나타냄)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{n}&lt;/code&gt; : n번 반복&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{n,}&lt;/code&gt; : n번 이상 반복 (matching 되는 가능한 긴 길이의 문자열을 나타냄)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{,m}&lt;/code&gt; : m번 이하 반복 (matching 되는 가능한 긴 길이의 문자열을 나타냄)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{}&lt;/code&gt; : 0번 이상 반복 (&lt;code&gt;*&lt;/code&gt; 와 같음)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{-n, m}&lt;/code&gt; : n번 이상 m 번 이하 반복 (matching 되는 가능한 짧은 길이의 문자열을 나타냄)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{-n}&lt;/code&gt; : n번 반복&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{-n,}&lt;/code&gt; : n번 이상 반복 (matching 되는 가능한 짧은 길이의 문자열을 나타냄)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{-,m}&lt;/code&gt; : m번 이하 반복 (matching 되는 가능한 짧은 길이의 문자열을 나타냄)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{-}&lt;/code&gt; : 0번 이상 반복&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;예를 들면 아래와 같이 사용할 수 있다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ab\+&lt;/code&gt; : 반드시 b 라는 문자가 한번 이상 와야 한다. &lt;code&gt;ab&lt;/code&gt;, &lt;code&gt;abb&lt;/code&gt;, &lt;code&gt;abbb&lt;/code&gt;, &lt;code&gt;abbbb&lt;/code&gt;, etc.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ab\?&lt;/code&gt; : a 뒤에 b가 올 수도 오지 않을 수 도 있다. &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;ab&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\(abc\)*&lt;/code&gt; : abc 문자열이 0번 이상 반복된다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\(abc\)\+&lt;/code&gt; : abc 문자열이 1번 이상 반복된다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DEB\|GIT&lt;/code&gt; : DEB 또는 GIT 을 찾는다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GIT\(HUB\|TER\)&lt;/code&gt; : GIT 으로 시작되고 HUB 또는 TER 가 이어지는 문자열을 검색한다. 즉, GITHUB, GITTER 가 검색된다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\&amp;lt;abc\&amp;gt;&lt;/code&gt; : 정확하게 abc 인 것만 찾는다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\&amp;lt;GIT\(HUB\|TER\)\&amp;gt;&lt;/code&gt; : 정확하게 GITHUB, GITTER 인 것만 검색한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;S\{2,4}&lt;/code&gt; : S 가 2번 이상 4번 이하 반복되는 문자열을 검색한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A.\{}A&lt;/code&gt; : ASSSSASSSSASSSASSSSSA 라는 문자열이 있으면 문자열 전체가 패턴 매치되는 하나의 결과가 된다. &lt;code&gt;A.*A&lt;/code&gt; 와 같다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A.\{-}A&lt;/code&gt; : ASSSSASSSSASSSASSSSSA 라는 문자열이 있으면 처음 ASSSSA 는 패턴 매치되는 하나의 결과, 그 다음 SSSS 는 매치 되지 않는 문자열, 그 다음 ASSSA 는 패턴 매치되는 하나의 결과, 그 다음 SSSSSA 는 매치 되지 않는 문자열이 된다. 즉, 매치되는 최소 길이의 문자열을 찾는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Replace&lt;/h1&gt;
&lt;p&gt;Vim 은 검색과 동시에 치환도 가능하다 : &lt;code&gt;:&amp;lt;시작줄 번호&amp;gt;,&amp;lt;끝 번호&amp;gt; s/검색어/바꿀단어/옵션&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:1,10 s/The/the/gc&lt;/code&gt; : 1번째 줄에서 10번째 줄 사이에 있는 "The" 라는 단어를 "the"로 치환&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;g&lt;/code&gt; 라는 옵션은 모든 검색어에 대해 변경을 실시하게 해준다. 만약 &lt;code&gt;g&lt;/code&gt; 옵션이 없을 경우 한 줄에 2 개 이상의 The 가 있을 경우 첫 번째 &lt;code&gt;The&lt;/code&gt; 만 &lt;code&gt;the&lt;/code&gt; 로 변경을 하게 된다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;c&lt;/code&gt; 라는 옵션은 치환이 발생할 때마다 정말 치환할 것인지를 묻는 prompt 를 출력한다.&lt;/p&gt;
&lt;p&gt;이외에 줄 번호를 가리키는 특별한 문자가 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.&lt;/code&gt; : 현재 커서가 놓여 있는 줄의 번호 &lt;/li&gt;
&lt;li&gt;&lt;code&gt;$&lt;/code&gt; : 마지막 줄&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:.,$ s/The/the/g&lt;/code&gt; : 현재에서 마지막 줄까지 모든 &lt;code&gt;The&lt;/code&gt; 를 &lt;code&gt;the&lt;/code&gt; 로 치환&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:1,$ s/\&amp;lt;be\&amp;gt;/BE/g&lt;/code&gt; : 모든 줄에서 다른 단어에 포함되지 않은 &lt;code&gt;be&lt;/code&gt; 라는 단어를 검색하여 대문자 &lt;code&gt;BE&lt;/code&gt; 로 변경&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;또는 아래와 같이 한번에 전체 문서에 대해서 치환을 수행할 수도 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:%s/The/the/g&lt;/code&gt; : 현재에서 마지막 줄까지 모든 &lt;code&gt;The&lt;/code&gt; 를 &lt;code&gt;the&lt;/code&gt; 로 치환. &lt;code&gt;:1,$ s/The/the/g&lt;/code&gt; 와 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;정규표현식과 변수&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;( )&lt;/code&gt; 는 문자열을 하나의 단위로 보게 하는 역할을 하였다. 하지만 치환에 사용 될 경우 변수 역할도 하게 된다.&lt;/p&gt;
&lt;p&gt;정규표현식 &lt;code&gt;([a-z]+) ([0-9]+)&lt;/code&gt; 를 만족하는 문자열 &lt;code&gt;abcd 100&lt;/code&gt; 가 있을 때, 정규표현식에서는 각 &lt;code&gt;( )&lt;/code&gt; 을 하나의 단위로 묶으면서 &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt; 와 같은 변수에 대응을 시킨다. 즉, 첫 번째 &lt;code&gt;( )&lt;/code&gt; 는 &lt;code&gt;1&lt;/code&gt; 이라는 변수에, 두 번째 &lt;code&gt;( )&lt;/code&gt; 는 &lt;code&gt;2&lt;/code&gt; 라는 변수에 저장된다.&lt;/p&gt;
&lt;p&gt;정규표현식의 변수와 Vim 의 치환을 사용하여 앞 뒤 순서를 바꿀 수 있다 : &lt;code&gt;:1,$ s/\([a-z]\+\)\( \+\)\([0-9]\+\)/321/g&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;s/.../.../g&lt;/code&gt; 와 같은 치환 형식에서 찾을 문자열 부분은 세 개의 &lt;code&gt;( )&lt;/code&gt; 로 이루어져 있어서 각각 변수 &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt; 에 저장된다. 그리고 치환할 문자열 부분에서 &lt;code&gt;321&lt;/code&gt; 과 같이 반대 순서로 변수를 나열하여 각 문자열들의 순서를 변경할 수 있게 된다.&lt;/p&gt;</content><category term="vim"></category></entry><entry><title>Vim Basics</title><link href="https://imjang57.github.io/garret/vim-basics.html" rel="alternate"></link><published>2017-05-04T00:00:00+09:00</published><updated>2017-05-04T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-05-04:/garret/vim-basics.html</id><summary type="html">&lt;p&gt;Vim 기본 사용법&lt;/p&gt;</summary><content type="html">&lt;h1&gt;VIM (VI Improved)&lt;/h1&gt;
&lt;p&gt;이 문서는 Vim 의 가장 기본적인 사용법을 정리한 문서이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Web page : http://www.vim.org&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CLI(Command Line Interface) 기반의 Text editor 이다. Linux, Mac, Windows 모두 지원한다. 처음 사용법이 익숙해지기가 어렵지만 한번 익히면 마우스 없이 대부분의 작업들을 빠르게 수행할 수 있다. 리눅스 서버는 대부분 CLI 환경만 제공되기 때문에 리눅스 서버 관리자라면 거의 필수로 익혀야 하는 Text editor 이다.&lt;/p&gt;
&lt;p&gt;Vimscript 라는 것을 작성하여 플러그인을 만들 수 있다. 사용법을 손에 익히고 여러 플러그인을 설치하면 왠만한 IDE 뺨치는 기능을 사용할 수 있다.&lt;/p&gt;
&lt;h1&gt;Vim modes&lt;/h1&gt;
&lt;p&gt;Vim 은 여러가지 모드를 제공한다. 대표적으로 사용되는 모드는 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Normal mode&lt;/em&gt; : where you can execute commands. This is default mode in which Vim starts up.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Insert mode&lt;/em&gt; : where you are simply writing text.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Visual mode&lt;/em&gt; : where you visually select a bunch of text so that you can run a command or operation only on that part of the text.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Vim 을 실행하면 가장 먼저 &lt;em&gt;Normal mode&lt;/em&gt; 상태로 실행된다. 다른 모드에서 &lt;code&gt;ESC&lt;/code&gt; 를 입력하면 &lt;em&gt;Normal mode&lt;/em&gt; 로 돌아온다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Normal mode&lt;/em&gt; 에서 &lt;code&gt;:&lt;/code&gt; 를 입력하면 Command 를 입력할 수 있다. 보통 Command 를 실행할 때 2가지 방법으로 하게 되는데 하나는 &lt;code&gt;:&lt;/code&gt; 를 입력한 후 Command 를 직접 입력하는 것이고, 다른 하나는 단축키를 사용하는 것이다. 2가지 모두 많이 사용되는 방법이다.&lt;/p&gt;
&lt;p&gt;커서 이동, put, yank, delete, search, replace, 기타 등등 대부분의 작업은 &lt;em&gt;Normal mode&lt;/em&gt; 에서 실행된다.&lt;/p&gt;
&lt;h1&gt;Help page&lt;/h1&gt;
&lt;p&gt;Vim 은 기본적으로 built-in help documentation 을 내장하고 있어서 작업 도중에 수시로 help documentation 을 참고할 수 있다.&lt;/p&gt;
&lt;p&gt;Normal mode 에서 &lt;code&gt;:help&lt;/code&gt; command 를 실행하면 확인할 수 있다. 자주 보게 되는 help 내용은 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:help [keyword]&lt;/code&gt; : shows documentation [for keyword]&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:help abbreviation&lt;/code&gt; : help for abbreviations&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:help quickref&lt;/code&gt; : Quick Reference&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:help user-manual&lt;/code&gt; : User Manuals&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;만약 플러그인을 설치할 때 플러그인이 help 를 제공하면 해당 플러그인의 help 문서도 확인가능하다.&lt;/p&gt;
&lt;h1&gt;Switching between modes&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Normal mode&lt;/em&gt; --(&lt;code&gt;i&lt;/code&gt;, &lt;code&gt;I&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;o&lt;/code&gt;, &lt;code&gt;O&lt;/code&gt;, &lt;code&gt;r&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt;)--&amp;gt; Insert mode&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Normal mode&lt;/em&gt; --(&lt;code&gt;v&lt;/code&gt;, &lt;code&gt;V&lt;/code&gt;)--&amp;gt; Visual mode&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Insert mode&lt;/em&gt; --(&lt;code&gt;ESC&lt;/code&gt;)--&amp;gt; Normal mode&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Visual mode&lt;/em&gt; --(&lt;code&gt;ESC&lt;/code&gt;)--&amp;gt; Normal mode&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Move cursor&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;move left / up / right / down : &lt;code&gt;h&lt;/code&gt; / &lt;code&gt;j&lt;/code&gt; / &lt;code&gt;k&lt;/code&gt; / &lt;code&gt;l&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;move left / up / right / down 3 times repeatedly : &lt;code&gt;3h&lt;/code&gt; / &lt;code&gt;3j&lt;/code&gt; / &lt;code&gt;3k&lt;/code&gt; / &lt;code&gt;3l&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;move the cursor to the next word : &lt;code&gt;w&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;move the cursor to the previous word : &lt;code&gt;b&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;go to specific line number : &lt;code&gt;&amp;lt;line-number&amp;gt;G&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;go to head of line : &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;go to tail of line : &lt;code&gt;$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;page up / down : &lt;code&gt;ctrl + b&lt;/code&gt; / &lt;code&gt;ctrl + f&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;page up / down half : &lt;code&gt;ctrl + d&lt;/code&gt; / &lt;code&gt;ctrl + u&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;jump to start of file : &lt;code&gt;gg&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;jump to end of file : &lt;code&gt;G&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;jump to top / bottom / middle of window : &lt;code&gt;H&lt;/code&gt; / &lt;code&gt;L&lt;/code&gt; / &lt;code&gt;M&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;move to previous / next sentence : &lt;code&gt;(&lt;/code&gt; / &lt;code&gt;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;move to previous / next paragraph : &lt;code&gt;{&lt;/code&gt; / &lt;code&gt;}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Editing&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;insert before the curosr : &lt;code&gt;i&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;insert at the beginning of the line : &lt;code&gt;I&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;insert (append) after the cursor : &lt;code&gt;a&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;insert (append) at the End of the line : &lt;code&gt;A&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;append (open) a new line below the current line : &lt;code&gt;o&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;append (open) a new line above the current line : &lt;code&gt;O&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;replace a single character : &lt;code&gt;r&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;replace from current cursor : &lt;code&gt;R&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;join line below to the current one : &lt;code&gt;J&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;exit &lt;em&gt;Insert mode&lt;/em&gt; (swith to &lt;em&gt;Normal mode&lt;/em&gt;) : &lt;code&gt;ESC&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Open and Close file&lt;/h1&gt;
&lt;p&gt;Vim 에서 파일을 열면 &lt;em&gt;buffer&lt;/em&gt; 라는 것을 생성하여 파일의 내용을 메모리에 올린 후 작업을 수행하게 된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Open file (buffer) : &lt;code&gt;:e &amp;lt;path&amp;gt;&lt;/code&gt;, &lt;code&gt;:edit &amp;lt;path&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Save file (buffer) : &lt;code&gt;:w&lt;/code&gt;, &lt;code&gt;:write&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Save file (buffer) as : &lt;code&gt;:saveas &amp;lt;path&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Close file (buffer) : &lt;code&gt;:bd&lt;/code&gt;, &lt;code&gt;:bw&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Quit Vim : &lt;code&gt;:q&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Print Working Directory : &lt;code&gt;:pwd&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Print path of current file : &lt;code&gt;:echo @%&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Print absolute path of current file : &lt;code&gt;echo expand('%:p')&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Use Mark&lt;/h1&gt;
&lt;p&gt;Vim 에서 &lt;em&gt;buffer&lt;/em&gt; 의 특정 위치를 alphabet(a-zA-Z) 으로 마킹할 수 있다. 자세한 내용은 &lt;code&gt;:help mark&lt;/code&gt; 와 &lt;code&gt;:help mark-motions&lt;/code&gt; help page 를 참고하자.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mark current location as a : &lt;code&gt;ma&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;goto mark a : &lt;code&gt;'a&lt;/code&gt; (cursor located on first non-blank character), `a (cursor located on marked character)&lt;/li&gt;
&lt;li&gt;list of marks : &lt;code&gt;:marks&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Abbreviation&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;set abbreviation foo with foooo : &lt;code&gt;:ab foo foooo&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;unset abbreviation foo : &lt;code&gt;:unab foo&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;위의 예의 경우, &lt;em&gt;Insert mode&lt;/em&gt;  에서 foo 와 &lt;SPACEBAR|ENTER&gt; 를 입력하면 foooo 가 입력된다.&lt;/p&gt;
&lt;h1&gt;Cut (Delete), Copy (Yank) and Paste (Put)&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;cut (delete) word : &lt;code&gt;dw&lt;/code&gt; (start from cursor), &lt;code&gt;daw&lt;/code&gt; (whole word)&lt;/li&gt;
&lt;li&gt;cut (delete) current line : &lt;code&gt;dd&lt;/code&gt;, &lt;code&gt;:d&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;cut (delete) 4 lines : &lt;code&gt;4dd&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;cut (delete) to the end of the line : &lt;code&gt;d$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;cut (delete) from cursor to end of current line : &lt;code&gt;D&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;cut (delete) one character of cursor : &lt;code&gt;x&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;cut (delete) one character before cursor : &lt;code&gt;X&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;cut (delete) 3 character of cursor : &lt;code&gt;3x&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;cut (delete) 3 character before cursor : &lt;code&gt;3X&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;cut (delete) lines from 4 to 10 inclusive : &lt;code&gt;:4,10d&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;copy (yank) word : &lt;code&gt;yw&lt;/code&gt; (start from cursor), &lt;code&gt;yaw&lt;/code&gt; (whole word)&lt;/li&gt;
&lt;li&gt;copy (yank) current line : &lt;code&gt;yy&lt;/code&gt;, &lt;code&gt;Y&lt;/code&gt;, &lt;code&gt;:y&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;copy (yank) 4 lines : &lt;code&gt;4yy&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;copy (yank) lines from 4 to 10 inclusive : &lt;code&gt;:4,10y&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;paste (put) at after current : &lt;code&gt;p&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;paste (put) at before current : &lt;code&gt;P&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;cut (delete) from current line to end of text : &lt;code&gt;dG&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;cut (delete) from current line to start of text : &lt;code&gt;dgg&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Undo and Redo&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;undo : &lt;code&gt;u&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;redo : &lt;code&gt;ctrl + r&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Select&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;swith to visual mode to select texts : &lt;code&gt;v&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;swith to visual mode to select line by line : &lt;code&gt;V&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;swith to visual mode to select vertical : &lt;code&gt;Ctrl + v&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can select texts in visual mode using vi move keys such as &lt;code&gt;h&lt;/code&gt;, &lt;code&gt;j&lt;/code&gt;, &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;l&lt;/code&gt;, &lt;code&gt;G&lt;/code&gt;, &lt;code&gt;gg&lt;/code&gt;, &lt;code&gt;w&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;H&lt;/code&gt;, &lt;code&gt;L&lt;/code&gt;, &lt;code&gt;M&lt;/code&gt;, etc. After selection, you can use &lt;code&gt;d&lt;/code&gt; for cut, &lt;code&gt;y&lt;/code&gt; for copy, etc.&lt;/p&gt;
&lt;h1&gt;Search&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;search text : &lt;code&gt;/searchtext&lt;/code&gt; in &lt;em&gt;Normal mode&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you want to search text &lt;em&gt;Hotkeys&lt;/em&gt;, input &lt;code&gt;/Hotkeys&lt;/code&gt;. Searching text is case-sensitive. If you want to ignore case, input &lt;code&gt;:set ignorecase&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;After run &lt;code&gt;/searchtext&lt;/code&gt; command, you can move to next and previous occurrence by &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Vim provide incremental search. This is helpful when you know only a part of the phrase. After &lt;code&gt;:set incsearch&lt;/code&gt;, vim will start searching by everytime you type.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;searchtext&lt;/code&gt; can be regular expression. For example:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;delete lines which are matched to pattern : &lt;code&gt;:g/pattern/d&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;delete empty lines : &lt;code&gt;:g/^$/d&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;delete lines which are include hello : &lt;code&gt;:g/hello/d&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Macro&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;record macro as a : &lt;code&gt;qa&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;stop recording macro : &lt;code&gt;q&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;run macro a : &lt;code&gt;@a&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;rerun last run macro : &lt;code&gt;@@&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;References&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://vim.rtorr.com/"&gt;Vim Cheat Sheet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/rtorr/vim-cheat-sheet"&gt;Vim Cheat Sheet Github&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="vim"></category></entry><entry><title>Vim Basics More</title><link href="https://imjang57.github.io/garret/vim-basics-more.html" rel="alternate"></link><published>2017-05-04T00:00:00+09:00</published><updated>2017-05-04T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-05-04:/garret/vim-basics-more.html</id><summary type="html">&lt;p&gt;Vim 기본 사용법에 대해 더 알면 좋은 내용들에 대한 글이다.&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Vim Basics More&lt;/h1&gt;
&lt;p&gt;Vim 에 대해 추가적으로 알면 좋은 내용들에 대해 정리한 글이다.&lt;/p&gt;
&lt;h1&gt;&lt;em&gt;buffer&lt;/em&gt;, &lt;em&gt;window&lt;/em&gt;, &lt;em&gt;tab&lt;/em&gt;&lt;/h1&gt;
&lt;p&gt;Vim 에서 &lt;em&gt;buffer&lt;/em&gt;  는 열려 있는 파일(file which is opened)를 뜻한다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;window&lt;/em&gt; 는 Vim 이 어떤 것을 출력하기 위한 component 로 &lt;em&gt;buffer&lt;/em&gt; 를 출력하는 방법이다. 사실 Vim 의 &lt;em&gt;buffer&lt;/em&gt; 는 text 만 출력할 수 있는 것이 아니다. Vim 화면을 가로나 세로로 분할하면 이 &lt;em&gt;windows&lt;/em&gt; 가 새로 만들어 지고 각 &lt;em&gt;window&lt;/em&gt; 에 &lt;em&gt;buffer&lt;/em&gt; 가 출력된다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;tab&lt;/em&gt; 은 Vim 의 Layout 이다. 여러 &lt;em&gt;windows&lt;/em&gt; 들의 집합이다. 대부분의 Text editor 나 Internet browser 에서 사용하는 tab 과는 개념이 다르다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A buffer is the in-memory text of a file.&lt;/li&gt;
&lt;li&gt;A window is a viewport on a buffer.&lt;/li&gt;
&lt;li&gt;A tab page is a collection of windows.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;대충 간략하게 정리하면 파일은 &lt;em&gt;buffer&lt;/em&gt; 에 로드되고, &lt;em&gt;buffer&lt;/em&gt; 는 &lt;em&gt;window&lt;/em&gt; 에 의해 출력되고, &lt;em&gt;window&lt;/em&gt; 는 &lt;em&gt;tab&lt;/em&gt; 에 의해 layout 이 결정된다.&lt;/p&gt;
&lt;h2&gt;Vim &lt;em&gt;buffer&lt;/em&gt; management&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;list of current buffers : &lt;code&gt;:ls&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;open new file (buffer) : &lt;code&gt;:e &amp;lt;path&amp;gt;&lt;/code&gt;, &lt;code&gt;:edit &amp;lt;path&amp;gt;&lt;/code&gt; (with enhanced tab completion (put set wildmenu in your .vimrc))&lt;/li&gt;
&lt;li&gt;save file (buffer) : &lt;code&gt;:w&lt;/code&gt;, &lt;code&gt;:write&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;close file (buffer) : &lt;code&gt;:bd&lt;/code&gt;, &lt;code&gt;:bw&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;switch between all open files (buffers) : &lt;code&gt;:b&amp;lt;buffer number&amp;gt;&lt;/code&gt; (&lt;code&gt;:b#&lt;/code&gt; chooses the last visited file)&lt;/li&gt;
&lt;li&gt;previous buffer : &lt;code&gt;:bp&lt;/code&gt;, &lt;code&gt;:bprevious&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;next buffer : &lt;code&gt;:bn&lt;/code&gt;, &lt;code&gt;:bnext&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;delete buffer : &lt;code&gt;:bd [buffer numbers...]&lt;/code&gt;, &lt;code&gt;:bw&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Close all buffer : &lt;code&gt;:%bd&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Close buffer from buffer number 1 to 1000 : &lt;code&gt;:1,1000bd&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;:ls&lt;/code&gt; 를 실행하면 Vim 의 하단에 다음과 같이 현재 열려진 &lt;em&gt;buffer&lt;/em&gt; 들을 보여준다. 아래 화면에서 &lt;em&gt;buffer&lt;/em&gt; 를 선택하여 이동할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;1 %a   &amp;quot;./checkin.pl&amp;quot;            line 1
2 #    &amp;quot;./grabakamailogs.pl&amp;quot;     line 1
3      &amp;quot;./grabwmlogs.pl&amp;quot;         line 0
  etc.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;%&lt;/code&gt; 는 현재 편집 중인 &lt;em&gt;buffer&lt;/em&gt; (current buffer) 를 참조한다. &lt;code&gt;#&lt;/code&gt; 는 직전에 편집하던 &lt;em&gt;buffer&lt;/em&gt; (alternative buffer) 를 참조한다. &lt;code&gt;ctrl + shift + 6&lt;/code&gt; 를 실행하면 두 &lt;em&gt;buffer&lt;/em&gt; 사이를 switch 한다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;e &amp;lt;path&amp;gt;&lt;/code&gt; 를 실행하면 새로운 &lt;em&gt;buffer&lt;/em&gt; 를 만들고 전달 받은 파일의 내용을 로드한다. &lt;code&gt;:e foo.txt bar.txt&lt;/code&gt;, &lt;code&gt;e /foo/bar/*.txt&lt;/code&gt; 와 같이 한 번에 여러 &lt;em&gt;buffer&lt;/em&gt; 를 생성하지는 못한다. 만약, 여러 파일을 한 번에 열고 싶으면 처음에 Vim 을 실행할 때 &lt;code&gt;Vim file1.txt file2.txt&lt;/code&gt; 와 같이 실행하면 된다. 아니면 &lt;code&gt;arga [paths...]&lt;/code&gt; 를 실행하면 여러 파일들로 새로운 &lt;em&gt;buffer&lt;/em&gt; 를 생성하고 대신 새로운 &lt;em&gt;buffer&lt;/em&gt; 로 switch 를 하지는 않는다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;:arga foo.txt bar.txt
:argadd /foo/bar/*.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Install &lt;em&gt;BufOnly&lt;/em&gt; plugin&lt;/h2&gt;
&lt;p&gt;Vim 으로 &lt;em&gt;buffer&lt;/em&gt; 를 사용하다보면 불편할 때가 있는데, 예를 들면 지금 편집중인 &lt;em&gt;buffer&lt;/em&gt; 를 빼고 나머지 &lt;em&gt;buffer&lt;/em&gt; 들을 모두 닫고 싶을 때이다. &lt;code&gt;:ls&lt;/code&gt; 로 현재 생성되어 있는 &lt;em&gt;buffer&lt;/em&gt; 를 확인하고 &lt;code&gt;bd &amp;lt;buffer number&amp;gt;&lt;/code&gt; 로 일일이 하나씩 &lt;em&gt;buffer&lt;/em&gt; 를 삭제해야 한다. 그래서 나는 &lt;em&gt;BufOnly&lt;/em&gt; 라는 plugin 을 설치해서 사용한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Download &lt;code&gt;BufOnly.vim&lt;/code&gt; Vimscript at &lt;a href="http://www.vim.org/scripts/script.php?script_id=1071"&gt;BufOnly page&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Goto &lt;code&gt;$VIMRUNTIME&lt;/code&gt; : &lt;code&gt;:echo $VIMRUNTIME&lt;/code&gt;, &lt;code&gt;:!explorer $VIMRUNTIME&lt;/code&gt; in Vim.&lt;/li&gt;
&lt;li&gt;Copy downloaded &lt;code&gt;BufOnly.vim&lt;/code&gt; to &lt;code&gt;$VIMRUNTIME&lt;/code&gt; directory or &lt;code&gt;~/.vim/plugin/BufOnly.vim&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Restart Vim&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;참고로 &lt;code&gt;$VIMRUNTIME&lt;/code&gt; 은 Vim 실행 후 &lt;em&gt;Normal mode&lt;/em&gt; 에서 &lt;code&gt;:echo $VIMRUNTIME&lt;/code&gt; 으로 확인할 수 있으며 Vim 이 실행되는 root path 이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;close buffers : &lt;code&gt;:BufOnly [buffer number]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Vim &lt;em&gt;window&lt;/em&gt; management&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;split window horizontal : &lt;code&gt;:sp [path]&lt;/code&gt;, &lt;code&gt;:split [path]&lt;/code&gt;, &lt;code&gt;Ctrl + w, s&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;split window vertical : &lt;code&gt;vs [path]&lt;/code&gt;, &lt;code&gt;:vertical split [path]&lt;/code&gt;, &lt;code&gt;Ctrl + w, v&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;resize all windows same : &lt;code&gt;Ctrl - w, =&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;resize horizontal : &lt;code&gt;:resize 60&lt;/code&gt;, &lt;code&gt;:res 60&lt;/code&gt;, &lt;code&gt;:resize +5&lt;/code&gt;, &lt;code&gt;:res +5&lt;/code&gt;, &lt;code&gt;:resize -5&lt;/code&gt;, &lt;code&gt;:res -5&lt;/code&gt;, &lt;code&gt;ctrl + w, +&lt;/code&gt;, &lt;code&gt;ctrl + w, -&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;resize vertical :  &lt;code&gt;:vertical resize 60&lt;/code&gt;, &lt;code&gt;:vertical res 60&lt;/code&gt;, &lt;code&gt;:vertical resize +5&lt;/code&gt;, &lt;code&gt;:vertical res +5&lt;/code&gt;, &lt;code&gt;:vertical resize -5&lt;/code&gt;, &lt;code&gt;:vertical res -5&lt;/code&gt;, &lt;code&gt;ctrl + w, &amp;gt;&lt;/code&gt;, &lt;code&gt;ctrl + w, &amp;lt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;switch between splitscreens : &lt;code&gt;ctrl + w, arrow key&lt;/code&gt;, &lt;code&gt;ctrl + w, &amp;lt;h|j|k|l&amp;gt;&lt;/code&gt;, &lt;code&gt;ctrl + w, n&lt;/code&gt;, &lt;code&gt;ctrl + w, p&lt;/code&gt;, &lt;code&gt;ctrl + w, w&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;close the current window : &lt;code&gt;ctrl + w, c&lt;/code&gt;, &lt;code&gt;:q&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;close all windows except the current one : &lt;code&gt;ctrl + w, o&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To resize in different steps, you can create maps that will adjust the window size differently. For example to increase the window size by a factor of 1.5 and decrease the window size by 0.67, you can map this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;nnoremap &amp;lt;silent&amp;gt; &amp;lt;Leader&amp;gt;+ :exe &amp;quot;resize &amp;quot; . (winheight(0) * 3/2)&amp;lt;CR&amp;gt;
nnoremap &amp;lt;silent&amp;gt; &amp;lt;Leader&amp;gt;- :exe &amp;quot;resize &amp;quot; . (winheight(0) * 2/3)&amp;lt;CR&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Vim &lt;em&gt;tab&lt;/em&gt; management&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;add new tab : &lt;code&gt;:tabe &amp;lt;path&amp;gt;&lt;/code&gt;, &lt;code&gt;:tabedit &amp;lt;path&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;add buffer to tab : &lt;code&gt;:&amp;lt;tab number&amp;gt;tabe &amp;lt;path&amp;gt;&lt;/code&gt;, &lt;code&gt;:&amp;lt;tab number&amp;gt;tabedit &amp;lt;path&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;close tab : &lt;code&gt;:tabc&lt;/code&gt;, &lt;code&gt;:tabclose&lt;/code&gt;, &lt;code&gt;:&amp;lt;tab number&amp;gt;tabc&lt;/code&gt;, &lt;code&gt;:&amp;lt;tab number&amp;gt;tabclose&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;switch between tabs : &lt;code&gt;:tabn&lt;/code&gt;, &lt;code&gt;:tabnext&lt;/code&gt;, &lt;code&gt;:tabp&lt;/code&gt;, &lt;code&gt;:tabprevious&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;switch to next tab by number : &lt;code&gt;gt&lt;/code&gt;, &lt;code&gt;&amp;lt;number&amp;gt;gt&lt;/code&gt;, &lt;code&gt;ctrl + PageDown&lt;/code&gt;, &lt;code&gt;&amp;lt;number&amp;gt;ctrl + PageDown&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;switch to previous tab by number : &lt;code&gt;gT&lt;/code&gt;, &lt;code&gt;&amp;lt;number&amp;gt;gT&lt;/code&gt;, &lt;code&gt;ctrl + PageUp&lt;/code&gt;, &lt;code&gt;&amp;lt;number&amp;gt;ctrl + PageUp&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;go to tab : &lt;code&gt;:tabmove &amp;lt;tab number&amp;gt;&lt;/code&gt;, &lt;code&gt;:tabm &amp;lt;tab number&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you map &lt;code&gt;:tabn&lt;/code&gt; and &lt;code&gt;:tabp&lt;/code&gt; to your &lt;code&gt;F7&lt;/code&gt; and &lt;code&gt;F8&lt;/code&gt; keys you can easily switch between files.&lt;/p&gt;
&lt;h1&gt;Selection&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;- select : &lt;code&gt;v, [h|j|k|l|g|G|...]&lt;/code&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;- select vertical : &lt;code&gt;ctrl + v, [h|j|k|l|g|G|...]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1&gt;Indentation&lt;/h1&gt;
&lt;p&gt;In command mode,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;indent current line by shiftwidth spaces : &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;:&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;de-indent current line by shiftwidth spaces : &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;:&amp;lt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;re-indent current line : &lt;code&gt;==&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;indent 5 lines : &lt;code&gt;5&amp;gt;&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;de-indent 5 lines : &lt;code&gt;5&amp;lt;&amp;lt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;re-indent 5 lines : &lt;code&gt;5==&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;indent lines 4 to 8, inclusive : &lt;code&gt;:4,8&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;indent selected lines : Select lines and use &lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;increase indent of a curly-braces block : put cursor on one of the curly braces and use &lt;code&gt;&amp;gt;, %&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;decrease indent of a curly-braces block : put cursor on one of the curly braces and use &lt;code&gt;&amp;lt;, %&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;re-indent a curly-braces block : put cursor on one of the curly braces and use &lt;code&gt;=, %&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Paste text, aligning indentation with surroundings : &lt;code&gt;]p&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;re-indent entire buffer : &lt;code&gt;gg=G&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In insert mode,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;insert indent at start of line : &lt;code&gt;ctrl + t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;remove indent at start of line : &lt;code&gt;ctrl + d&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;vim settings in &lt;code&gt;.vimrc&lt;/code&gt; file for indentation:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;set expandtab       &amp;quot;Use softtabstop spaces instead of tab characters for indentation
set shiftwidth=4    &amp;quot;Indent by 4 spaces when using &amp;gt;&amp;gt;, &amp;lt;&amp;lt;, == etc.
set softtabstop=4   &amp;quot;Indent by 4 spaces when pressing &amp;lt;TAB&amp;gt;

set autoindent      &amp;quot;Keep indentation from previous line
set smartindent     &amp;quot;Automatically inserts indentation in some cases
set cindent         &amp;quot;Like smartindent, but stricter and more customisable
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Vim has intelligent indentation based on filetype. Try adding this to your &lt;code&gt;.vimrc&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="k"&gt;has&lt;/span&gt; (&lt;span class="s"&gt;&amp;quot;autocmd&amp;quot;&lt;/span&gt;)
    &amp;quot; &lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;detection&lt;/span&gt;. &lt;span class="n"&gt;Indent&lt;/span&gt; &lt;span class="n"&gt;based&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt; &lt;span class="n"&gt;filetype&lt;/span&gt;. &lt;span class="n"&gt;Recommended&lt;/span&gt;.
    &lt;span class="n"&gt;filetype&lt;/span&gt; &lt;span class="n"&gt;plugin&lt;/span&gt; &lt;span class="n"&gt;indent&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt;
&lt;span class="n"&gt;endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Folding&lt;/h1&gt;
&lt;p&gt;여러 line 들을 folding 하면 필요 없는 부분들을 숨겨서 긴 source code 등을 보는데 더 수월할 때가 많다.&lt;/p&gt;
&lt;p&gt;folding 을 하는 가장 기본적인 방법은 원하는 line 들을 선택한 후 &lt;code&gt;z, f&lt;/code&gt;, &lt;code&gt;:fold&lt;/code&gt;, &lt;code&gt;:fo&lt;/code&gt; 를 실행하는 것이다.&lt;/p&gt;
&lt;p&gt;unfolding 은 folding 된 line 에서 &lt;code&gt;z, o&lt;/code&gt;, &lt;code&gt;:foldopen&lt;/code&gt;, &lt;code&gt;:foldo&lt;/code&gt; 중 하나를 실행하면 된다.&lt;/p&gt;
&lt;p&gt;자세한 내용은 &lt;code&gt;:help fold&lt;/code&gt; 를 참고하자.&lt;/p&gt;
&lt;h1&gt;Get the name of the current file&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Register &lt;code&gt;%&lt;/code&gt; contains the name of the current file&lt;/li&gt;
&lt;li&gt;Register &lt;code&gt;#&lt;/code&gt; contains the name of the alternate file.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;현재 작업 중인 buffer 의 file name 을 확인하려면 register &lt;code&gt;%&lt;/code&gt; 를 확인하면 된다 : &lt;code&gt;:echo @%&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;기타 file path 를 확인하기 위한 command :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:echo expand('%:t')&lt;/code&gt; : &lt;code&gt;my.txt&lt;/code&gt;, name of file ('tail')&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:echo expand('%:p')&lt;/code&gt; : &lt;code&gt;/abc/def/my.txt&lt;/code&gt;, full path&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:echo expand('%:p:h')&lt;/code&gt; : &lt;code&gt;/abc/def&lt;/code&gt;, directory containing file ('head')&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:echo expand('%:p:h:t')&lt;/code&gt; : &lt;code&gt;dev&lt;/code&gt;, First get the full path with &lt;code&gt;:p&lt;/code&gt; (&lt;code&gt;/abc/def/my.txt&lt;/code&gt;), then get the head of that with &lt;code&gt;:h&lt;/code&gt; (&lt;code&gt;/abc/def&lt;/code&gt;), then get the tail of that with &lt;code&gt;:t&lt;/code&gt; (&lt;code&gt;def&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:echo expand('%:r')&lt;/code&gt; : &lt;code&gt;my&lt;/code&gt;, name of file less one extension ('root')&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:echo expand('%:e')&lt;/code&gt; : &lt;code&gt;txt&lt;/code&gt; name of file's extension ('extension')&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For more info run &lt;code&gt;:help expand&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;If all that is wanted is to display the name of the current file, type &lt;code&gt;Ctrl-G&lt;/code&gt; (or press &lt;code&gt;1 then Ctrl-G&lt;/code&gt; for the full path).&lt;/p&gt;
&lt;p&gt;When using &lt;code&gt;@%&lt;/code&gt;, the name is displayed relative to the current directory.&lt;/p&gt;</content><category term="vim"></category></entry><entry><title>NPE (NullPointerException) 을 피하자</title><link href="https://imjang57.github.io/garret/avoid-null-pointer-exception-in-java.html" rel="alternate"></link><published>2017-01-18T00:00:00+09:00</published><updated>2017-01-18T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-18:/garret/avoid-null-pointer-exception-in-java.html</id><summary type="html">&lt;p&gt;Java 에서 NPE (NullPointerException) 을 피하면서 코딩하기 위한 습관들&lt;/p&gt;</summary><content type="html">&lt;h1&gt;NPE(NullPointerException) 을 피하자.&lt;/h1&gt;
&lt;p&gt;자바 개발을 하다보면 가장 많이 만나고 영향이 큰 예외 중 하나가 &lt;em&gt;NPE&lt;/em&gt; 이다. NPE 는 개발자의 습관이나 부주의 등이 대부분 원인이다. 이를 예방하는 가장 좋은 방법은 NPE 를 피하는 코딩 습관을 갖는 것이다.&lt;/p&gt;
&lt;h2&gt;null 의 의미&lt;/h2&gt;
&lt;p&gt;자바에서 &lt;code&gt;null&lt;/code&gt; 이란 아래와 같은 상태를 의미한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;아직 object 가 생성되지 않은 상태, 즉 아직 memory 할당이 되지 않은 object 상태&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;NPE 는 null 상태인 object 를 참조하여 어떠한 행위(method 실행)를 하려할 때 발생하는 예외이다.&lt;/p&gt;
&lt;h2&gt;NPE가 발생하는 상황&lt;/h2&gt;
&lt;p&gt;NPE 는 아래와 같은 상황에서 발생할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;null object 의 method 를 호출&lt;/li&gt;
&lt;li&gt;null object 의 instance member 에 접근&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Avoid NPE in source code&lt;/h1&gt;
&lt;p&gt;NPE 는 대부분 개발자의 부주의로 발생하므로, 개발할 때 조금만 신경쓰면 대부분의 NPE 를 예방할 수 있다.&lt;/p&gt;
&lt;h2&gt;String 객체를 비교할 경우&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;equals()&lt;/code&gt;, &lt;code&gt;equalsIgnoreCase()&lt;/code&gt; 등을 사용할 때 null 이 아닌 것이 확실한 객체가 있다면 해당 객체의 method 를 호출하자.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Compare String&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;equals&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;testStr&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
 &lt;span class="c1"&gt;// logic&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;String.valueOf() 사용&lt;/h2&gt;
&lt;p&gt;로그 등을 남길 때 객체의 상태를 확인하기 위해 객체의 &lt;code&gt;toString()&lt;/code&gt; 을 호출하는 경우가 있는데, 객체가 null 일 경우 NPE 가 발생한다. 로그를 위해 null 을 체크하는 로직을 추가하는 것은 불필요한 코드가 될 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;toString()&lt;/code&gt; method 보다는 &lt;code&gt;String.valueOf()&lt;/code&gt; 를 사용하자.&lt;/p&gt;
&lt;h2&gt;Primitive type 사용&lt;/h2&gt;
&lt;p&gt;꼭 필요한 경우가 아니라면 Primitive type data 를 사용하자. NPE 를 줄이고 memory 도 더 효율적으로 사용할 수 있다.&lt;/p&gt;
&lt;h2&gt;return empty collection&lt;/h2&gt;
&lt;p&gt;List, Set, Map 등과 같은 Collection 을 return 하는 method 를 구현할 때, null 을 return 하지 말자. 대신 empty collection 을 return 하자. 그러면 함수를 사용하는 개발자는 불필요한 null 체크를 하지 않아도 된다.&lt;/p&gt;
&lt;h2&gt;Use null-safe stuffs&lt;/h2&gt;
&lt;p&gt;null 에 안전한 자바 내장 함수나 commons-lang 과 같은 helper class 를 사용하자. Apache Commons 도 좋고, 요즘은 Googld guava 가 매우 유용한 라이브러리들을 많이 제공한다.&lt;/p&gt;
&lt;h2&gt;Unit Test&lt;/h2&gt;
&lt;p&gt;Java assert, Unit test (JUnit) 등을 활용하여 사전 확인 및 다양한 상황에서의 테스트를 수행하자.&lt;/p&gt;
&lt;h2&gt;협업할 때는 기능 및 제약사항 등을 확실히 명시하자.&lt;/h2&gt;
&lt;p&gt;NPE 는 개발자의 부주의에 의해 대부분 발생하고, 개발자의 부주의는 정보가 없어서 발생하는 경우가 많다. 아래의 내용들은 명확하게 공유하자.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Method parameter 와 return value 에 대한 명세&lt;/li&gt;
&lt;li&gt;Method 에서 수행하는 validation 으로 인해 발생가능한 Exception 들&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="https://github.com/google/guava"&gt;Google guava&lt;/a&gt; 의 &lt;em&gt;Preconditions&lt;/em&gt; 등을 사용하면 parameter 에 대한 validation 을 쉽게 처리할 수 있다.&lt;/p&gt;
&lt;p&gt;또한 &lt;em&gt;Java Doc&lt;/em&gt; 등의 문서를 적절히 사용하자. 자동으로 Java doc 을 생성해주는 프로그램도 많다. 또는 &lt;a href="http://swagger.io"&gt;swagger&lt;/a&gt; 등을 이용하여 RestAPI 서비스의 API 에 대한 명세를 공유할 수도 있다.&lt;/p&gt;
&lt;p&gt;문서의 내용을 자세하게 채우지 않아도 된다. 위의 내용들에 대해서만이라도 명확하게 작성하자.&lt;/p&gt;
&lt;h2&gt;Optional class&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Optional&lt;/em&gt; 을 사용하면 null check 를 위한 코드를 상당히 줄일 수 있으며 코드의 Readability 를 높일 수 있다.&lt;/p&gt;
&lt;p&gt;Optional 은 원래 google guava 라이브러리에서 제공되었었는데 java 8 로 버전 업하면서 자바에서도 지원(&lt;code&gt;java.util.Optional&amp;lt;T&amp;gt;&lt;/code&gt;)하게 되었다.&lt;/p&gt;
&lt;p&gt;Optional object 생성:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;nStr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Test String&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;Optional&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;eOp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Optional&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;empty&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// empty Optional 객체 생성&lt;/span&gt;
&lt;span class="n"&gt;Optional&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;nullableOp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Optional&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ofNullable&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nStr&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// null 을 허용하는 Optional 객체 생성&lt;/span&gt;
&lt;span class="n"&gt;Optional&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;notNullableOp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Optional&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;of&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// str 에 접근하는 시점이 아니라 Optional 객체를 생성하는 이 순간 parameter 의 null 여부를 체크하여 NPE 가 발생&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt; &lt;span class="n"&gt;notNullableOp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;isPresent&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
 &lt;span class="c1"&gt;// Optional 객체에 값이 있는지 확인 후 아래 코드를 실행&lt;/span&gt;
 &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;notNullableOp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;get&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;notNullableOp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ifPresent&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Optional 객체에 값이 있는지 확인 후 전달받은 function 을 실행&lt;/span&gt;
&lt;span class="n"&gt;notNullableOp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ifPresent&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;});&lt;/span&gt;
&lt;span class="n"&gt;nullableOp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ifPresent&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// null 이므로 실행되지 않는다.&lt;/span&gt;
&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;emtpyStr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;eOp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;orElse&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Empty String&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Optional 객체가 empty 일 경우 (null 일 경우) &amp;quot;Empty String&amp;quot; 의 reference 를 return.&lt;/span&gt;
&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;exStr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;eOp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;orElseThrow&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Exception&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Optional 객체가 empty 일 경우 (null 일 경우) 지정된 Exception 을 throw.&lt;/span&gt;
&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;notNullableOp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;filter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;length&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="na"&gt;orElse&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Too long string&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Optional 과 map 을 이용하여 null check 없이 jsonNode 접근하기:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Optional&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;of&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rootNode&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
 &lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;map&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;get&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;secondNode&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
 &lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;map&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;get&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;thirdNode&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
 &lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ifPresent&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
 &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;get&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;value&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;
 &lt;span class="o"&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;if else 를 이용한 null 체크는 source code readability 를 떨어뜨린다. Optional 과 Java doc 을 이용한 직관적인 코드 작성을 하자.&lt;/p&gt;</content><category term="java"></category><category term="NPE"></category><category term="NullPointerException"></category><category term="null"></category></entry><entry><title>Bash script 로 각 디렉터리들의 실제 사용량 조회하기</title><link href="https://imjang57.github.io/garret/check-disk-usage-of-directories-with-bash-script.html" rel="alternate"></link><published>2017-01-18T00:00:00+09:00</published><updated>2017-01-18T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-18:/garret/check-disk-usage-of-directories-with-bash-script.html</id><summary type="html">&lt;p&gt;Bash script 로 각 디렉터리들이 실제 사용하고 있는 디스크 크기를 알아보는 방법&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Linux 에서 각 디렉터리 별 디스크 사용량 확인하기&lt;/h1&gt;
&lt;p&gt;리눅스에서 각 디렉터리마다 디스크를 얼마나 사용하고 있는지 확인하기 위한 bash script 이다.&lt;/p&gt;
&lt;p&gt;스크립트:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# make newlines the only seperator (IFS : Internal Field Separator)&lt;/span&gt;
&lt;span class="nv"&gt;IFS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;$&amp;#39;\n&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; d in &lt;span class="k"&gt;$(&lt;/span&gt;ls -l &lt;span class="p"&gt;|&lt;/span&gt; grep &lt;span class="s1"&gt;&amp;#39;^d&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; awk &lt;span class="s1"&gt;&amp;#39;{ print substr($0, index($0, $9)) }&amp;#39;&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt; du -hs &lt;span class="nv"&gt;$d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;처음에 &lt;code&gt;IFS&lt;/code&gt; 를 지정해주지 않으면 디렉터리 이름에 공백이 들어간 경우 디렉터리 이름이 공백을 기준으로 split 되어 별도의 디렉터리처럼 동작하게 된다.&lt;/p&gt;
&lt;p&gt;나머지들은 워낙 기본적인 것들이니 간단하게 언급만 하면, 현재 디렉터리의 파일 목록을 조회하고, &lt;code&gt;grep&lt;/code&gt; 으로 디렉터리만 뽑아내고, &lt;code&gt;awk&lt;/code&gt; 로 파일 이름만 뽑아내고, &lt;code&gt;for&lt;/code&gt; statement 를 사용해서 각 디렉터리마다 &lt;code&gt;du&lt;/code&gt; 명령을 사용한다.&lt;/p&gt;</content><category term="bash"></category><category term="linux"></category><category term="du"></category><category term="disk"></category></entry><entry><title>JVM Process monitoring with JDK tools</title><link href="https://imjang57.github.io/garret/jvm-process-monitoring-with-jdk-tools.html" rel="alternate"></link><published>2017-01-18T00:00:00+09:00</published><updated>2017-01-18T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-18:/garret/jvm-process-monitoring-with-jdk-tools.html</id><summary type="html">&lt;p&gt;JDK Tools 을 사용하여 JVM Process 를 모니터링하는 방법에 대한 소개&lt;/p&gt;</summary><content type="html">&lt;h1&gt;JVM Process monitoring&lt;/h1&gt;
&lt;p&gt;요즘 일 때문에 오랜만에 자바를 사용하고 있고, 스칼라에 관심이 생겨 공부해보고 있다. 그런데 둘다 &lt;em&gt;JVM&lt;/em&gt; 기반 언어다 보니 JVM 에 대해 알아야 겠다는 생각이 들었다. (사실 일하다가 JVM 모니터링 할 일이 생긴 김에 간단하게 정리한다.) 어쨌든 둘 다 JVM 에서 동작하는 녀석들이라 JVM 모니터링에 대해 간단하게 남겨보고자 한다.&lt;/p&gt;
&lt;p&gt;자바든 스칼라든 실행되면 JVM 프로세스이다. 자바나 스칼라로 쓰여진 코드는 Java Bytecode 로 컴파일되고, JVM 은 이 Bytecode 를 실행한다. 그러므로 컴파일 된 이후에는 자바로 작성했든 스칼라로 작성했든 JVM 입장에서는 그냥 똑같은 Bytecode 이다. 그러니 같은 방법(JVM Process monitoring)으로 모니터링할 수 있다.&lt;/p&gt;
&lt;h1&gt;JVM Monitoring tools&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;JDK (Java Development Kit)&lt;/em&gt; 를 설치하면 기본적으로 자바 코드를 컴파일하기 위한 &lt;code&gt;javac&lt;/code&gt;, 컴파일된 bytecode 를 실행하는 &lt;code&gt;java&lt;/code&gt; 를 제공한다. 그리고 개발자들을 위한 다양한 도구들을 기본적으로 제공한다. 모니터링을 위해서 아래 도구들을 사용가능하다.(물론 아래 도구들 외에 더 많다.)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;jps&lt;/code&gt; : JVM Process Status&lt;/li&gt;
&lt;li&gt;&lt;code&gt;jstat&lt;/code&gt; : JVM Statistics&lt;/li&gt;
&lt;li&gt;&lt;code&gt;jhat&lt;/code&gt; : Java Heap Analysis Tool&lt;/li&gt;
&lt;li&gt;&lt;code&gt;jstack&lt;/code&gt; : Java thread Stack traces&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;VisualVM&lt;/em&gt; 과 같은 GUI 도구도 있지만 어쨌든 기본은 CLI 도구들이고, GUI 도구들도 CLI 도구들을 이용하는 형태이다.&lt;/p&gt;
&lt;h1&gt;JVM Monitoring&lt;/h1&gt;
&lt;p&gt;JVM 프로세스를 모니터링하려면 당연히 JVM 프로세스가 있어야 한다. 테스트 프로그램은 임시로 tomcat 을 사용하였다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;yum install -y tomcat&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;passwd tomcat&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/etc/passwd&lt;/code&gt; 파일에서 tomcat 계정의 login shell 을 bash 로 지정&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sudo service tomcat start&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;tomcat 계정으로 전환(&lt;code&gt;su - tomcat&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;jps : JVM Process Status&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;jps&lt;/code&gt; 를 실행하면 JVM Process 목록과 PID 를 확인할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ jps
&lt;span class="m"&gt;17285&lt;/span&gt; Bootstrap
&lt;span class="m"&gt;17322&lt;/span&gt; Jps
$ jps -m
&lt;span class="m"&gt;17285&lt;/span&gt; Bootstrap start
&lt;span class="m"&gt;17398&lt;/span&gt; Jps -m
$ jps -ml
&lt;span class="m"&gt;17285&lt;/span&gt; org.apache.catalina.startup.Bootstrap start
&lt;span class="m"&gt;17413&lt;/span&gt; sun.tools.jps.Jps -ml
$
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;jstat: JVM Statistics&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;jps&lt;/code&gt; 에서 확인한 PID 로 &lt;code&gt;jstat&lt;/code&gt; 를 실행할 수 있다. 위에서 tomcat 을 실행하는 Bootstrap 의 PID 가 17285 이므로 이를 이용하여 &lt;code&gt;jstat&lt;/code&gt; 을 실행하였다. 그리고 1000 밀리초 단위로 통계치를 수집하도록 하였다. 결과는 퍼센트(%)로 출력된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ jstat -gcutil &lt;span class="m"&gt;17285&lt;/span&gt; 1000
  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT   
  0.00  98.44  60.41   5.27  96.61  89.46      &lt;span class="m"&gt;1&lt;/span&gt;    0.005     &lt;span class="m"&gt;0&lt;/span&gt;    0.000    0.005
  0.00  98.44  60.41   5.27  96.61  89.46      &lt;span class="m"&gt;1&lt;/span&gt;    0.005     &lt;span class="m"&gt;0&lt;/span&gt;    0.000    0.005
  0.00  98.44  60.41   5.27  96.61  89.46      &lt;span class="m"&gt;1&lt;/span&gt;    0.005     &lt;span class="m"&gt;0&lt;/span&gt;    0.000    0.005
  0.00  98.44  60.41   5.27  96.61  89.46      &lt;span class="m"&gt;1&lt;/span&gt;    0.005     &lt;span class="m"&gt;0&lt;/span&gt;    0.000    0.005
  0.00  98.44  60.41   5.27  96.61  89.46      &lt;span class="m"&gt;1&lt;/span&gt;    0.005     &lt;span class="m"&gt;0&lt;/span&gt;    0.000    0.005
$
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;위에서처럼 &lt;code&gt;-gcutil&lt;/code&gt; 옵션을 사용하면 Java Heap 현황을 확인할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;GCT&lt;/em&gt; : Garbage Collection Time (seconds, 누적)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;FGCT&lt;/em&gt; : Full GCT (seconds, 누적)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;FGC&lt;/em&gt; : Full Garbage Collection 발생 회수&lt;/li&gt;
&lt;li&gt;&lt;em&gt;M&lt;/em&gt; : Metaspace 영역의 사용률&lt;/li&gt;
&lt;li&gt;&lt;em&gt;S0&lt;/em&gt; : Survivor 0 영역의 사용률&lt;/li&gt;
&lt;li&gt;&lt;em&gt;S1&lt;/em&gt; : Survivor 1 영역의 사용률&lt;/li&gt;
&lt;li&gt;&lt;em&gt;E&lt;/em&gt; : Eden 영역의 사용률&lt;/li&gt;
&lt;li&gt;&lt;em&gt;O&lt;/em&gt; : Old 영역의 사용률&lt;/li&gt;
&lt;li&gt;&lt;em&gt;CCS&lt;/em&gt; : Compressed Class Space (part of metaspace)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;YGC&lt;/em&gt; : Young GC 발생 회수&lt;/li&gt;
&lt;li&gt;&lt;em&gt;YGCT&lt;/em&gt; : Young GC Time (seconds, 누적)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;FGCT 열의 값이 계속 증가하면 문제가 있는 것이다.&lt;/p&gt;
&lt;p&gt;M 열은 Metadata 를 위한 힙 영역이다. 이 영역은 자바8부터 M(Metaspace)로 표시되기 시작했고 이전 버전까지는 P(Permgen, Permanent Generation) 영역이라고 불리었다. 클래스의 Metadata, JVM 내부 객체 등이 저장되는 중요한 곳이다. 매우 무조건 자바 프로그램의 경우 이 영역에서 &lt;code&gt;java.lang.OutOfMemoryError&lt;/code&gt; 를 만날 수도 있다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-gcutil&lt;/code&gt; 대신 &lt;code&gt;-gccause&lt;/code&gt; 옵션을 사용하면 &lt;code&gt;-gcutil&lt;/code&gt; 의 결과에 GC 의 원인까지 확인할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ jstat -gccause &lt;span class="m"&gt;17285&lt;/span&gt; 1000
  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT    LGCC                 GCC                 
  0.00  98.44  61.41   5.27  96.61  89.46      &lt;span class="m"&gt;1&lt;/span&gt;    0.005     &lt;span class="m"&gt;0&lt;/span&gt;    0.000    0.005 Allocation Failure   No GC               
  0.00  98.44  61.41   5.27  96.61  89.46      &lt;span class="m"&gt;1&lt;/span&gt;    0.005     &lt;span class="m"&gt;0&lt;/span&gt;    0.000    0.005 Allocation Failure   No GC               
  0.00  98.44  61.41   5.27  96.61  89.46      &lt;span class="m"&gt;1&lt;/span&gt;    0.005     &lt;span class="m"&gt;0&lt;/span&gt;    0.000    0.005 Allocation Failure   No GC               
$
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;&lt;em&gt;LGCC&lt;/em&gt; : 지난 GC의 발생 이유&lt;/li&gt;
&lt;li&gt;&lt;em&gt;GCC&lt;/em&gt; : 현재 GC의 발생 이유&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;jstack: Java thread Stack traces&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;jstack&lt;/code&gt; 을 이용하면 현재 Java 프로세스의 stack dump 를 얻을 수 있다. &lt;code&gt;jstack&lt;/code&gt; 을 이용하면 현재 실행 중인 여러 thread 들의 stack 을 확인할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ jstack 17285
2016-12-26 10:32:20
Full thread dump OpenJDK 64-Bit Server VM &lt;span class="o"&gt;(&lt;/span&gt;25.111-b15 mixed mode&lt;span class="o"&gt;)&lt;/span&gt;:
&lt;span class="s2"&gt;&amp;quot;Attach Listener&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#17 daemon prio=9 os_prio=0 tid=0x00007f48d0001000 nid=0x458b waiting on condition [0x0000000000000000]&lt;/span&gt;
   java.lang.Thread.State: RUNNABLE
&lt;span class="s2"&gt;&amp;quot;ajp-bio-8009-AsyncTimeout&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#15 daemon prio=5 os_prio=0 tid=0x00007f491049c800 nid=0x43a9 waiting on condition [0x00007f48f8ba4000]&lt;/span&gt;
   java.lang.Thread.State: TIMED_WAITING &lt;span class="o"&gt;(&lt;/span&gt;sleeping&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.Thread.sleep&lt;span class="o"&gt;(&lt;/span&gt;Native Method&lt;span class="o"&gt;)&lt;/span&gt;
 at org.apache.tomcat.util.net.JIoEndpoint&lt;span class="nv"&gt;$AsyncTimeout&lt;/span&gt;.run&lt;span class="o"&gt;(&lt;/span&gt;JIoEndpoint.java:152&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.Thread.run&lt;span class="o"&gt;(&lt;/span&gt;Thread.java:745&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;ajp-bio-8009-Acceptor-0&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#14 daemon prio=5 os_prio=0 tid=0x00007f491049a000 nid=0x43a8 runnable [0x00007f48f8ca5000]&lt;/span&gt;
   java.lang.Thread.State: RUNNABLE
 at java.net.PlainSocketImpl.socketAccept&lt;span class="o"&gt;(&lt;/span&gt;Native Method&lt;span class="o"&gt;)&lt;/span&gt;
 at java.net.AbstractPlainSocketImpl.accept&lt;span class="o"&gt;(&lt;/span&gt;AbstractPlainSocketImpl.java:409&lt;span class="o"&gt;)&lt;/span&gt;
 at java.net.ServerSocket.implAccept&lt;span class="o"&gt;(&lt;/span&gt;ServerSocket.java:545&lt;span class="o"&gt;)&lt;/span&gt;
 at java.net.ServerSocket.accept&lt;span class="o"&gt;(&lt;/span&gt;ServerSocket.java:513&lt;span class="o"&gt;)&lt;/span&gt;
 at org.apache.tomcat.util.net.DefaultServerSocketFactory.acceptSocket&lt;span class="o"&gt;(&lt;/span&gt;DefaultServerSocketFactory.java:60&lt;span class="o"&gt;)&lt;/span&gt;
 at org.apache.tomcat.util.net.JIoEndpoint&lt;span class="nv"&gt;$Acceptor&lt;/span&gt;.run&lt;span class="o"&gt;(&lt;/span&gt;JIoEndpoint.java:222&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.Thread.run&lt;span class="o"&gt;(&lt;/span&gt;Thread.java:745&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;ContainerBackgroundProcessor[StandardEngine[Catalina]]&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#13 daemon prio=5 os_prio=0 tid=0x00007f4910497000 nid=0x43a7 waiting on condition [0x00007f48f8da6000]&lt;/span&gt;
   java.lang.Thread.State: TIMED_WAITING &lt;span class="o"&gt;(&lt;/span&gt;sleeping&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.Thread.sleep&lt;span class="o"&gt;(&lt;/span&gt;Native Method&lt;span class="o"&gt;)&lt;/span&gt;
 at org.apache.catalina.core.ContainerBase&lt;span class="nv"&gt;$ContainerBackgroundProcessor&lt;/span&gt;.run&lt;span class="o"&gt;(&lt;/span&gt;ContainerBase.java:1510&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.Thread.run&lt;span class="o"&gt;(&lt;/span&gt;Thread.java:745&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;GC Daemon&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#11 daemon prio=2 os_prio=0 tid=0x00007f491040c800 nid=0x43a5 in Object.wait() [0x00007f48fa637000]&lt;/span&gt;
   java.lang.Thread.State: TIMED_WAITING &lt;span class="o"&gt;(&lt;/span&gt;on object monitor&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.Object.wait&lt;span class="o"&gt;(&lt;/span&gt;Native Method&lt;span class="o"&gt;)&lt;/span&gt;
 - waiting on &amp;lt;0x00000000ecfdd7d0&amp;gt; &lt;span class="o"&gt;(&lt;/span&gt;a sun.misc.GC&lt;span class="nv"&gt;$LatencyLock&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
 at sun.misc.GC&lt;span class="nv"&gt;$Daemon&lt;/span&gt;.run&lt;span class="o"&gt;(&lt;/span&gt;GC.java:117&lt;span class="o"&gt;)&lt;/span&gt;
 - locked &amp;lt;0x00000000ecfdd7d0&amp;gt; &lt;span class="o"&gt;(&lt;/span&gt;a sun.misc.GC&lt;span class="nv"&gt;$LatencyLock&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;Service Thread&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#8 daemon prio=9 os_prio=0 tid=0x00007f49100e1000 nid=0x43a3 runnable [0x0000000000000000]&lt;/span&gt;
   java.lang.Thread.State: RUNNABLE
&lt;span class="s2"&gt;&amp;quot;C1 CompilerThread2&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#7 daemon prio=9 os_prio=0 tid=0x00007f49100ce000 nid=0x43a2 waiting on condition [0x0000000000000000]&lt;/span&gt;
   java.lang.Thread.State: RUNNABLE
&lt;span class="s2"&gt;&amp;quot;C2 CompilerThread1&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#6 daemon prio=9 os_prio=0 tid=0x00007f49100cc800 nid=0x43a1 waiting on condition [0x0000000000000000]&lt;/span&gt;
   java.lang.Thread.State: RUNNABLE
&lt;span class="s2"&gt;&amp;quot;C2 CompilerThread0&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#5 daemon prio=9 os_prio=0 tid=0x00007f49100bf000 nid=0x43a0 waiting on condition [0x0000000000000000]&lt;/span&gt;
   java.lang.Thread.State: RUNNABLE
&lt;span class="s2"&gt;&amp;quot;Signal Dispatcher&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#4 daemon prio=9 os_prio=0 tid=0x00007f49100bc800 nid=0x439f runnable [0x0000000000000000]&lt;/span&gt;
   java.lang.Thread.State: RUNNABLE
&lt;span class="s2"&gt;&amp;quot;Finalizer&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#3 daemon prio=8 os_prio=0 tid=0x00007f4910093000 nid=0x439e in Object.wait() [0x00007f48fb5f4000]&lt;/span&gt;
   java.lang.Thread.State: WAITING &lt;span class="o"&gt;(&lt;/span&gt;on object monitor&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.Object.wait&lt;span class="o"&gt;(&lt;/span&gt;Native Method&lt;span class="o"&gt;)&lt;/span&gt;
 - waiting on &amp;lt;0x00000000edd08988&amp;gt; &lt;span class="o"&gt;(&lt;/span&gt;a java.lang.ref.ReferenceQueue&lt;span class="nv"&gt;$Lock&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.ref.ReferenceQueue.remove&lt;span class="o"&gt;(&lt;/span&gt;ReferenceQueue.java:143&lt;span class="o"&gt;)&lt;/span&gt;
 - locked &amp;lt;0x00000000edd08988&amp;gt; &lt;span class="o"&gt;(&lt;/span&gt;a java.lang.ref.ReferenceQueue&lt;span class="nv"&gt;$Lock&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.ref.ReferenceQueue.remove&lt;span class="o"&gt;(&lt;/span&gt;ReferenceQueue.java:164&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.ref.Finalizer&lt;span class="nv"&gt;$FinalizerThread&lt;/span&gt;.run&lt;span class="o"&gt;(&lt;/span&gt;Finalizer.java:209&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;Reference Handler&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#2 daemon prio=10 os_prio=0 tid=0x00007f491008e800 nid=0x439d in Object.wait() [0x00007f48fb6f5000]&lt;/span&gt;
   java.lang.Thread.State: WAITING &lt;span class="o"&gt;(&lt;/span&gt;on object monitor&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.Object.wait&lt;span class="o"&gt;(&lt;/span&gt;Native Method&lt;span class="o"&gt;)&lt;/span&gt;
 - waiting on &amp;lt;0x00000000edd00970&amp;gt; &lt;span class="o"&gt;(&lt;/span&gt;a java.lang.ref.Reference&lt;span class="nv"&gt;$Lock&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.Object.wait&lt;span class="o"&gt;(&lt;/span&gt;Object.java:502&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.ref.Reference.tryHandlePending&lt;span class="o"&gt;(&lt;/span&gt;Reference.java:191&lt;span class="o"&gt;)&lt;/span&gt;
 - locked &amp;lt;0x00000000edd00970&amp;gt; &lt;span class="o"&gt;(&lt;/span&gt;a java.lang.ref.Reference&lt;span class="nv"&gt;$Lock&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.ref.Reference&lt;span class="nv"&gt;$ReferenceHandler&lt;/span&gt;.run&lt;span class="o"&gt;(&lt;/span&gt;Reference.java:153&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;main&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#1 prio=5 os_prio=0 tid=0x00007f4910009000 nid=0x4397 runnable [0x00007f4919dbd000]&lt;/span&gt;
   java.lang.Thread.State: RUNNABLE
 at java.net.PlainSocketImpl.socketAccept&lt;span class="o"&gt;(&lt;/span&gt;Native Method&lt;span class="o"&gt;)&lt;/span&gt;
 at java.net.AbstractPlainSocketImpl.accept&lt;span class="o"&gt;(&lt;/span&gt;AbstractPlainSocketImpl.java:409&lt;span class="o"&gt;)&lt;/span&gt;
 at java.net.ServerSocket.implAccept&lt;span class="o"&gt;(&lt;/span&gt;ServerSocket.java:545&lt;span class="o"&gt;)&lt;/span&gt;
 at java.net.ServerSocket.accept&lt;span class="o"&gt;(&lt;/span&gt;ServerSocket.java:513&lt;span class="o"&gt;)&lt;/span&gt;
 at org.apache.catalina.core.StandardServer.await&lt;span class="o"&gt;(&lt;/span&gt;StandardServer.java:470&lt;span class="o"&gt;)&lt;/span&gt;
 at org.apache.catalina.startup.Catalina.await&lt;span class="o"&gt;(&lt;/span&gt;Catalina.java:781&lt;span class="o"&gt;)&lt;/span&gt;
 at org.apache.catalina.startup.Catalina.start&lt;span class="o"&gt;(&lt;/span&gt;Catalina.java:727&lt;span class="o"&gt;)&lt;/span&gt;
 at sun.reflect.NativeMethodAccessorImpl.invoke0&lt;span class="o"&gt;(&lt;/span&gt;Native Method&lt;span class="o"&gt;)&lt;/span&gt;
 at sun.reflect.NativeMethodAccessorImpl.invoke&lt;span class="o"&gt;(&lt;/span&gt;NativeMethodAccessorImpl.java:62&lt;span class="o"&gt;)&lt;/span&gt;
 at sun.reflect.DelegatingMethodAccessorImpl.invoke&lt;span class="o"&gt;(&lt;/span&gt;DelegatingMethodAccessorImpl.java:43&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.reflect.Method.invoke&lt;span class="o"&gt;(&lt;/span&gt;Method.java:498&lt;span class="o"&gt;)&lt;/span&gt;
 at org.apache.catalina.startup.Bootstrap.start&lt;span class="o"&gt;(&lt;/span&gt;Bootstrap.java:294&lt;span class="o"&gt;)&lt;/span&gt;
 at org.apache.catalina.startup.Bootstrap.main&lt;span class="o"&gt;(&lt;/span&gt;Bootstrap.java:428&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;VM Thread&amp;quot;&lt;/span&gt; &lt;span class="nv"&gt;os_prio&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="nv"&gt;tid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00007f4910084800 &lt;span class="nv"&gt;nid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x439c runnable
&lt;span class="s2"&gt;&amp;quot;GC task thread#0 (ParallelGC)&amp;quot;&lt;/span&gt; &lt;span class="nv"&gt;os_prio&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="nv"&gt;tid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00007f491001e000 &lt;span class="nv"&gt;nid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x4398 runnable
&lt;span class="s2"&gt;&amp;quot;GC task thread#1 (ParallelGC)&amp;quot;&lt;/span&gt; &lt;span class="nv"&gt;os_prio&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="nv"&gt;tid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00007f491001f800 &lt;span class="nv"&gt;nid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x4399 runnable
&lt;span class="s2"&gt;&amp;quot;GC task thread#2 (ParallelGC)&amp;quot;&lt;/span&gt; &lt;span class="nv"&gt;os_prio&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="nv"&gt;tid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00007f4910021800 &lt;span class="nv"&gt;nid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x439a runnable
&lt;span class="s2"&gt;&amp;quot;GC task thread#3 (ParallelGC)&amp;quot;&lt;/span&gt; &lt;span class="nv"&gt;os_prio&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="nv"&gt;tid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00007f4910023800 &lt;span class="nv"&gt;nid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x439b runnable
&lt;span class="s2"&gt;&amp;quot;VM Periodic Task Thread&amp;quot;&lt;/span&gt; &lt;span class="nv"&gt;os_prio&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="nv"&gt;tid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00007f49100ef800 &lt;span class="nv"&gt;nid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x43a4 waiting on condition
JNI global references: 44
$
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;References&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.wolfe.id.au/2011/10/16/monitoring-the-openjdk-from-the-cli/"&gt;Monitoring the OpenJDK from the CLI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://d2.naver.com/helloworld/6043"&gt;Garbage Collection 모니터링 방법&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="java"></category><category term="jvm"></category><category term="monitoring"></category><category term="jps"></category><category term="stat"></category><category term="stack"></category></entry><entry><title>Windows 에서 Filename too long 에러</title><link href="https://imjang57.github.io/garret/windows-error-filename-too-long.html" rel="alternate"></link><published>2017-01-18T00:00:00+09:00</published><updated>2017-01-18T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-18:/garret/windows-error-filename-too-long.html</id><summary type="html">&lt;p&gt;Windows 에서 Filename too long 에러가 발생한 경우&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Windows 에서 Filename too long 에러&lt;/h1&gt;
&lt;p&gt;Windows 에서 Git 사용하다가 아래와 같은 에러가 발생했다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;fatal&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;cannot&lt;/span&gt; &lt;span class="n"&gt;create&lt;/span&gt; &lt;span class="n"&gt;directory&lt;/span&gt; &lt;span class="n"&gt;at&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;node_modules/gulp-clean/node_modules/gulp-util/node_modules/dateformat/node_modules/meow/node_modules/normalize-package-data/node_modules/validate-npm-package-license/node_modules/spdx-correct/node_modules/spdx-license-ids&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Filename&lt;/span&gt; &lt;span class="n"&gt;too&lt;/span&gt; &lt;span class="n"&gt;long&lt;/span&gt;
&lt;span class="n"&gt;warning&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Clone&lt;/span&gt; &lt;span class="n"&gt;succeeded&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;but&lt;/span&gt; &lt;span class="n"&gt;checkout&lt;/span&gt; &lt;span class="n"&gt;failed&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;span class="n"&gt;You&lt;/span&gt; &lt;span class="n"&gt;can&lt;/span&gt; &lt;span class="n"&gt;inspect&lt;/span&gt; &lt;span class="n"&gt;what&lt;/span&gt; &lt;span class="n"&gt;was&lt;/span&gt; &lt;span class="n"&gt;checked&lt;/span&gt; &lt;span class="n"&gt;out&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;git status&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="n"&gt;retry&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;checkout&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;git checkout -f HEAD&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;에러 메시지 부분에 파일 이름이 매우 길고 메시지 끝에 &lt;code&gt;Filename too long&lt;/code&gt; 이라는 글자가 보인다. 말그대로 파일 이름이 너무 길어서 나는 에러다.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://stackoverflow.com/questions/22575662/filename-too-long-in-git-for-windows/22575737#22575737"&gt;Stack Overflow&lt;/a&gt;의 답변에 따르면 윈도우의 오래된 파일 API 를 사용하는 경우 파일 이름의 길이가 260글자까지만 가능하다. 최신 API 를 사용하면 4096글자까지 가능하다. Window 의 Git 이 사용하는 MinGW 가 오래된 API 를 사용하는 듯하다.&lt;/p&gt;
&lt;p&gt;나는 Windows 7 에서 Git 1.9.x 버전을 사용하다가 위 에러를 만났다. 혹시나 해서 현재 최신 버전인 2.10.1 으로 다시 설치해봤지만 여전히 에러가 발생한다. 즉, 아직 고쳐지지 않았다는 이야기..&lt;/p&gt;
&lt;p&gt;&lt;a href="http://stackoverflow.com/questions/22575662/filename-too-long-in-git-for-windows/26111092#26111092"&gt;같은 StackOverflow 질문에 달린 답변&lt;/a&gt;에 따르면 아래 설정을 하면 된다고 한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git config --system core.longpaths true
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;하지만 위 설정을 해도 안된다. 위 설정으로 해결된다는 사람도 있는데 내 경우와 다른 점이 무엇인지 잘 모르겠다. 그래서 그냥 리눅스에 clone 한 Git repository 에서 export 해서 zip 으로 압축해서 옮겨왔다. 시간이 많지 않고, 다른 Git client 찾아서 설치하고 테스트하기도 귀찮고 윈도우에서 작업할게 아니라 테스트용이라..&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/msysgit/msysgit/wiki/Git-cannot-create-a-file-or-directory-with-a-long-path"&gt;이 글&lt;/a&gt;에 Git 이 윈도우에서 260자 제한을 건 기술적인 이유가 잘 나와있으니 궁금하면 읽어보자.&lt;/p&gt;
&lt;p&gt;참고로, zip 파일을 윈도우에서 압축해제 할 때도 위 에러가 발생했다. 내가 사용하던 반디집(Bandizip) 프로그램이 예전 버전이라 오래된 API 를 사용하고 있었나 싶어서 최신으로 업데이트했다. 그러니 매우 잘 동작했다.&lt;/p&gt;</content><category term="windows"></category><category term="error"></category></entry><entry><title>Windows 에서 apache zeppelin 사용 시 HiveContext 에러</title><link href="https://imjang57.github.io/garret/hive-context-error-of-zeppelin-on-windows.html" rel="alternate"></link><published>2017-01-10T00:00:00+09:00</published><updated>2016-01-10T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-10:/garret/hive-context-error-of-zeppelin-on-windows.html</id><summary type="html">&lt;p&gt;Windows 에서 apache zeppelin 사용 시 HiveContext 에러가 발생하는 경우&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Windows 에서 zeppelin 실행&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://imjang57.github.io/garret/run-spark-shell-on-windows.html"&gt;윈도우에서 spark-shell을 실행하는 방법&lt;/a&gt; 에서 윈도우에서 spark-shell 을 실행하는 방법에 대해 알아봤다. spark-shell 이 실행가능하니까 당연히 zeppelin 도 실행가능할거라고 생각된다. 그래서 실행해보니 에러가 발생했다..-_-..; 메시지가 매우 긴데.. 다음과 같은 메시지가 나오는 경우였다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Caused by: java.lang.IllegalArgumentException: java.net.URISyntaxException: Relative path in absolute URI: file:C:/Users/imjan/Desktop/zeppelin-0.6.2/spark-warehouse
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;%ZEPPELIN_HOME%\spark-warehouse&lt;/code&gt; 를 hive 테이블들을 저장하기 위해 사용하는 것 같다. 그래서 &lt;code&gt;%ZEPPELIN_HOME%\spark-warehouse&lt;/code&gt; 폴더를 생성하고 &lt;a href="https://imjang57.github.io/garret/run-spark-shell-on-windows.html"&gt;윈도우에서 spark-shell을 실행하는 방법&lt;/a&gt; 포스트에서 했떤 것 처럼 winutils 를 사용해서 권한을 설정해줬다&lt;/p&gt;
&lt;p&gt;그런데 같은 에러가 또 발생한다..!!!!..ㅆ....&lt;/p&gt;
&lt;p&gt;그래서 찾다보니 &lt;a href="https://hernandezpaul.wordpress.com/2016/11/14/apache-zeppelin-installation-on-windows-10/"&gt;이 블로그 포스트&lt;/a&gt; 에서 해결책을 찾았다.&lt;/p&gt;
&lt;p&gt;결론은 &lt;code&gt;spark.sql.warehouse.dir&lt;/code&gt; 이라는 설정값을 정확하게 설정해줘야 한다는 것이다. &lt;code&gt;%ZEPPELIN_HOME%\conf\interpreter.json&lt;/code&gt; 을 열어서 spark interprefter 설정을 찾아서 아래와 같이 &lt;code&gt;spark.sql.warehouse.dir&lt;/code&gt; 을 추가하자.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="err"&gt;...&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;quot;2C5DV85NF&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;quot;id&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;2C5DV85NF&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;quot;name&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;spark&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;quot;group&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;spark&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;quot;properties&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;quot;spark.sql.warehouse.dir&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;file:///C:/Users/imjan/Desktop/zeppelin-0.6.2/spark-warehouse&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;quot;spark.executor.memory&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;quot;args&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;quot;zeppelin.spark.printREPLOutput&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;true&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;quot;spark.cores.max&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;quot;zeppelin.dep.additionalRemoteRepository&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;spark-packages,http://dl.bintray.com/spark-packages/maven,false;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;quot;zeppelin.spark.sql.stacktrace&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;false&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;quot;zeppelin.spark.importImplicit&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;true&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;quot;zeppelin.spark.concurrentSQL&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;false&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;quot;zeppelin.spark.useHiveContext&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;true&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;quot;zeppelin.pyspark.python&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;python&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;quot;zeppelin.dep.localrepo&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;local-repo&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;quot;zeppelin.R.knitr&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;true&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;quot;zeppelin.spark.maxResult&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;1000&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;quot;master&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;local[*]&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;quot;spark.app.name&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Zeppelin&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;quot;zeppelin.R.image.width&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;100%&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;quot;zeppelin.R.render.options&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;out.format \u003d \u0027html\u0027, comment \u003d NA, echo \u003d FALSE, results \u003d \u0027asis\u0027, message \u003d F, warning \u003d F&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;quot;zeppelin.R.cmd&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;R&amp;quot;&lt;/span&gt;
      &lt;span class="p"&gt;},&lt;/span&gt;
      &lt;span class="err"&gt;...&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="err"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;그리고 아래 코드를 실행해서 테스트해보니 잘된다. &lt;code&gt;%ZEPPELIN_HOME&lt;/code&gt;\spark-warehouse&lt;code&gt;에&lt;/code&gt;tmptable` 이라는 폴더가 생성된 걸 확인할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;hiveCtx&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;org&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;apache&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;spark&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sql&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;hive&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;HiveContext&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sc&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;hiveCtx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sql&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;select 1, 2&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;saveAsTable&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;tmpTable&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr&gt;
&lt;p&gt;위의 내용은 zeppelin 내장 spark interpreter 를 사용한 경우라서 사용 형태라 다른 경우 맞지 않을 수도 있다.&lt;/p&gt;
&lt;h1&gt;참고&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://hernandezpaul.wordpress.com/2016/11/14/apache-zeppelin-installation-on-windows-10/"&gt;Apache Zeppelin installation on Windows 10&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="spark"></category><category term="zeppelin"></category></entry><entry><title>Windows 에서 spark-shell 을 실행하는 방법</title><link href="https://imjang57.github.io/garret/run-spark-shell-on-windows.html" rel="alternate"></link><published>2017-01-10T00:00:00+09:00</published><updated>2016-01-10T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-10:/garret/run-spark-shell-on-windows.html</id><summary type="html">&lt;p&gt;Windows 에서 spark-shell 을 실행하는 방법&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Windows 에서 spark-shell 실행&lt;/h1&gt;
&lt;p&gt;윈도우에서 spark-shell 실행 시 NullPointerException 발생할 경우 문제 해결하는 방법에 대한 글이다.&lt;/p&gt;
&lt;h1&gt;윈도우에서 Spark 실행 시 RuntimeException(NullPointerException) 발생&lt;/h1&gt;
&lt;p&gt;Spark 은 보통 리눅스에서 사용되지만 Local mode 로 실행하면 윈도우에서도 실행할 수 있다. 그런데 리눅스에서는 단순히 spark-shell 스크립트를 실행하면 되는데 윈도우에서는 아래와 같은 에러가 발생하는 경우가 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;java.lang.RuntimeException: java.lang.NullPointerException&lt;/span&gt;
&lt;span class="x"&gt;        at org.apache.hadoop.hive.ql.session.SessionState.start(SessionState.java:522)&lt;/span&gt;
&lt;span class="x"&gt;at org.apache.spark.sql.hive.client.ClientWrapper.&amp;lt;init&amp;gt;(ClientWrapper.scala:194)&lt;/span&gt;
&lt;span class="x"&gt;at org.apache.spark.sql.hive.client.IsolatedClientLoader.createClient(IsolatedClientLoader.scala:238)&lt;/span&gt;
&lt;span class="x"&gt;at org.apache.spark.sql.hive.HiveContext.executionHive&lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;lzycompute&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;HiveContext.scala&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="m"&gt;218&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;span class="x"&gt;at org.apache.spark.sql.hive.HiveContext.executionHive(HiveContext.scala:208)&lt;/span&gt;
&lt;span class="x"&gt;at org.apache.spark.sql.hive.HiveContext.functionRegistry&lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;lzycompute&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;HiveContext.scala&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="m"&gt;462&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;span class="x"&gt;at org.apache.spark.sql.hive.HiveContext.functionRegistry(HiveContext.scala:461)&lt;/span&gt;
&lt;span class="x"&gt;at org.apache.spark.sql.UDFRegistration.&amp;lt;init&amp;gt;(UDFRegistration.scala:40)&lt;/span&gt;
&lt;span class="x"&gt;................&lt;/span&gt;
&lt;span class="x"&gt;................&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;그냥 NullPointerException 이고 아무런 메시지가 없다…-_-…&lt;/p&gt;
&lt;p&gt;내 기억에 작년에 분명 spark-shell 을 윈도우에서 잘 썼었는데 갑자기 에러가 나서 당황했는데, HiveContext 가 원인이었다.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://blogs.msdn.microsoft.com/arsen/2016/02/09/resolving-spark-1-6-0-java-lang-nullpointerexception-not-found-value-sqlcontext-error-when-running-spark-shell-on-windows-10-64-bit/"&gt;MSDN 블로그의 한 글&lt;/a&gt;에 따르면 윈도우에서 Spark 이 HiveContext 를 초기화하기 위해서는 &lt;code&gt;winutils.exe&lt;/code&gt; 이라는 파일이 필요하다. 블로그에 따르면 HiveContext 를 초기화하는데 Hadoop 의 Native libraries 를 필요로 하기 때문이라는 듯 하다.&lt;/p&gt;
&lt;p&gt;이번에 사용하려고 했던 spark 빌드는 hive 를 포함한 빌드이기 때문에 spark-shell 이 실행될 때 무조건 HiveContext 를 초기화하게 되어 있었다. 생각해보니 작년에 사용했던 건 hive 를 제외하고 소스를 빌드해서 사용했던 것 같다.ㅠㅠ&lt;/p&gt;
&lt;p&gt;어쨌든 이 문제를 해결하기 위해서는 아래와 같은 것들이 필요하다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;winutils.exe 다운로드 및 %HADOOP_HOME%\bin 에 복사&lt;/li&gt;
&lt;li&gt;HADOOP_HOME 환경 변수 설정&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;자세한 내용은 블로그에 쉽게 나와있으니 읽어보면 되고, 아래 명령들만 기억하자.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;%HADOOP_HOME%&lt;span class="se"&gt;\b&lt;/span&gt;in&lt;span class="se"&gt;\w&lt;/span&gt;inutils.exe ls &lt;span class="se"&gt;\t&lt;/span&gt;mp&lt;span class="se"&gt;\h&lt;/span&gt;ive
%HADOOP_HOME%&lt;span class="se"&gt;\b&lt;/span&gt;in&lt;span class="se"&gt;\w&lt;/span&gt;inutils.exe chmod &lt;span class="m"&gt;777&lt;/span&gt; &lt;span class="se"&gt;\t&lt;/span&gt;mp&lt;span class="se"&gt;\h&lt;/span&gt;ive
%HADOOP_HOME%&lt;span class="se"&gt;\b&lt;/span&gt;in&lt;span class="se"&gt;\w&lt;/span&gt;inutils.exe ls &lt;span class="se"&gt;\t&lt;/span&gt;mp&lt;span class="se"&gt;\h&lt;/span&gt;ive
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;hadoop 은 설치하고 파일 옮기고 귀찮으니까 그냥 &lt;a href="https://github.com/steveloughran/winutils"&gt;winutils github&lt;/a&gt; 에서 다운로드 하자. 윈도우에서 hadoop 을 잘 쓸 수 있게 &lt;code&gt;winutils.exe&lt;/code&gt; 파일까지 포함시켜서 구성되어 있다. 다운로드 해서 &lt;code&gt;%HADOOP_HOME%&lt;/code&gt; 만 잘 잡아주면 된다.&lt;/p&gt;
&lt;h1&gt;추가로 발생한 문제&lt;/h1&gt;
&lt;p&gt;나의 경우에 위 내용을 다 했는데도 에러가 발생했다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;java.lang.RuntimeException: java.lang.RuntimeException: The root scratch dir: /tmp/hive on HDFS should be writable. Current permissions are: rwx------&lt;/span&gt;
&lt;span class="x"&gt;  at org.apache.hadoop.hive.ql.session.SessionState.start(SessionState.java:522)&lt;/span&gt;
&lt;span class="x"&gt;  at org.apache.spark.sql.hive.client.ClientWrapper.&amp;lt;init&amp;gt;(ClientWrapper.scala:204)&lt;/span&gt;
&lt;span class="x"&gt;  at org.apache.spark.sql.hive.client.IsolatedClientLoader.createClient(IsolatedClientLoader.scala:238)&lt;/span&gt;
&lt;span class="x"&gt;  at org.apache.spark.sql.hive.HiveContext.executionHive&lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;lzycompute&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;HiveContext.scala&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="m"&gt;218&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;span class="x"&gt;  at org.apache.spark.sql.hive.HiveContext.executionHive(HiveContext.scala:208)&lt;/span&gt;
&lt;span class="x"&gt;  at org.apache.spark.sql.hive.HiveContext.functionRegistry&lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;lzycompute&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;HiveContext.scala&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="m"&gt;462&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;span class="x"&gt;  at org.apache.spark.sql.hive.HiveContext.functionRegistry(HiveContext.scala:461)&lt;/span&gt;
&lt;span class="x"&gt;  at org.apache.spark.sql.UDFRegistration.&amp;lt;init&amp;gt;(UDFRegistration.scala:40)&lt;/span&gt;
&lt;span class="x"&gt;  at org.apache.spark.sql.SQLContext.&amp;lt;init&amp;gt;(SQLContext.scala:330)&lt;/span&gt;
&lt;span class="x"&gt;  at org.apache.spark.sql.hive.HiveContext.&amp;lt;init&amp;gt;(HiveContext.scala:97)&lt;/span&gt;
&lt;span class="x"&gt;  at org.apache.spark.sql.hive.HiveContext.&amp;lt;init&amp;gt;(HiveContext.scala:101)&lt;/span&gt;
&lt;span class="x"&gt;  at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)&lt;/span&gt;
&lt;span class="x"&gt;  at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)&lt;/span&gt;
&lt;span class="x"&gt;  at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)&lt;/span&gt;
&lt;span class="x"&gt;  at java.lang.reflect.Constructor.newInstance(Constructor.java:422)&lt;/span&gt;
&lt;span class="x"&gt;  at org.apache.spark.repl.Main&lt;/span&gt;&lt;span class="p"&gt;$.&lt;/span&gt;&lt;span class="nv"&gt;createSQLContext&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;Main.scala&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="m"&gt;89&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;span class="x"&gt;  ... 47 elided&lt;/span&gt;
&lt;span class="x"&gt;Caused by: java.lang.RuntimeException: The root scratch dir: /tmp/hive on HDFS should be writable. Current permissions are: rwx------&lt;/span&gt;
&lt;span class="x"&gt;  at org.apache.hadoop.hive.ql.session.SessionState.createRootHDFSDir(SessionState.java:612)&lt;/span&gt;
&lt;span class="x"&gt;  at org.apache.hadoop.hive.ql.session.SessionState.createSessionDirs(SessionState.java:554)&lt;/span&gt;
&lt;span class="x"&gt;  at org.apache.hadoop.hive.ql.session.SessionState.start(SessionState.java:508)&lt;/span&gt;
&lt;span class="x"&gt;  ... 62 more&lt;/span&gt;
&lt;span class="x"&gt;&amp;lt;console&amp;gt;:13: error: not found: value sqlContext&lt;/span&gt;
&lt;span class="x"&gt;       import sqlContext.implicits._&lt;/span&gt;
&lt;span class="x"&gt;              ^&lt;/span&gt;
&lt;span class="x"&gt;&amp;lt;console&amp;gt;:13: error: not found: value sqlContext&lt;/span&gt;
&lt;span class="x"&gt;       import sqlContext.sql&lt;/span&gt;
&lt;span class="x"&gt;              ^&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;이번에는 그래도 쉽게 이유를 알 수 있었다. 에러 메시지를 보면 다음과 같다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;The root scratch dir: /tmp/hive on HDFS should be writable. Current permissions are: rwx------
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;즉, 권한 문제다. 그런데 원래 위의 내용대로 하면 위 문제가 해결되어야 한다. 뭐가 문제인가.&lt;/p&gt;
&lt;p&gt;문제는 내가 C 드라이브가 아니라 E 드라이브에서 spark-shell 을 실행해서 였다. 위의 내용대로 해서 &lt;code&gt;C:\tmp\hive&lt;/code&gt; 를 생성하고 권한 설정했는데, spark-shell 은 E 드라이브에서 실행해서 실제로는 &lt;code&gt;E:\tmp\hive&lt;/code&gt; 에 접근했던 거였다. 그래서 &lt;code&gt;E:\tmp\hive&lt;/code&gt; 로 다시 권한을 설정하고 실행하니 잘 되었다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;code&gt;HADOOP_HOME&lt;/code&gt; 을 환경변수로 해주기 귀찮아서 더 해보니까 conf/spark-env.cmd 파일에 아래처럼 추가해줘도 동작한다.&lt;/p&gt;
&lt;p&gt;set HADOOP_HOME=C:\hadoop\hadoop-2.6.4&lt;/p&gt;
&lt;h1&gt;참고&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://blogs.msdn.microsoft.com/arsen/2016/02/09/resolving-spark-1-6-0-java-lang-nullpointerexception-not-found-value-sqlcontext-error-when-running-spark-shell-on-windows-10-64-bit/"&gt;Resolving Spark 1.6.0 "java.lang.NullPointerException, not found: value sqlContext" error when running spark-shell on Windows 10 (64-bit)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/steveloughran/winutils/tree/master/hadoop-2.6.4/bin"&gt;hadoop 2.6.4 winutils github&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="spark"></category></entry><entry><title>Git Basics</title><link href="https://imjang57.github.io/garret/git-basics.html" rel="alternate"></link><published>2017-01-05T00:00:00+09:00</published><updated>2017-01-05T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-05:/garret/git-basics.html</id><summary type="html">&lt;p&gt;Git 기본 사용법&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Git Basic&lt;/h1&gt;
&lt;p&gt;이 글은 Git 에 대해 기본적인 내용은 알고 있다고 생각하고 정리 목적으로 작성된 글이니 Git 을 아예 모르면 &lt;a href="http://git-scm.com/book/"&gt;Git Book&lt;/a&gt; 을 먼저 숙지하자.&lt;/p&gt;
&lt;p&gt;아래 내용들에 알면 Git 을 잘 사용하기 위한 개념들은 다 알고 있다고 봐도 된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;VCS (Version Control System), DVCS (Distributed Version Control System)&lt;/li&gt;
&lt;li&gt;Working tree, Staging Area (Index), Local Repository, Remote Repository, Bare Repository&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;git help&lt;/code&gt; 명령을 실행하면 사용 가능한 subcommand 들을 확인할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ git &lt;span class="nb"&gt;help&lt;/span&gt;
usage: git &lt;span class="o"&gt;[&lt;/span&gt;--version&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;--help&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;-C &amp;lt;path&amp;gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;-c &lt;span class="nv"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;value&lt;span class="o"&gt;]&lt;/span&gt;
           &lt;span class="o"&gt;[&lt;/span&gt;--exec-path&lt;span class="o"&gt;[=&lt;/span&gt;&amp;lt;path&amp;gt;&lt;span class="o"&gt;]]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;--html-path&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;--man-path&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;--info-path&lt;span class="o"&gt;]&lt;/span&gt;
           &lt;span class="o"&gt;[&lt;/span&gt;-p &lt;span class="p"&gt;|&lt;/span&gt; --paginate &lt;span class="p"&gt;|&lt;/span&gt; --no-pager&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;--no-replace-objects&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;--bare&lt;span class="o"&gt;]&lt;/span&gt;
           &lt;span class="o"&gt;[&lt;/span&gt;--git-dir&lt;span class="o"&gt;=&lt;/span&gt;&amp;lt;path&amp;gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;--work-tree&lt;span class="o"&gt;=&lt;/span&gt;&amp;lt;path&amp;gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;--namespace&lt;span class="o"&gt;=&lt;/span&gt;&amp;lt;name&amp;gt;&lt;span class="o"&gt;]&lt;/span&gt;
           &amp;lt;command&amp;gt; &lt;span class="o"&gt;[&lt;/span&gt;&amp;lt;args&amp;gt;&lt;span class="o"&gt;]&lt;/span&gt;

These are common Git commands used in various situations:

start a working area &lt;span class="o"&gt;(&lt;/span&gt;see also: git &lt;span class="nb"&gt;help&lt;/span&gt; tutorial&lt;span class="o"&gt;)&lt;/span&gt;
   clone      Clone a repository into a new directory
   init       Create an empty Git repository or reinitialize an existing one

work on the current change &lt;span class="o"&gt;(&lt;/span&gt;see also: git &lt;span class="nb"&gt;help&lt;/span&gt; everyday&lt;span class="o"&gt;)&lt;/span&gt;
   add        Add file contents to the index
   mv         Move or rename a file, a directory, or a symlink
   reset      Reset current HEAD to the specified state
   rm         Remove files from the working tree and from the index

examine the &lt;span class="nb"&gt;history&lt;/span&gt; and state &lt;span class="o"&gt;(&lt;/span&gt;see also: git &lt;span class="nb"&gt;help&lt;/span&gt; revisions&lt;span class="o"&gt;)&lt;/span&gt;
   bisect     Use binary search to find the commit that introduced a bug
   grep       Print lines matching a pattern
   log        Show commit logs
   show       Show various types of objects
   status     Show the working tree status

grow, mark and tweak your common &lt;span class="nb"&gt;history&lt;/span&gt;
   branch     List, create, or delete branches
   checkout   Switch branches or restore working tree files
   commit     Record changes to the repository
   diff       Show changes between commits, commit and working tree, etc
   merge      Join two or more development histories together
   rebase     Reapply commits on top of another base tip
   tag        Create, list, delete or verify a tag object signed with GPG

collaborate &lt;span class="o"&gt;(&lt;/span&gt;see also: git &lt;span class="nb"&gt;help&lt;/span&gt; workflows&lt;span class="o"&gt;)&lt;/span&gt;
   fetch      Download objects and refs from another repository
   pull       Fetch from and integrate with another repository or a &lt;span class="nb"&gt;local&lt;/span&gt; branch
   push       Update remote refs along with associated objects

&lt;span class="s1"&gt;&amp;#39;git help -a&amp;#39;&lt;/span&gt; and &lt;span class="s1"&gt;&amp;#39;git help -g&amp;#39;&lt;/span&gt; list available subcommands and some
concept guides. See &lt;span class="s1"&gt;&amp;#39;git help &amp;lt;command&amp;gt;&amp;#39;&lt;/span&gt; or &lt;span class="s1"&gt;&amp;#39;git help &amp;lt;concept&amp;gt;&amp;#39;&lt;/span&gt;
to &lt;span class="nb"&gt;read&lt;/span&gt; about a specific subcommand or concept.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;git help commit&lt;/code&gt; 이나 &lt;code&gt;git commit --help&lt;/code&gt; 와 같이 subcommand 자체에 대한 help 도 확인할 수 있으니 필요할 때마다 help 를 활용하자.&lt;/p&gt;
&lt;h1&gt;Git configuration&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;Git&lt;/em&gt; 설정을 적용하는 방법은 2가지가 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git config&lt;/code&gt; command 를 사용하는 방법&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.gitconfig&lt;/code&gt; 파일에 추가하는 방법&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;git config&lt;/code&gt; 명령을 사용하면 git 프로그램이 자동으로 &lt;code&gt;.gitconfig&lt;/code&gt; 파일에 해당 설정을 추가하는 것이기 때문에 결과는 같다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git config&lt;/code&gt; command:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git config --global user.name &lt;span class="s2"&gt;&amp;quot;imjang57&amp;quot;&lt;/span&gt;
git config --global user.email &lt;span class="s2"&gt;&amp;quot;imjang57@gmail.com&amp;quot;&lt;/span&gt;
git config --global color.ui auto
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;git config file (&lt;code&gt;~/.gitconfig&lt;/code&gt;):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;[user]&lt;/span&gt;
    &lt;span class="na"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;imjang57&lt;/span&gt;
&lt;span class="s"&gt;    email = imjang57@gmail.com&lt;/span&gt;
&lt;span class="k"&gt;[color]&lt;/span&gt;
    &lt;span class="na"&gt;ui&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;auto&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;위에서 &lt;code&gt;git config --global&lt;/code&gt; 과 같이 global option 을 전달했기 때문에 &lt;code&gt;~/.gitconfig&lt;/code&gt; 파일에 설정이 저장되었다. 만약 특정 Git repository 에만 설정을 적용하고 싶으면 해당 Local git repository 의 working directory 로 가서 &lt;code&gt;git config --local&lt;/code&gt; 과 같이 local option 을 사용하면 된다. 그러면 &lt;code&gt;&amp;lt;PROJECT_HOME&amp;gt;/.git/config&lt;/code&gt; 에 설정이 저장된다.&lt;/p&gt;
&lt;p&gt;현재의 git 설정들을 확인하고 싶다면 &lt;code&gt;git config --list&lt;/code&gt; 와 같이 실행한다. 만약 범위를 좁히고 싶다면 &lt;code&gt;git config --list --system&lt;/code&gt;, &lt;code&gt;git config --list --global&lt;/code&gt;, &lt;code&gt;git config --list --local&lt;/code&gt; 와 같이 실행할 수도 있다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;아래 설정은 git 이 실행할 텍스트 에디터 명령을 지정한다. commit message 작성 등을 위해 사용된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git config --global core.editor &amp;quot;\&amp;quot;C:\Windows\notepad.exe\&amp;quot;&amp;quot;
git config --global core.editor &amp;quot;nano&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr&gt;
&lt;p&gt;아래 설정은 proxy 를 설정한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git config --global http.proxy http://&amp;lt;username&amp;gt;:&amp;lt;password&amp;gt;@&amp;lt;host&amp;gt;:&amp;lt;port&amp;gt;
git config --global https.proxy http://&amp;lt;username&amp;gt;:&amp;lt;password&amp;gt;@&amp;lt;host&amp;gt;:&amp;lt;port&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;만약 프록시 서버가 별도의 인증서가 필요하면 다음과 같은 설정으로 인증서 파일을 추가한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git config --global http.sslCAInfo /path/to/mycertification.crt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;아니면 다음과 같이 ssl 인증서에 대한 validation 을 하지 않도록 설정할 수도 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git config http.sslVerify &lt;span class="nb"&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr&gt;
&lt;p&gt;아래 설정은 git 에서 사용하는 scheme 을 강제로 변환하기 위해 사용된다. 아래와 같이 설정하면 git scheme 을 https 로 바꿔서 사용하게 된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git config --global url.&lt;span class="s2"&gt;&amp;quot;https://&amp;quot;&lt;/span&gt;.insteadOf git://
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Git basic usage&lt;/h1&gt;
&lt;h2&gt;Git Local Repository 생성&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;새로운 git repository 생성 : &lt;code&gt;git init&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;명령어를 실행한 경로에 &lt;code&gt;.git&lt;/code&gt; 이라는 디렉터리가 생성되어 repository 관리 정보가 저장된다. &lt;code&gt;git init&lt;/code&gt; 명령을 실행한 디렉터리의 내용을 &lt;em&gt;Working Tree&lt;/em&gt; 라고 한다. working tree 의 변경 내용이 있을 때 &lt;code&gt;git add&lt;/code&gt;, &lt;code&gt;git rm&lt;/code&gt; 등을 실행하면 &lt;em&gt;Index&lt;/em&gt; 가 생성된다. &lt;code&gt;git commit&lt;/code&gt; 을 실행하면 local branch 에 변경 내용이 적용된다. &lt;code&gt;git push&lt;/code&gt; 를 실행하면 remote repository 에 변경된 내용을 추가한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Remote Repository 추가 : &lt;code&gt;git remote add &amp;lt;remote repository name&amp;gt; &amp;lt;Remote Repository URL&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;git init&lt;/code&gt; 후에 &lt;code&gt;git remote add&lt;/code&gt; 를 통해 remote repoistory 를 추가할 수 있다. 이후 &lt;code&gt;git fetch&lt;/code&gt; 을 실행하면 remote repository 의 정보를 읽어서 local repository 에 동기화한다. 그런데 &lt;code&gt;git fetch&lt;/code&gt;는 working tree 에 이 정보들을 적용하지는 않는다. 단지 local repository (&lt;code&gt;.git&lt;/code&gt; directory) 에만 정보를 저장한다. &lt;code&gt;git remote add origin ssh://user@host:22/repos/project&lt;/code&gt; 로 remote repository 를 등록했으면 &lt;code&gt;git merge origin/master&lt;/code&gt; 를 실행해서 merge 해야만 working tree 에 최신 정보가 적용된다. 만약 이 과정이 귀찮으면 그냥 &lt;code&gt;git pull&lt;/code&gt; 을 실행하면 된다. &lt;code&gt;git pull&lt;/code&gt; 은 &lt;code&gt;git fetch&lt;/code&gt; 와 &lt;code&gt;git merge&lt;/code&gt; 를 한꺼번에 실행해준다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Git Local Repository 를 만드는 다른 방법은 Remote Repository 를 복사하는 것이다. &lt;code&gt;git clone &amp;lt;url&amp;gt; [target directory]&lt;/code&gt; 을 실행하면 remote repository 를 복사한다. target directory 를 지정해주지 않으면 remote repository 의 이름으로 target directory 가 생성된다.&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;remote repository 목록 확인 : &lt;code&gt;git remote&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;URL 포함하여 remote repository 목록 확인 : &lt;code&gt;git remote -v&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;remote repository 상세 정보 확인 : &lt;code&gt;git remote show [remote repository name]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;remote repository 를 삭제 : &lt;code&gt;git remote rm &amp;lt;remote repository name&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;remote repository 의 이름 변경 : &lt;code&gt;git remote rename &amp;lt;from_name&amp;gt; &amp;lt;to_name&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2&gt;Bare repository&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;git init&lt;/code&gt; 을 실행할 때 &lt;code&gt;--bare&lt;/code&gt; 옵션을 추가하면 &lt;em&gt;Bare repository&lt;/em&gt; 를 생성한다. &lt;em&gt;Bare repository&lt;/em&gt; 는 저장소 역할만 한다. 즉, &lt;em&gt;Working directory&lt;/em&gt; 가 생성되지 않으며, 읽기 작업만 가능하다. &lt;code&gt;git init --bare &amp;lt;repository name&amp;gt;&lt;/code&gt; 으로 생성된 repository 에는 보통 &lt;code&gt;.git&lt;/code&gt; 디렉터리에 생성되는 파일들이 그대로 생성된다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Bare repository&lt;/em&gt; 는 코드 공유 및 협업을 위한 서버에 생성되는 저장소로 사용되며 각 개발자들은 이 &lt;em&gt;Bare repository&lt;/em&gt; 를 clone 하여 각자의 작업을 진행한다.&lt;/p&gt;
&lt;h2&gt;Managing Modifications in local repository&lt;/h2&gt;
&lt;p&gt;Git 으로 변경사항들을 관리하기 위한 기본적인 명령들을에는 status, add, rm, mv, commit, stash, diff 등이 있다.&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;repository 상태 (현재 branch, 변경 내역 등) 확인 : &lt;code&gt;git status&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;staging area (index) 에 파일 추가 : &lt;code&gt;git add &amp;lt;file&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;새롭게 생성된 Untracked files 나 modificated files 는 &lt;code&gt;git commit&lt;/code&gt; 전에 &lt;code&gt;git add&lt;/code&gt; 로 staging area 에 등록해야 한다. staging area 는 commit 전에 존재하는 임시 영역이다.&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;git repository 에 변경 내용을 기록 : &lt;code&gt;git commit [-m "messages"]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Staging area 에 기록된 파일들을 실제 repository 에 반영하는 작업이다. -m 옵션이 없다면 git 환경설정에서 지정된 editor 가 실행되고 자세한 로그를 작성할 수 있다. 관례적으로 첫 번째 줄에는 로그에 대한 한 줄 요약을 작성하고 두 번째 줄은 공백, 세 번째 줄부터 상세 내용을 작성한다. 아무것도 입력하지 않고 editor 를 종료하면 commit 이 취소된다.&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;working tree 와 staging area 의 차이를 확인 : &lt;code&gt;git diff&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;staging area 와 laest commit 의 차이를 확인 : &lt;code&gt;git diff --staged&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;working tree 와 최신 commit 의 차이를 확인 : &lt;code&gt;git diff HEAD&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;특정 branch 와 master branch 간의 diff 확인 : &lt;code&gt;git diff master..&amp;lt;branch name&amp;gt; [path]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;staging area 의 파일 삭제 : &lt;code&gt;git rm &amp;lt;path/to&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;특정 파일을 staging area 에서 삭제하지만 working tree 에는 보존 : &lt;code&gt;git rm --cached &amp;lt;path/to&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;파일 이동 : &lt;code&gt;git mv &amp;lt;from_file&amp;gt; &amp;lt;to_file&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;현재의 모든 변경 내용을 임시 저장하기 : &lt;code&gt;git stash&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;가장 최근의 임시 저장된 내용을 다시 적용하기 : &lt;code&gt;git stash pop&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;현재 임시 저장된 목록을 출력 : &lt;code&gt;git stash list&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;가장 최근의 임시 저장된 내용을 삭제 : &lt;code&gt;git stash drop&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Igrnoring files&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;.gitigrnore&lt;/code&gt; 파일에 무시할 파일들의 리스트를 추가하면 이후 추가된 파일들은 git add 등으로 변경 내용을 index 에 적용할 때 무시된다. 디렉터리마다 &lt;code&gt;.gitignore&lt;/code&gt; 파일을 생성할 수 있으며 해당 디렉터리부터 하위 디렉터리 들에 대해 파일의 내용이 적용된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;*.[oa]       # ignore files ending in &amp;quot;.o&amp;quot; or &amp;quot;.a&amp;quot;
!lib.a       # do track lib.a, even though you&amp;#39;re ignoring .a files above
*~           # ignore files ending in tilde(&amp;quot;~&amp;quot;)
/TODO        # only ignore the root TODO file, not subdir/TODO
build/       # ignore all files in the build/ directory
doc/*.txt    # ignore doc/notes.txt, but not doc/server/arch.txt
doc/**/*.txt # ignore all &amp;quot;*.txt&amp;quot; files in the doc/ directory
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;.gitignore&lt;/code&gt; 파일의 다른 용도는 empty directory 를 repository 에 저장하기 위해 사용된다. git 은 빈 디렉터리는 저장소에 저장하지 않는다. 이때 빈 디렉터리 안에 임의의 빈 &lt;code&gt;.gitignore&lt;/code&gt; 파일을 생성하여 commit 하면 해당 디렉터리도 저장소에 추가할 수 있다.&lt;/p&gt;
&lt;h2&gt;Viewing the Commit History&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;commit history 확인 : &lt;code&gt;git log [/path/to]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;commit 에서 변경된 내용도 같이 확인 : - &lt;code&gt;git log -p [/path/to]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;마지막 2개의 내용만 확인 : &lt;code&gt;git log -2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;한줄 요약으로 보기 : &lt;code&gt;git log --pretty=oneline&lt;/code&gt;, &lt;code&gt;git log --oneline&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Commit graph 를 같이 확인 : &lt;code&gt;git log --graph&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Commit 에 대한 Reference 정보 추가 : &lt;code&gt;git log --decorate&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;전체 또는 특정 branch 에 대한 Commit 정보 확인 : &lt;code&gt;git log --branch[=&amp;lt;pattern&amp;gt;]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;master branch 에 없고 feature-A branch 에 존재하는 commit 들을 확인 : &lt;code&gt;git log master..feature-A&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;전체 branch 의 commit 들을 commit graph 와 Reference 정보를 추가하여 한줄만 확인하려면 &lt;code&gt;git log --branches --graph --decoraete --oneline&lt;/code&gt; 을 실행하면 된다.&lt;/p&gt;
&lt;p&gt;특정 파일의 version history list 를 확인하려면 &lt;code&gt;git log --follow [file]&lt;/code&gt; 를 실행한다. git 나름대로 rename 한 작업까지 계산해준다.&lt;/p&gt;
&lt;h2&gt;Working with Remote Repository&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;git pull&lt;/code&gt;, &lt;code&gt;git fetch&lt;/code&gt;, &lt;code&gt;git merge&lt;/code&gt;, &lt;code&gt;git push&lt;/code&gt; 를 통해 remote repository 와 동기화할 수 있다.&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;Remote Repository 의 변경 내용들을 Local Repository 로 갱신 : &lt;code&gt;git pull&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;원격 저장소의 변경 내용이 로컬 작업 디렉토리에 받아지고(fetch), 병합(merge)된다. &lt;code&gt;git pull&lt;/code&gt; 은 내부적으로 아래의 두 명령이 연속적으로 실행된 것과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git fetch &amp;lt;remote repository name&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git merge &amp;lt;remote repository name&amp;gt;/master&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;Local Repository 의 commit 들을 Remote Repository 에 전달 : &lt;code&gt;git push [remote repository] [remote branch]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Remote Repository 이름이 origin 이고, origin 의 master branch 로 Local Repository 의 변경 내용을 올리려고 하면 &lt;code&gt;git push origin master&lt;/code&gt; 를 실행한다.&lt;/p&gt;
&lt;h2&gt;Branch and Merge&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;branch 목록 출력 및 현재 작업 중인 branch 확인 : &lt;code&gt;git branch&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Remote Repository 의 branch 들을 모두 포함하여 출력 : &lt;code&gt;git branch -a&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;branch 생성 : &lt;code&gt;git branch &amp;lt;branch name&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;branch 변경 : &lt;code&gt;git checkout &amp;lt;branch name&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;branch 생성 및 변경 : &lt;code&gt;git checkout -b &amp;lt;branch name&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;만약 feature-A 라는 이름의 branch를 생성하고 해당 branch 로 변경하고 싶으면 &lt;code&gt;git checkout -b feature-A&lt;/code&gt; 을 실행한다. 이는 다음 명령어 들을 연속으로 실행한 것과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git branch feature-A&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git checkout feature-A&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이후 master branch 로 돌아오려면 &lt;code&gt;git checkout master&lt;/code&gt; 를 실행한다. 만약 현재 branch 를 사용하기 전의 branch 로 되돌아가려면 &lt;code&gt;git checkout -&lt;/code&gt; 를 실행하면 된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;branch 삭제 : &lt;code&gt;git branch -d &amp;lt;branch name&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;branch 를 merge 하기 : &lt;code&gt;git merge [options] &amp;lt;branch name&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;만약 구현이 완료된 feature-A branch 를 merge 하려면 base branch(보통 master 또는 development)에서 &lt;code&gt;git merge feature-A&lt;/code&gt; 를 실행한다.&lt;/p&gt;
&lt;h2&gt;Resolve conflicts&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;git pull&lt;/code&gt;, &lt;code&gt;git merge&lt;/code&gt; 등을 하다보면 내가 변경하고 commit 한 내용과 다른 사람이 변경하고 commit 한 내용이 서로 충돌하는 경우가 발생한다. 대부분의 경우 git 이 자동으로 바뀐 부분을 알아서 적용해준다. 하지만 만약 서로 다른 사람들이 파일의 같은 부분을 동시에 고쳤을 경우, git 이 해결하지 못하고 충돌이 발생했음을 알려준다.&lt;/p&gt;
&lt;p&gt;이렇게 충돌이 발생하면, git이 알려주는 파일의 충돌 부분을 직접 수정해서 병합이 가능하도록 수정해야 한다. 충돌을 해결했다면, &lt;code&gt;git add [file path]&lt;/code&gt; 를 실행하여 수정된 부분을 다시 index 에 저장하고 commit 한다.&lt;/p&gt;
&lt;p&gt;변경 내용을 병합하기 전에, &lt;code&gt;git diff&lt;/code&gt; 를 사용하여 어떻게 바뀌었는지 비교해보는 것이 좋다.&lt;/p&gt;
&lt;h2&gt;Rebase&lt;/h2&gt;
&lt;p&gt;보통 &lt;code&gt;git merge&lt;/code&gt; 를 실행하면 작업 내용이 특정 parent commit 에서 분기되지 않았으면 &lt;em&gt;fast forward&lt;/em&gt; 방식이라고 해서 그대로 commit 내용을 가져 온 후 HEAD Reference 를 가장 최신의 commit 으로 변경한다.&lt;/p&gt;
&lt;p&gt;하지만 특정 parent commit 에서 작업 내용이 분기된 경우 &lt;code&gt;git merge&lt;/code&gt; 는 Base commit 으로부터 분기된 두 작업 내용을 합쳐서 새로운 commit 을 생성한다. 즉, parent commit 이 2개인 새로운 commit 이 생성되는 것이다. 이 경우 merge 한 내용을 commit history 나 graph 로 확인할 때 복잡해질 수 있다. 때문에 merge 전에 rebase 를 하도록 권장하기도 한다. 단, 이는 각 팀에 따라 다를 수 있다. 어떤 팀은 그냥 merge 를 할 수 있고 어떤 팀은 rebase 를 장려할 수도 있다. 필수는 아니다.&lt;/p&gt;
&lt;p&gt;만약 feature-A branch 에서 기능 개발 완료 후 master 로 merge 전에 rebase 를 하여 commit history 를 정리하고 싶다면 feature-A branch 에서 &lt;code&gt;git rebase master&lt;/code&gt; 를 실행한다. 그 후 master branch 로 전환한 후 &lt;code&gt;git merge feature-A&lt;/code&gt; 를 실행하면 &lt;em&gt;fast forward&lt;/em&gt; 방식으로 merge 된 것과 같이 commit history 가 정리된다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git merge&lt;/code&gt; 와 마찬가지로 &lt;code&gt;git rebase&lt;/code&gt; 도 conflict 가 발생할 수 있다. rebase 중에 conflic file 이 발견되면 rebase 작업은 잠시 멈추게 된다. 그리고 merge 와 마찬가지로 conflict file 을 수정한 후 &lt;code&gt;git add &amp;lt;conflict file&amp;gt;&lt;/code&gt; 을 실행한 뒤 &lt;code&gt;git rebase --continue&lt;/code&gt; 를 실행하면 작업이 이어서 진행된다. 만약 rebase 작업을 취소하고 싶다면 &lt;code&gt;git rebase --abort&lt;/code&gt; 를 실행한다.&lt;/p&gt;
&lt;p&gt;rebase 와 commit cherry-picking 으로 commit 을 관리하면 &lt;em&gt;fast forward&lt;/em&gt; 방식으로 정리된  commit history 를 관리할 수 있다.&lt;/p&gt;
&lt;p&gt;자세한 내용은 &lt;code&gt;git help rebase&lt;/code&gt; 나 공식 문서를 확인하자.&lt;/p&gt;
&lt;h2&gt;Tag&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Tag 목록 확인 : &lt;code&gt;git tag&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Tag 생성 : &lt;code&gt;git tag &amp;lt;tag name&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Tag 삭제 : &lt;code&gt;git tag -d &amp;lt;tag name&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;pattern 으로 tag 목록 확인 : &lt;code&gt;git tag -l 'v1.8.5*'&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;특정 tag의 정보 보기 : &lt;code&gt;git show &amp;lt;tag name&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;이미 지나간 commit 에 대한 tag 를 생성 : git tag -a &lt;tag name&gt; &lt;commit ID&gt;&lt;/li&gt;
&lt;li&gt;remote server 에 tag 정보 push : &lt;code&gt;git push origin [tagname]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;remote server 에 모든 tag 정보를 한꺼번에 전송 : &lt;code&gt;git push origin --tags&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;git tag 에는 2가지 type 이 있다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;lightweight : pointer to a specific commit. 즉, lightweight tag 정보는 오직 commit checksum 만 저장된다.&lt;/li&gt;
&lt;li&gt;annotated tag: stored as full objects in the Git database. They are checksummed; contain the tagger name, e-mail, and date; have a tagging message; and can be signed and verified with GNU Privacy Guard (GPG).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;git tag &amp;lt;tag name&amp;gt;&lt;/code&gt; 으로 Tag 를 생성할 경우 기본적으로 libweight tag 이다. annotated tag 는 &lt;code&gt;-a&lt;/code&gt; 옵션을 사용(&lt;code&gt;git tag -a &amp;lt;tag name&amp;gt; -m '&amp;lt;message&amp;gt;'&lt;/code&gt;)해야 한다. &lt;code&gt;-m&lt;/code&gt; 옵션이 없으면 git 에 editor 를 실행하여 message를 입력할 수 있도록 한다.&lt;/p&gt;
&lt;p&gt;annotated tag 는 추가적인 tag 정보들(tag name, tagger, date, message 등)과 commit 내용을 보여 준다. lightweight tag 는 tag 관련된 추가적인 정보들이 없이 commit 내용만 보여준다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tag 로 checkout : &lt;code&gt;git checkout -b version2 v2.0.0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;git 에는 사실 tag 로 checkout 하는 기능은 없다. 단지 특정 tag 로 branch 를 만드는 것이다. 때문에 이렇게 만들어진 branch 에서 작업하고 commit 하면 master 에 반영이 안되니 주의해야 한다.&lt;/p&gt;
&lt;h1&gt;Advanced&lt;/h1&gt;
&lt;h2&gt;Undo modifications&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Local 의 변경 내용을 HEAD 로 되돌리기: &lt;code&gt;git checkout -- &amp;lt;file path&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;위의 명령은 이미 인덱스에 추가된 변경 내용과 새로 생성한 파일은 그대로 남는다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Staging Area (index) 의 파일을 Unstaged 로 바꾸기: &lt;code&gt;git reset HEAD &amp;lt;file path&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;만약 어떤 파일을 수정한 후 git add 를 실행하여 Staged 상태일 때, 변경 내용들을 취소하고 싶을 경우 아래 명령들을 차례로 실행한다.&lt;/p&gt;
&lt;p&gt;HEAD 는 Git 에서 사용되는 special pointer 이다. HEAD 는 현재 작업 중인 local branch 를 가리킨다. &lt;code&gt;git checkout&lt;/code&gt; 으로 branch 를 변경하면 HEAD 가 변경된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Repository 의 history 중 하나로 복원하기: &lt;code&gt;git reset [options] &amp;lt;commit hash ID&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;history 와 모든 변경 내용들을 삭제하면서 특정 commit 으로 되돌아가기 : &lt;code&gt;git reset --hard [commit]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;git reset --hard&lt;/code&gt; 의 경우 history 를 포함한 모든 변경 내용들을 삭제하여 깔끔하게 이전 내용으로 되돌아갈 수 있다. 하지만 Local Git Repository 가 다른 Remote Repository 와 공유될 경우 문제가 발생할 수도 있다. 이때 사용가능 한 것이 &lt;code&gt;git revert &amp;lt;commit hash ID&amp;gt;&lt;/code&gt; 이다. &lt;code&gt;git revert&lt;/code&gt; 는 history 와 commit 들을 삭제하지 않는다. 내용을 특정 commit 으로 되돌리지만 삭제하지 않고 또하나의 새로운 commit 으로 처리한다.&lt;/p&gt;
&lt;h2&gt;Modify commits&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;commit 수정하기: &lt;code&gt;git commit --amend&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;아래와 같은 경우 commit 내용을 수정해야 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;어떤 파일을 빼먹었을 때&lt;/li&gt;
&lt;li&gt;commit message 를 잘못 적었을 때&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;커밋을 했는데 Stage하는 것을 깜빡하고 빠트린 파일이 있으면 아래와 같이 고칠 수 있다:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git commit -m &amp;#39;initial commit&amp;#39;
git add &amp;lt;forgotten_file_path&amp;gt;
git commit --amend
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;여기서 실행한 명령어 3개는 모두 하나의 commit 으로 기록된다. 두 번째 commit 은 첫 번째 commit 을 덮어쓴다.&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;.git&lt;/code&gt; directory&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;.git&lt;/code&gt; 디렉터리는 local git repository 정보가 저장되는 곳이다. 안에 여러 파일들이 있는데 간단하게 중요한 몇몇 파일만 설명하면 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.git/objects&lt;/code&gt; : 각 Commit Object 들이 Hash 값에 따라 저장됨&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.git/refs&lt;/code&gt; : Commit Hash 를 참조하는 Reference 정보&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.git/refs/heads&lt;/code&gt; : local git repository 의 각 branch 들의 HEAD 가 저장(master branch 의 head 는 &lt;code&gt;.git/refs/heads/master&lt;/code&gt; 에 저장)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.git/HEAD&lt;/code&gt; : 현재 작업 중인 branch 의 HEAD 정보를 나타냄(예 : ref: refs/heads/master)&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Github&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;branch 들 (example: ruby on rails repository 의 4-0-stable branch 와 3-2-stable branch) 사이의 변경 내역 확인하는 방법 : &lt;code&gt;https://github.com/rails/rails/compare/4-0-stable...3-2-stable&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;master branch 의 2015년 1월 1일부터의 변경 내역을 확인하는 방법(변경 내역이 너무 많거나, 기간이 너무 긴 경우에는 최근 변경 내용만 나온다) : &lt;code&gt;https://www.github.com/rails/rails/compare/master@{2015-01-01}...master&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;References&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://git-scm.com/book/en/v2"&gt;Git Book English&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://git-scm.com/book/ko/v2"&gt;Git Book Korean&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://rogerdudler.github.io/git-guide/index.ko.html"&gt;git - 간편 안내서&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="git"></category></entry><entry><title>Granularity (Coarse-grained V.S. Fine-grained)</title><link href="https://imjang57.github.io/garret/granularity-coarse-grained-and-fine-grained.html" rel="alternate"></link><published>2017-01-04T00:00:00+09:00</published><updated>2017-01-04T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-04:/garret/granularity-coarse-grained-and-fine-grained.html</id><summary type="html">&lt;p&gt;Granularity (Coarse-grained V.S. Fine-grained) 의 의미&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Coarse-grained V.S. Fine-grained in Spark&lt;/h1&gt;
&lt;p&gt;Coarse-grained 와 Fine-grained 는 한국말로 번역하기가 참 애매한 단어이다. 그래서 의미도 잘 와닿지 않는다.&lt;/p&gt;
&lt;p&gt;Quora 에 누군가가 &lt;a href="https://www.quora.com/What-does-coarse-grained-mean-in-Spark-RDD"&gt;Spark RDD 에서 사용되는 Coarse-grained 의 개념에 대해 질문&lt;/a&gt;하였는데, 누군가가 coarse-grained 에 대해 아래와 같이 설명한다.:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Basically, it means that you can write you transformations to be applied to the while dataset, but not individual elements on the dataset. Operations like map, filter, group reduce, but not get(index) or set(index).&lt;/p&gt;
&lt;p&gt;By restricting RDD operations to coarse-grained immutable transformations, Spark is able to provide powerful distributed data processing, while keeping the system fairly simple to understand and operate.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Coarse-grained 와 Fine-grained 는 원래 곡식을 낟알로 만들 때 대충 작업하여 낟알을 거칠하는 것과 세심하게 하여 낟알을 부드럽게 하는 것을 의미한다. 소프트웨어 공학에서 Coarse-grained 와 Fine-grained 는 어떤 작업(Process, Wordload)의 분할 단위가 큰가 작은가를 구분하는 상대적인 의미로 사용된다.&lt;/p&gt;
&lt;p&gt;얼마나 세분화 되었는가? 모듈화 되었는가? 한국말로 표현하기가 좀 애매한데, 여튼 어느 정도 grain 되었는지를 나타내는 것을 granularity 라고 한다. 이 &lt;a href="https://en.wikipedia.org/wiki/Granularity"&gt;Granularity&lt;/a&gt;에 대한 위키피디아 페이지에 다음과 같은 언급이 있다.:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Coarse-grained materials or systems have fewer, larger discrete components than fine-grained materials or systems.&lt;/p&gt;
&lt;p&gt;The concepts granularity, coarseness, and fineness are relative, used when comparing systems or descriptions of systems.&lt;/p&gt;
&lt;/blockquote&gt;</content><category term="granularity"></category><category term="coarse-grained"></category><category term="fine-grained"></category><category term="programming"></category></entry><entry><title>Function, Method, Procedure</title><link href="https://imjang57.github.io/garret/function-and-method.html" rel="alternate"></link><published>2017-01-03T00:00:00+09:00</published><updated>2017-01-03T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-03:/garret/function-and-method.html</id><summary type="html">&lt;p&gt;Function, Method, Procedure 의 차이점&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Function, Method, Procedure&lt;/h1&gt;
&lt;p&gt;보통 function 과 method 를 구분 없이 사용한다. 하지만 이들은 엄연히 다른 개념이다. 서브루틴, 함수, 메서드, 프로시저 모두 비슷하지만 각자 의미가 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Sub-routine : A sub-routne is A repeatable piece of procedural code you can call by name.&lt;/li&gt;
&lt;li&gt;Function : A function is a sub-routine that returns one or more values. A function should calculate its return value based on its input.&lt;/li&gt;
&lt;li&gt;Procedure : A procedure is a sub-routine that doesn not return a value, but does have side-effects. (such as writing to a file, printing to the screen, or modifying the value of its input)&lt;/li&gt;
&lt;li&gt;Method : A method is a function or procedure that is executed in the context of an object. A Method calculates a new value or trigger side-effect based on the values of its inputs and/or the scope of the object instance&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;보통 개발자들은 이들 단어에 대해 별 다른 구분없이 비슷한 의미로 사용한다. 하지만 Programming Language Theory 에서는 확실히 다르다.&lt;/p&gt;
&lt;p&gt;이런 단어들의 의미를 무시해도 상관없을까? 사실 대부분의 경우 무시해도 큰 상관은 없다고 생각된다. 하지만 어떤 로직을 모듈화하여 서브루틴으로 만들 때 이것들을 고려하면 더 좋다고 생각한다. 이 서브루틴은 어떤 타입의 서브루틴으로 구현해야 하는지 고민하면 그 서브루틴의 역할이나 목적을 더 명확해질 것이다. 서브루틴의 역할이나 목적이 명확해지면, 하나의 서브루틴이 과도하게 많은 역할을 하게 되는 현상을 방지할 수 있을 것이다. 프로그래밍에서 중요한 중복 제거, 모듈화에 대한 자연스러운 의식의 흐름이 생기게 되고 결과적으로 코드가 단순하지고 관리하기 좋아질 것이다. 어쨌든 좋은 함수를 만들기 위한 고민은 항상 필요하다고 생각한다.&lt;/p&gt;
&lt;p&gt;물론, 실제 개발할 때 시간에 쫓겨 항상 이런 고민을 하지 못한다..ㅠㅠ.. 그래도 항상 고민하려고 노력하자. 개발은 사람이 하는 일이라 의식의 흐름에 영향을 받으니, 의식의 흐름을 항상 올바로 하려고 노력하자.&lt;/p&gt;</content><category term="function"></category><category term="method"></category><category term="procedure"></category><category term="sub-routine"></category><category term="programming"></category></entry><entry><title>Parameter and Argument</title><link href="https://imjang57.github.io/garret/parameter-and-argument.html" rel="alternate"></link><published>2017-01-03T00:00:00+09:00</published><updated>2017-01-03T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-03:/garret/parameter-and-argument.html</id><summary type="html">&lt;p&gt;Parameter 와 Argument 의 정확한 의미&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Parameter and Argument&lt;/h1&gt;
&lt;p&gt;많은 개발자들이 Parameter 와 Argument 를 딱히 구분하지 않고 사용한다. 그런데 이 둘은 엄연히 다르며, 그러다 보니 논쟁하다보면 맥락이 어긋나는 경우가 발생한다.&lt;/p&gt;
&lt;p&gt;K&amp;amp;R 의 C Programming Language Second Edition 에 다음과 같이 언급한다.&lt;/p&gt;
&lt;p&gt;We well generally use parameter for a variable named in the parenthesized list in a function definition, and argument for the value used in a call of the function.&lt;/p&gt;
&lt;p&gt;즉, Parameter(파라미터, 매개변수)는 함수 선언에서 사용되는 변수의 이름을 뜻하며, Argument(인자, 전달인자)는 함수를 호출할 때 전달되는 값을 의미한다.&lt;/p&gt;</content><category term="parameter"></category><category term="argument"></category><category term="programming"></category></entry><entry><title>SSH with key</title><link href="https://imjang57.github.io/garret/ssh-with-key.html" rel="alternate"></link><published>2017-01-02T00:00:00+09:00</published><updated>2017-01-02T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-02:/garret/ssh-with-key.html</id><summary type="html">&lt;p&gt;Key 로 SSH 로그인 하기 위한 과정&lt;/p&gt;</summary><content type="html">&lt;h1&gt;SSH with key file&lt;/h1&gt;
&lt;p&gt;SSH 를 사용할 때 비밀번호를 일일이 입력하기 귀찮을 때가 있다. 특히 개발용 서버에 수시로 접속할 때.. 이 때 key 파일을 이용한 로그인을 하면 비밀번호를 입력하는 번거로움을 피할 수 있다.&lt;/p&gt;
&lt;p&gt;SSH 에서 key 를 이용한 로그인을 위해 RSA asymmetric encryption (RSA 비대칭키 암호화) 방식을 이용할 수 있다. 이 방법은 아래와 같은 절차를 따라 동작한다. (물론 당연히 다른 암호화 방식의 Key 를 사용해도 된다.)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Public Key (공개키) 와 Private Key (비공개키) 를 생성&lt;/li&gt;
&lt;li&gt;Local Host (SSH Client) 에 Private Key 저장&lt;/li&gt;
&lt;li&gt;Remote Host (SSH Server) 에 Public Key 등록&lt;/li&gt;
&lt;li&gt;Local Host 가 Remote  Host 에 접속 요청을 하면서 Public Key 전달&lt;/li&gt;
&lt;li&gt;Remote Host 는 Public Key 를 받아서 등록된 Public Key 인지 검사한 후 승인 또는 비승인&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Key 생성&lt;/h2&gt;
&lt;p&gt;먼저 Public Key 와 Private Key 를 생성한다. 리눅스에서는 아래와 같은 명령을 실행하면 된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ ssh-keygen -t rsa
Generating public/private rsa key pair.
Enter file in which to save the key &lt;span class="o"&gt;(&lt;/span&gt;/home/axl/.ssh/id_rsa&lt;span class="o"&gt;)&lt;/span&gt;: &amp;lt;&lt;span class="k"&gt;return&lt;/span&gt;&amp;gt;
Enter passphrase &lt;span class="o"&gt;(&lt;/span&gt;empty &lt;span class="k"&gt;for&lt;/span&gt; no passphrase&lt;span class="o"&gt;)&lt;/span&gt;: &amp;lt;Type the passphrase&amp;gt;
Enter same passphrase again: &amp;lt;Type the passphrase&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;ssh-keygen&lt;/code&gt; 을 실행하면 key file 이 저장될 위치와 passphrase 를 차례대로 묻는다. 저장될 위치는 기본값으로 &lt;code&gt;$HOME/.ssh&lt;/code&gt; 이다. 특별히 변경할 일이 없다면 그대로 엔터를 입력하여 기본값으로 사용하자. passphrase 는 비공개키를 생성하는데 사용될 문자열로 이 문자열을 암호화하여 키를 생성한다. 자동 로그인을 원한다면 생략해야 한다.&lt;/p&gt;
&lt;p&gt;키가 정상적으로 생성되면 키가 생성된 곳에 아래와 같은 파일들을 볼 수 있다. 참고로 파일들은 SSH 를 사용할 때 보안에 매우 중요한 파일들이다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;drwx------  &lt;span class="m"&gt;2&lt;/span&gt; ubuntu ubuntu &lt;span class="m"&gt;4096&lt;/span&gt; Feb &lt;span class="m"&gt;18&lt;/span&gt; 18:54 .
drwxr-xr-x &lt;span class="m"&gt;16&lt;/span&gt; ubuntu ubuntu &lt;span class="m"&gt;4096&lt;/span&gt; Mar  &lt;span class="m"&gt;1&lt;/span&gt; 06:02 ..
-rw-rw-r--  &lt;span class="m"&gt;1&lt;/span&gt; ubuntu ubuntu  &lt;span class="m"&gt;790&lt;/span&gt; Feb &lt;span class="m"&gt;19&lt;/span&gt; 06:04 authorized_keys
-rw-------  &lt;span class="m"&gt;1&lt;/span&gt; ubuntu ubuntu &lt;span class="m"&gt;1675&lt;/span&gt; Feb &lt;span class="m"&gt;18&lt;/span&gt; 18:51 id_rsa
-rw-r--r--  &lt;span class="m"&gt;1&lt;/span&gt; ubuntu ubuntu  &lt;span class="m"&gt;395&lt;/span&gt; Feb &lt;span class="m"&gt;18&lt;/span&gt; 18:51 id_rsa.pub
-rw-r--r--  &lt;span class="m"&gt;1&lt;/span&gt; ubuntu ubuntu &lt;span class="m"&gt;2216&lt;/span&gt; Feb &lt;span class="m"&gt;19&lt;/span&gt; 18:34 known_hosts
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;authorized_keys&lt;/code&gt; 파일은 없을수도 있다. &lt;code&gt;id_rsa&lt;/code&gt; 파일은 private key 이다. 매우 중요하므로 절대로 타인에게 노출되면 안된다. &lt;code&gt;id_rsa.pub&lt;/code&gt; 파일은 public key 이다. 접속하려는 Remote Host 의 &lt;code&gt;authorized_keys&lt;/code&gt; 에 입력한다. &lt;code&gt;authorized_keys&lt;/code&gt; 파일은 Remote Host 의 &lt;code&gt;.ssh&lt;/code&gt; 디렉토리 아래에 위치하면서 &lt;code&gt;id_rsa.pub&lt;/code&gt; 키의 값을 저장한다.&lt;/p&gt;
&lt;h2&gt;Remote Host 에 Public Key 등록&lt;/h2&gt;
&lt;p&gt;이제 &lt;code&gt;id_rsa.pub&lt;/code&gt; 파일을 리모트 서버의 &lt;code&gt;$HOME/.ssh/authorized_keys&lt;/code&gt; 파일에 추가해줘야 한다. SSH Server의 &lt;code&gt;authorized_keys&lt;/code&gt; 의 내용이 SSH Client의 &lt;code&gt;id_rsa.pub&lt;/code&gt; 파일과 같아야 한다.&lt;/p&gt;
&lt;p&gt;아래와 같이 SCP (Secure Copy) 를 이용하여 Public Key 를 Remote Host 에 복사한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;scp &lt;span class="nv"&gt;$HOME&lt;/span&gt;/.ssh/id_rsa.pub root@server.net:id_rsa.pub
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;그리고 Public Key 를 Remote Host 의 authorized_keys 에 추가한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;cat &lt;span class="nv"&gt;$HOME&lt;/span&gt;/id_rsa.pub &amp;gt;&amp;gt; &lt;span class="nv"&gt;$HOME&lt;/span&gt;/.ssh/authorized_keys
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;SSH 접속&lt;/h2&gt;
&lt;p&gt;이후에는 비밀번호 없이 바로 SSH 접속이 가능하다.&lt;/p&gt;
&lt;p&gt;만약 Private Key 를 다른 곳에 저장했다면 아래와 같이 &lt;code&gt;-i&lt;/code&gt; 옵션을 사용하여 키를 지정할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ ssh root@server.net -i keyfile
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Remote Host 의 SSHD 설정&lt;/h2&gt;
&lt;p&gt;Key 를 이용한 SSH 로그인을 사용하기 위해서는 Remote Host 의 SSHD 설정에서 RSA 키 인증을 사용하도록 설정해야 한다. 아래와 같은 내용이 있는지 SSHD 설정 파일 (&lt;code&gt;/etc/ssh/sshd_config&lt;/code&gt;) 을 확인한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;RSAAuthentication yes
#DSAAuthentication yes
PubkeyAuthentication yes
AuthorizedKeysFile .ssh/authorized_keys
&lt;/pre&gt;&lt;/div&gt;</content><category term="linux"></category><category term="ssh"></category><category term="key-gen"></category></entry><entry><title>SSH Brute force 막기</title><link href="https://imjang57.github.io/garret/defence-ssh-brute-force.html" rel="alternate"></link><published>2017-01-01T00:00:00+09:00</published><updated>2017-01-01T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-01:/garret/defence-ssh-brute-force.html</id><summary type="html">&lt;p&gt;SSH Brute force 공격 시도를 막는 설정&lt;/p&gt;</summary><content type="html">&lt;h1&gt;ssh brute force 막기&lt;/h1&gt;
&lt;p&gt;AWS EC2 를 사용하고 있었는데 갑자기 인스턴스가 엄청나게 느려졌다. 확인해보니 SSH 연결 시도가 엄청나게 쌓이고 있었다. 인터넷에서 Source 주소를 입력해서 찾아보니 중국이라고 나오는데 그거는 뭐 알 수 없는 거고.. 어쨌든 Security Group 을 22번 포트에 대해 그냥 다 열어놨더니 이런 일이 발생했나보다. 그래도 진짜 공격 받아보긴 처음이네 ㅎㅎ..&lt;/p&gt;
&lt;p&gt;어쨌뜬 그래서 이 글에 brute force 방식으로 SSH 비밀번호를 해킹하려는 시도를 차단하기 위한 설정을 남긴다. (물론 AWS 인스턴스는 Security Group 을 내 주소로만 SSH 허용하도록 바꿔서 문제없지만 나중에 필요하게 될지 모르니....)&lt;/p&gt;
&lt;p&gt;brute force 공격이 들어오면 매번 로그인 시도때마다 SSH 서버의 Resource 가 소모되기 때문에 보안성이 좋은 비밀번호나 키를 사용하더라도 이를 방지해주는 것이 좋다.&lt;/p&gt;
&lt;p&gt;ssh port 로 20초간 5회 이상 접속을 시도하면 10분간 접속을 차단하는 iptables rule 을 만들어 보자.&lt;/p&gt;
&lt;p&gt;blacklist 와 ssh chain 생성:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# iptables -N blacklist
# iptables -N ssh
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;INPUT chain 에서 state module 로 ssh port 에 접속이 시작되면 ssh chain 으로 보낸다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# iptables -A INPUT -m state --state NEW -p tcp --dport ssh -j ssh
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;blacklist chain 에서는 recent module 로 "blacklist" 라는 목록에 접속 주소를 기록하고 접속을 거부한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# iptables -A blacklist -m recent --set --name blacklist
# iptables -A blacklist -j REJECT
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;ssh chain 은 다음과 같다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# iptables -A ssh -m recent --update --seconds 600 --hitcount 1 --name blacklist -j REJECT
# iptables -A ssh -m recent --set --name ssh
# iptables -A ssh -m recent --update --seconds 20 --hitcount 5 --name ssh -j blacklist
# iptables -A ssh -j ACCEPT
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;이 ssh chain 은 다음과 같이 동작한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;접속 주소가 이미 blacklist 에 들어 있고 지난 10분간 1회 이상 접속이 있었으면 접속을 거부한다.&lt;/li&gt;
&lt;li&gt;접속 주소를 "ssh" 목록이 기록한다.&lt;/li&gt;
&lt;li&gt;접속 주소가 이미 "ssh" 목록에 있으면, 지난 20초간 5회 이상 접속이 있었으면 blacklist chain 으로 보낸다.&lt;/li&gt;
&lt;li&gt;위의 3개가 다 통과하면 ssh 접속을 허락한다.&lt;/li&gt;
&lt;/ol&gt;</content><category term="ssh"></category><category term="iptables"></category><category term="brute force"></category></entry><entry><title>iptables</title><link href="https://imjang57.github.io/garret/iptables.html" rel="alternate"></link><published>2017-01-01T00:00:00+09:00</published><updated>2017-01-01T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-01:/garret/iptables.html</id><summary type="html">&lt;p&gt;iptables 사용법&lt;/p&gt;</summary><content type="html">&lt;h1&gt;iptables&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;iptables&lt;/em&gt; 는 리눅스에서 네트웍 방화벽으로 사용되는 도구이다. Source, Destination, Protocol, State 등으로 다양한 조건을 설정할 수 있다. 리눅스 호스트에서 제공되는 가장 기초적인 방화벽 도구이며, C언어로 작성된 packet filtering framework 인 &lt;a href="https://www.netfilter.org"&gt;netfilter&lt;/a&gt; 를 기반으로 동작한다. 사실은 iptables 가 netfilter 의 하위 프로젝트라고 볼 수도 있다. 보통 &lt;em&gt;netfilter/iptables&lt;/em&gt; 와 같이 함께 언급되기도 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.netfilter.org"&gt;netfilter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.netfilter.org/projects/iptables/index.html"&gt;iptables&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://git.netfilter.org/"&gt;netfilter git repository&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://git.netfilter.org/iptables/"&gt;iptables git repository&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;대부분의 리눅스 배포판에서 &lt;em&gt;iptables&lt;/em&gt; 는 기본적으로 제공된다. &lt;code&gt;iptables&lt;/code&gt; 명령으로 방화벽 정책 관련 작업을 수행할 수 있고 &lt;em&gt;iptables-service&lt;/em&gt; 패키지를 설치하면 Daemon 형태로 관리가 가능하다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;iptables&lt;/em&gt; 에서 사용되는 정책(Rule)을 저장하기 위한 파일의 위치는 &lt;code&gt;/etc/sysconfig/iptables&lt;/code&gt; 이다.&lt;/p&gt;
&lt;p&gt;참고로, CentOS 7 부터는 &lt;em&gt;iptables&lt;/em&gt; 대신 &lt;a href="http://www.firewalld.org"&gt;firewalld&lt;/a&gt; 가 사용된다. 클라우드 환경에서의 조금 더 유연한 방화벽 관리를 위해 python 으로 만든 도구인데, 내부적으로는 &lt;em&gt;netfilter/iptables&lt;/em&gt; 를 사용한 front-end for the iptables 이다. 사용자 입장에서는 그저 명령어를 &lt;code&gt;iptables&lt;/code&gt; 대신에 &lt;code&gt;firewall-cmd&lt;/code&gt; 나 &lt;code&gt;firewall-config&lt;/code&gt; 를 사용하게 된 것이다. CentOS 7 에는 &lt;em&gt;iptables&lt;/em&gt; 자체는 있지만 &lt;em&gt;iptables-service&lt;/em&gt; 가 없어서 &lt;em&gt;firewalld&lt;/em&gt; 로 방화벽을 관리하도록 하는데, 사실 &lt;em&gt;filrewalld&lt;/em&gt; 를 끄고, &lt;em&gt;iptables-service&lt;/em&gt; 를 설치한 후 사용할 수도 있다(인터넷에 찾으면 많이 나온다). 하지만 이왕 바뀐거 나중에 다시 롤백되지 않을 가능성이 크니 익숙해지는게 좋을 테고 익숙해지면 &lt;em&gt;Redhat&lt;/em&gt; 이 &lt;em&gt;firewalld&lt;/em&gt; 를 선택한 이유도 알게 될 지도.. 어쨌든 이 글에선 &lt;em&gt;firewalld&lt;/em&gt; 에 대해선 다루지 않는다.&lt;/p&gt;
&lt;p&gt;만약 iptables 가 설치되어 있지 않다면 아래와 같이 설치하자.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ yum install iptables iptables-service
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;tables&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;iptables&lt;/em&gt; 는 4개의 &lt;em&gt;table&lt;/em&gt; 을 관리한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;filter&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;nat&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;mangle&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;raw&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;보통 사용하는 &lt;em&gt;table&lt;/em&gt; 은 &lt;em&gt;filter&lt;/em&gt; 이다.&lt;/p&gt;
&lt;h2&gt;chain&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;filter table&lt;/em&gt; 에는 &lt;em&gt;INPUT&lt;/em&gt;, &lt;em&gt;OUTPUT&lt;/em&gt;, &lt;em&gt;FORWARD&lt;/em&gt; 3개의 &lt;em&gt;chain&lt;/em&gt; 이 있다. 각 &lt;em&gt;chain&lt;/em&gt; 들은 Network Traffic (IP Packet) 에 대하여 정해진 규칙들을 수행한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;INPUT&lt;/em&gt; : Host 를 향해 들어오는 Packet&lt;/li&gt;
&lt;li&gt;&lt;em&gt;OUTPUT&lt;/em&gt; : Host 에서 나가는 Packet&lt;/li&gt;
&lt;li&gt;&lt;em&gt;FORWARD&lt;/em&gt; : Host 가 Destination 이 아닌 Packet&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;INPUT chain&lt;/em&gt; 에 해당하는 Packet 을 허용(&lt;em&gt;ACCEPT&lt;/em&gt;), 거부(&lt;em&gt;REJECT&lt;/em&gt;), 또는 드랍(&lt;em&gt;DROP&lt;/em&gt;) 할 지 결정할 수 있다.&lt;/p&gt;
&lt;h2&gt;match&lt;/h2&gt;
&lt;p&gt;어떤 Packet 에 규칙을 적용할지 판단하기 위한 조건이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--source&lt;/code&gt; (&lt;code&gt;-s&lt;/code&gt;) : Source IP address 또는 Network&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--destination&lt;/code&gt; (&lt;code&gt;-d&lt;/code&gt;) : Destination address 또는 Network&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--protocol&lt;/code&gt; (&lt;code&gt;-p&lt;/code&gt;) : Protocol&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--in-interface&lt;/code&gt; (&lt;code&gt;-i&lt;/code&gt;) : 입력 interface&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--out-interface&lt;/code&gt; (&lt;code&gt;-o&lt;/code&gt;) : 출력 interface&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--state&lt;/code&gt; : 연결 상태&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--string&lt;/code&gt; : Application Layer Data 의 Byte 순서&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--comment&lt;/code&gt; : Kernel memory 내의 규칙과 연계되는 최대 256 bytes 주석&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--syn&lt;/code&gt; (&lt;code&gt;-y&lt;/code&gt;) : SYN Packet 을 허용하지 않음&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--fragment&lt;/code&gt; (&lt;code&gt;-f&lt;/code&gt;) : 두 번째 이후의 조각에 대해서 규칙을 명시&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--table&lt;/code&gt; (&lt;code&gt;-t&lt;/code&gt;) : 처리될 table&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--jump&lt;/code&gt; (&lt;code&gt;-j&lt;/code&gt;) : 규칙에 맞는 Packet 을 어떻게 처리할 것인가를 명시&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--match&lt;/code&gt; (&lt;code&gt;-m&lt;/code&gt;) : 특정 module 과의 매치&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;target&lt;/h2&gt;
&lt;p&gt;Packet 에 적용하려는 동작이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;ACCEPT&lt;/em&gt; : Packet 을 받아들인다.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;DROP&lt;/em&gt; : Packet 을 버린다. Packet 을 송신한 쪽은 아무런 응답도 받지 못한다.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;REJECT&lt;/em&gt; : Packet 을 버리고 이와 동시에 적절한 응답 패킷(connection refused)을 전송한다.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;LOG&lt;/em&gt; : Packet 을 syslog에 기록한다.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;RETURN&lt;/em&gt; : 호출 체인 내에서 Packet 처리를 계속한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;연결 추적(Connection Tracking)&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;iptables&lt;/em&gt; 는 연결 추적(connection tracking)이라는 방법을 사용하여 내부 Network 상 서비스 연결 상태에 따라서 그 연결을 감시하고 제한할 수 있게 해준다. 연결 추적 방식은 연결 상태를 표에 저장하기 때문에, 다음과 같은 연결 상태에 따라서 시스템 관리자가 연결을 허용하거나 거부할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;NEW&lt;/em&gt; : 새로운 Connection 을 요청하는 Packet, (예: &lt;em&gt;HTTP&lt;/em&gt; 요청)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;ESTABLISHED&lt;/em&gt; : 기존 Connection 의 일부인 Packet&lt;/li&gt;
&lt;li&gt;&lt;em&gt;RELATED&lt;/em&gt; : 기존 Connection 에 속하지만 새로운 Connection 을 요청하는 Packet, 예를 들면 접속 port 가 20인 수동 FTP의 경우 전송 포트는 사용되지 않은 1024 이상의 어느 port 라도 사용 가능하다.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;INVALID&lt;/em&gt; : 연결 추적표에서 어디 Connection 에도 속하지 않은 Packet&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;상태에 기반(stateful)한 &lt;em&gt;iptables&lt;/em&gt; 연결 추적 기능은 어느 Network Protocol 에서나 사용 가능하다. &lt;em&gt;UDP&lt;/em&gt; 와 같이 상태를 저장하지 않는 (stateless) Protocol 에서도 사용할 수 있다.&lt;/p&gt;
&lt;h2&gt;명령어(commond)&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;iptables&lt;/em&gt; 에서 사용 가능한 명령들의 목록:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-A&lt;/code&gt; (&lt;code&gt;--append&lt;/code&gt;) : 새로운 규칙을 추가한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-D&lt;/code&gt; (&lt;code&gt;--delete&lt;/code&gt;) : 규칙을 삭제한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-C&lt;/code&gt; (&lt;code&gt;--check&lt;/code&gt;) : 패킷을 테스트한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-R&lt;/code&gt; (&lt;code&gt;--replace&lt;/code&gt;) : 새로운 규칙으로 교체한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-I&lt;/code&gt; (&lt;code&gt;--insert&lt;/code&gt;) : 새로운 규칙을 삽입한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-L&lt;/code&gt; (&lt;code&gt;--list&lt;/code&gt;) : 규칙을 출력한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-F&lt;/code&gt; (&lt;code&gt;--flush&lt;/code&gt;) : &lt;em&gt;chain&lt;/em&gt; 으로부터 규칙을 모두 삭제한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-Z&lt;/code&gt; (&lt;code&gt;--zero&lt;/code&gt;) : 모든 &lt;em&gt;chain&lt;/em&gt; 의 패킷과 바이트 카운터 값을 0으로 만든다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-N&lt;/code&gt; (&lt;code&gt;--new&lt;/code&gt;) : 새로운 &lt;em&gt;chain&lt;/em&gt; 을 만든다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-X&lt;/code&gt; (&lt;code&gt;--delete-chain&lt;/code&gt;) : &lt;em&gt;chain&lt;/em&gt; 을 삭제한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-P&lt;/code&gt; (&lt;code&gt;--policy&lt;/code&gt;) : 기본정책을 변경한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;추가로 &lt;code&gt;-L&lt;/code&gt; 옵션 이용시 &lt;code&gt;-n&lt;/code&gt; (&lt;code&gt;--numeric&lt;/code&gt;) 옵션을 추가하면 address 와 port 를 더 편하게 볼 수 있다. (&lt;code&gt;iptables -nL&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;내용을 확인할 때 &lt;code&gt;--line-numbers&lt;/code&gt; 를 추가하면 각 Ruleset 들의 순서도 같이 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-v&lt;/code&gt; (&lt;code&gt;--verbose&lt;/code&gt;) 옵션을 사용하면 더 다양한 정보를 볼 수 있다.&lt;/p&gt;
&lt;p&gt;추가 사용법은 &lt;code&gt;-h&lt;/code&gt; (&lt;code&gt;--help&lt;/code&gt;) 를 확인하자.&lt;/p&gt;
&lt;h2&gt;기본 동작&lt;/h2&gt;
&lt;p&gt;다음은 &lt;em&gt;iptables&lt;/em&gt; 의 기본 동작 과정이다.&lt;/p&gt;
&lt;p&gt;패킷에 대한 동작은 위에서 부터 차례로 각 규칙에 대해 검사하고, 그 규칙과 일치하는 패킷에 대하여 타겟에 지정한 &lt;em&gt;ACCEPT&lt;/em&gt;, &lt;em&gt;DROP&lt;/em&gt; 등을 수행한다.&lt;/p&gt;
&lt;p&gt;규칙이 일치하고 작업이 수행되면, 그 패킷은 해당 규칙의 결과에 따리 처리하고 체인에서 추가 규칙을 무시한다.&lt;/p&gt;
&lt;p&gt;패킷이 체인의 모든 규칙과 매치하지 않아 규칙의 바닥에 도달하면 정해진 기본정책(policy)이 수행된다.&lt;/p&gt;
&lt;p&gt;기본 정책은 policy &lt;em&gt;ACCEPT&lt;/em&gt;, policy &lt;em&gt;DROP&lt;/em&gt; 으로 설정할 수 있다.&lt;/p&gt;
&lt;p&gt;일반적으로 기본정책은 모든 패킷에 대해 &lt;em&gt;DROP&lt;/em&gt; 을 설정하고 특별히 지정된 포트와 IP주소등에 대해 &lt;em&gt;ACCEPT&lt;/em&gt; 를 수행하게 만든다.&lt;/p&gt;
&lt;h1&gt;iptables 사용하기&lt;/h1&gt;
&lt;p&gt;iptables 적용 예:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;iptables -P INPUT ACCEPT&lt;/code&gt; : &lt;em&gt;INPUT Chain&lt;/em&gt; 의 기본 정책을 &lt;em&gt;ACCEPT&lt;/em&gt; 로 설정&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iptables -P INPUT DROP&lt;/code&gt; : &lt;em&gt;INPUT Chain&lt;/em&gt; 의 기본정책을 &lt;em&gt;DROP&lt;/em&gt; 으로 설정&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iptables -F&lt;/code&gt; : &lt;em&gt;Chain&lt;/em&gt; 에 정의된 모든 규칙을 삭제&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iptables -nL&lt;/code&gt; : 현재 ruleset 설정 확인(address 와 port 는 숫자로 출력)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iptables -A INPUT -i lo -j ACCEPT&lt;/code&gt; : &lt;em&gt;INPUT Chain&lt;/em&gt; 에 localhost interface 인 Packet 은 모두 &lt;em&gt;ACCEPT&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iptables -A INPUT -m state — state ESTABLISHED,RELATED -j ACCEPT&lt;/code&gt; : &lt;em&gt;INPUT Chain&lt;/em&gt; 에 state module 의 state 가 &lt;em&gt;ESTABLISHED&lt;/em&gt;, &lt;em&gt;RELATED&lt;/em&gt; 인 Packet 에 대해 &lt;em&gt;ACCEPT&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iptables -A INPUT -p tcp -m tcp — dport 22 -j ACCEPT&lt;/code&gt; : &lt;em&gt;INPUT Chain&lt;/em&gt; 에 Protocol 의 &lt;em&gt;TCP&lt;/em&gt; 이며 destination port 가 22번인 Packet 에 대해 &lt;em&gt;ACCEPT&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;service iptables save&lt;/code&gt; 명령을 실행하면 &lt;code&gt;/etc/sysconfig/iptables&lt;/code&gt; 에 &lt;em&gt;iptables&lt;/em&gt; 현재 설정이 저장된다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;iptables&lt;/em&gt; 규칙을 만들 때는 순서가 매우 중요하다. 예를 들어 만일 &lt;em&gt;chain&lt;/em&gt; 에서 local network 인 192.168.100.0/24 subnetwork 에서 들어오는 모든 packet 을 &lt;em&gt;DROP&lt;/em&gt; 하도록 지정한 후 (&lt;em&gt;DROP&lt;/em&gt; 하도록 지정된 subnetwork 에 포함되는) 192.168.100.13 에서 들어오는 packet 을 모두 허용하는 &lt;em&gt;chain&lt;/em&gt; (&lt;code&gt;-A&lt;/code&gt;)을 그 후에 추가하면 뒤에 추가된 추가 규칙이 무시된다. 먼저 192.168.100.13 을 허용하는 규칙을 설정한 후 subnet 을 &lt;em&gt;DROP&lt;/em&gt; 하는 규칙을 설정해야한다.&lt;/p&gt;
&lt;p&gt;HTTP Web Server 를 용할 경우:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;iptables -A INPUT -p tcp -m tcp --dport 80 -j ACCEPT
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;HTTPS:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;iptables -A INPUT -p tcp -m tcp --dport 443 -j ACCEPT
-A INPUT -m state --state NEW -m tcp -p tcp -m multiport --dports 80,443 -j ACCEPT
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;MySQL (port 3306):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;iptables -A INPUT -p tcp --dport 3306 -j ACCEPT
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;FTP(passive mode):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;iptables -A INPUT -p tcp --dport 21 -j ACCEPT
iptables -A OUTPUT -p tcp --sport 21 -j ACCEPT
iptables -A INPUT -p tcp --dport 1024:65535 -j ACCEPT
iptables -A OUTPUT -p tcp --sport 1024:65535 -j ACCEPT
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;NTP 시간동기화:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;iptables -A INPUT -p udp --dport 123 -j ACCEPT
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;서버의 취약점을 차단하기 위한 iptables 설정 예&lt;/h1&gt;
&lt;p&gt;NULL 패킷 차단: &lt;code&gt;iptables -A INPUT -p tcp --tcp-flags ALL NONE -j DROP&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;NULL 패킷은 정찰 패킷으로 서버설정의 약한 곳을 찾기위한 방법으로 사용된다.&lt;/p&gt;
&lt;h1&gt;기타 사용법&lt;/h1&gt;
&lt;p&gt;기타 &lt;em&gt;iptables&lt;/em&gt; 사용법에 대해 알아보자.&lt;/p&gt;
&lt;h2&gt;iptables 수정&lt;/h2&gt;
&lt;p&gt;등록된 &lt;em&gt;iptables&lt;/em&gt; 를 수정하는 방법은 &lt;code&gt;/etc/sysconfig/iptables&lt;/code&gt; 에서 직접 vi로 수정하거나 &lt;code&gt;iptables&lt;/code&gt; 명령어를 사용한다.&lt;/p&gt;
&lt;p&gt;실행 순번을 확인하기: &lt;code&gt;iptables -nL --line-number&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;순번 3의 행을 수정(replace, &lt;code&gt;-R&lt;/code&gt;): &lt;code&gt;iptables -R INPUT 3 -p tcp --dport 2222 -j ACCEPT&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;인터페이스 지정&lt;/h2&gt;
&lt;p&gt;Network interface 를 지정하여 &lt;em&gt;iptables&lt;/em&gt; 를 적용할 수도 있다.&lt;/p&gt;
&lt;p&gt;루프백 인터페이스에 대해 모든 패킷을 허용: &lt;code&gt;iptables -A INPUT -i lo -j ACCEPT&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;랜카드 지정에 대해 모든 패킷을 허용: &lt;code&gt;iptables -A INPUT -i eth0 -j ACCEPT&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;IP 주소 지정&lt;/h2&gt;
&lt;p&gt;IP address 를 지정하여 iptables 를 적용할 수도 있다.&lt;/p&gt;
&lt;p&gt;신뢰할 만한 ip에 대해 모든 패킷을 허용: &lt;code&gt;iptables -A INPUT -s 192.168.0.3 -j ACCEPT&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;신뢰할 만한 ip 대역에 대해 모든 패킷을 허용: &lt;code&gt;iptables -A INPUT -s 192.168.0.0/24 -j ACCEPT&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;신뢰할 만한 ip 대역에 대해 모든 패킷을 허용: &lt;code&gt;iptables -A INPUT -s 192.168.0.0/255.255.255.0 -j ACCEPT&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;신뢰할 만한 ip와 MAC주소에 대해 모든 패킷을 허용: &lt;code&gt;iptables -A INPUT -s 192.168.0.3 -m mac — mac-source 00:50:80:FD:E6:32 -j ACCEPT&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;포트 범위지정: &lt;code&gt;iptables -A INPUT -p tcp --dport 6881:6890 -j ACCEPT&lt;/code&gt;&lt;/p&gt;
&lt;h1&gt;자동화 스크립트&lt;/h1&gt;
&lt;p&gt;자주 방화벽 설정을 초기화하고 재설정해야 한다면 자동화 스크립트를 짜놓는게 좋다. 아래는 그에 대한 예이다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/bin/bash&lt;/span&gt;
&lt;span class="c1"&gt;# iptables 설정 자동화 스크립트&lt;/span&gt;
&lt;span class="c1"&gt;# 입맛에 따라 수정해서 사용합시다.&lt;/span&gt;
iptables -F
&lt;span class="c1"&gt;# TCP 포트 22번을 SSH 접속을 위해 허용&lt;/span&gt;
&lt;span class="c1"&gt;# 원격 접속을 위해 먼저 설정합니다&lt;/span&gt;
iptables -A INPUT -p tcp -m tcp --dport &lt;span class="m"&gt;22&lt;/span&gt; -j ACCEPT
&lt;span class="c1"&gt;# 기본 정책을 설정합니다&lt;/span&gt;
iptables -P INPUT DROP
iptables -P FORWARD DROP
 iptables -P OUTPUT ACCEPT
&lt;span class="c1"&gt;# localhost 접속 허용&lt;/span&gt;
iptables -A INPUT -i lo -j ACCEPT
&lt;span class="c1"&gt;# established and related 접속을 허용&lt;/span&gt;
iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
&lt;span class="c1"&gt;# Apache 포트 80 허용&lt;/span&gt;
iptables -A INPUT -p tcp --dport &lt;span class="m"&gt;80&lt;/span&gt; -j ACCEPT
&lt;span class="c1"&gt;# 설정을 저장&lt;/span&gt;
/sbin/service iptables save
&lt;span class="c1"&gt;# 설정한 내용을 출력&lt;/span&gt;
iptables -L -v
위 내용을 입맛에 맞게 수정한 후에 저장&lt;span class="o"&gt;(&lt;/span&gt;myfirewall&lt;span class="o"&gt;)&lt;/span&gt;
권한부여: chmod +x myfirewall
실행: ./myfirewall
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;References&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;http://webdir.tistory.com/170&lt;/li&gt;
&lt;/ul&gt;</content><category term="iptables"></category></entry><entry><title>HomeBrew Install And Uninstall</title><link href="https://imjang57.github.io/garret/homebrew-install-and-uninstall.html" rel="alternate"></link><published>2016-12-31T00:00:00+09:00</published><updated>2016-12-31T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2016-12-31:/garret/homebrew-install-and-uninstall.html</id><summary type="html">&lt;p&gt;HomeBrew 를 설치하고 삭제하는 방법&lt;/p&gt;</summary><content type="html">&lt;h1&gt;HomeBrew&lt;/h1&gt;
&lt;p&gt;HomeBrew 는 OS X (이제는 MacOS) 에서 패키지 관리를 자동으로 해주는 도구이다. 이 글을 쓸 때는 최신 버전이 1.1.5 이다.&lt;/p&gt;
&lt;p&gt;HomeBrew 를 설치하려면 _Command Line Tools (CLT) for Xcode_가 필요하다. 귀찮으니 그냥 Xcode 설치하자. Xcode 에 다 포함되어 있다.&lt;/p&gt;
&lt;h2&gt;Install&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/Homebrew"&gt;Homebrew Github Project&lt;/a&gt;에 가면 &lt;a href="https://github.com/Homebrew/install"&gt;install repository&lt;/a&gt; 가 있다. 여기에 &lt;code&gt;install&lt;/code&gt; 과  &lt;code&gt;uninstall&lt;/code&gt; 이라는 스크립트를 제공해서 HomeBrew 를 설치하고 삭제할 수 있게 해준다.(Bash 는 아니고 Ruby 인 듯)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;install&lt;/code&gt; 스크립트로 설치하려면 아래와 같이 실행하면 된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;/usr/bin/ruby -e &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;위 스크립트로 설치하면 &lt;code&gt;/usr/local&lt;/code&gt; 에 HomeBrew 가 설치된다. 그런데 이 때 HomeBrew 를 위한 local git repository (&lt;code&gt;.git&lt;/code&gt; 디렉터리) 도 &lt;code&gt;/usr/local&lt;/code&gt; 에 생기고 다른 라이선스 관련 파일 등도 여기에 생성된다..-_-.. 이건 좀.. 그래서 uninstall 스크립트로 삭제하면 깨끗하게 지워지니까 일단 넘어가자. 이게 정 마음에 안들면 &lt;a href="https://github.com/Homebrew/brew/blob/master/docs/Installation.md#installation"&gt;installation guide&lt;/a&gt; 를 참고해서 직접 &lt;code&gt;git clone&lt;/code&gt; 해서 설치하자.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;install&lt;/code&gt; 스크립트로 실행하면 아래와 같이 설치되는 목록들을 보여준다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ /usr/bin/ruby -e &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="o"&gt;==&lt;/span&gt;&amp;gt; This script will install:
/usr/local/bin/brew
/usr/local/share/doc/homebrew
/usr/local/share/man/man1/brew.1
/usr/local/share/zsh/site-functions/_brew
/usr/local/etc/bash_completion.d/brew
/usr/local/Homebrew
&lt;span class="o"&gt;==&lt;/span&gt;&amp;gt; The following new directories will be created:
/usr/local/Cellar
/usr/local/Homebrew
/usr/local/Frameworks
/usr/local/include
/usr/local/opt
/usr/local/sbin
/usr/local/share/zsh
/usr/local/share/zsh/site-functions
/usr/local/var
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Uninstall&lt;/h2&gt;
&lt;p&gt;설치때와 마찬가지로 &lt;a href="https://github.com/Homebrew/install"&gt;install repository&lt;/a&gt;에서 제공하는 &lt;code&gt;uninstall&lt;/code&gt; 스크립트를 실행하면 된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ /usr/bin/ruby -e &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
Warning: This script will remove:
/Library/Caches/Homebrew/
/Users/youngho/Library/Logs/Homebrew/
/usr/local/.git/
/usr/local/.gitignore
/usr/local/.travis.yml
/usr/local/.yardopts
/usr/local/CODEOFCONDUCT.md
/usr/local/CONTRIBUTING.md
/usr/local/Cellar/
/usr/local/LICENSE.txt
/usr/local/Library/
/usr/local/README.md
/usr/local/SUPPORTERS.md
/usr/local/bin/brew
/usr/local/share/doc/homebrew/
/usr/local/share/man/man1/brew.1
Are you sure you want to uninstall Homebrew? &lt;span class="o"&gt;[&lt;/span&gt;y/N&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Usage&lt;/h1&gt;
&lt;p&gt;사용법은 매우 쉬우니 대충 적고 넘어간다.&lt;/p&gt;
&lt;p&gt;실행 명령어는 &lt;code&gt;brew&lt;/code&gt; 이다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ which brew
/usr/local/bin/brew
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;brew man page 에 더 자세한 내용이 많으니 참고하자.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ man &lt;span class="m"&gt;1&lt;/span&gt; brew
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;주로 사용하는 명령들의 목록:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;brew help&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;brew config&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;brew list [FORMULA...]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;brew info [FORMULA...]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;brew search &amp;lt;TEXT|/REGEX/&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;brew install FORMULA...&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;brew uninstall FORMULA...&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;brew upgrade [FORMULA...]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;HomeBrew 자체를 업그레이드하려면 &lt;code&gt;brew update&lt;/code&gt; 명령을 실행하면 되는데 지금은 잘 되는지 모르겠다. 0.9 버전일 사용할 때 &lt;em&gt;El Capitan&lt;/em&gt; 되면서 &lt;em&gt;System Integrity Protection&lt;/em&gt; 이라는 기능이 생겨서 제대로 안됐었는데, 맥 복구 모드(recovery mode)로 부팅해서 기능을 끄고 해서 해결했었던가 기억이 잘 안난다. 나중에 업데이트 할 일 생기면 다시 시도해보자.&lt;/p&gt;
&lt;h1&gt;References&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://brew.sh"&gt;HomeBrew Web&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Homebrew/brew"&gt;HomeBrew Github&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="mac"></category><category term="os x"></category><category term="homebrew"></category></entry><entry><title>Shell, Bash, Zsh</title><link href="https://imjang57.github.io/garret/introduction-shell-bash-zsh.html" rel="alternate"></link><published>2016-12-31T00:00:00+09:00</published><updated>2016-12-31T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2016-12-31:/garret/introduction-shell-bash-zsh.html</id><summary type="html">&lt;p&gt;내가 사용하는 Shell 에 대한 소개와 설치 과정&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Shell&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;Shell&lt;/em&gt; 은 &lt;em&gt;OS&lt;/em&gt; (&lt;em&gt;Operating System&lt;/em&gt;) 가 제공하는 여러 서비스들을 사용하기 위한 User interface 를 말한다. &lt;em&gt;CLI&lt;/em&gt; (&lt;em&gt;Command-line interface&lt;/em&gt;) 도 &lt;em&gt;Shell&lt;/em&gt; 이고 &lt;em&gt;GUI&lt;/em&gt; (&lt;em&gt;Graphical User Interface&lt;/em&gt;) 도 &lt;em&gt;Shell&lt;/em&gt; 이다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Linux&lt;/em&gt; 와 &lt;em&gt;OS X&lt;/em&gt; 에서는 보통 &lt;em&gt;Bash&lt;/em&gt; 가 Default shell 로 제공된다. 이 외에 &lt;em&gt;csh&lt;/em&gt;, &lt;em&gt;ksh&lt;/em&gt;, &lt;em&gt;zsh&lt;/em&gt; 등 많은 &lt;em&gt;Shell&lt;/em&gt; 들이 있다.&lt;/p&gt;
&lt;p&gt;요즘 가장 많이 사용되는 Linux 와 OS X  에서 Default shell 이고 수 많은 shell script 들이 &lt;em&gt;Bash&lt;/em&gt; 를 기반으로 작성되기 때문에 &lt;em&gt;Bash&lt;/em&gt; 는 필수이다. 여기에 나는 개인적으로 사용되는 환경에서는 &lt;em&gt;Zsh&lt;/em&gt; 을 추가로 설치해서 사용한다.&lt;/p&gt;
&lt;p&gt;이 &lt;em&gt;Shell&lt;/em&gt; 들은 마음에 드는 프롬프트를 만들고, 자주 사용하는 명령들을 alias 하고, 환경변수를 지정해서 사용하는 등 개인 취향에 따라 customizing 할 수 있다. 그래서 이 글에 내가 사용하는 Bash 설정과 Zsh 을 설치하고 설정하기 위한 과정들을 남긴다.&lt;/p&gt;
&lt;h2&gt;Shell 확인 및 변경&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Shell&lt;/em&gt; 확인은 다음과 같이 가능하다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;현재 내가 사용중인 Shell 확인 : &lt;code&gt;echo $SHELL&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;System 에서 사용가능한 Shell 목록 확인 : &lt;code&gt;cat /etc/shells&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;만약 내가 사용 중인 Shell 을 변경하고 싶다면 &lt;code&gt;chsh -s /path/to/other/shell&lt;/code&gt; 를 실행하면 된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ chsh -s /usr/local/bin/zsh
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Shell 의 실행 형태&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Shell&lt;/em&gt; 의 실행 형태는 &lt;em&gt;Interacctive shell&lt;/em&gt; 과 &lt;em&gt;Non-interactive shell&lt;/em&gt; 2가지가 있다. &lt;em&gt;Interactive shell&lt;/em&gt; 은 사용자가 명령을 입력하고 이를 실행하는 형태의 &lt;em&gt;Shell&lt;/em&gt; 이고 &lt;em&gt;Non-interactive shell&lt;/em&gt; 은 Script 를 실행할 때 사용되는 형태이다. 그리고 &lt;em&gt;Interactive shell&lt;/em&gt; 은 &lt;em&gt;Login shell&lt;/em&gt; 과 &lt;em&gt;Non-login Shell&lt;/em&gt; 이 있다. &lt;em&gt;Shell&lt;/em&gt; 은 실행 형태에 따라 사용자가 로그인할 때, 로그아웃할 때 각각 수행되는 스크립트들이 있다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Bash&lt;/em&gt; 의 경우를 예로 살펴보자. &lt;em&gt;Interactive Login Shell&lt;/em&gt; 일 경우 로그인할 때는 &lt;code&gt;/etc/profile&lt;/code&gt; 이 먼저 실행되고 &lt;code&gt;~/.bash_profile&lt;/code&gt;, &lt;code&gt;~/.bash_login&lt;/code&gt;, &lt;code&gt;~/.profile&lt;/code&gt; 들 중 처음 나오는 1개가 실행되다. 로그아웃할 때는 &lt;code&gt;~/.bash_logout&lt;/code&gt; 을 실행한다. &lt;em&gt;Interactive Non-login Shell&lt;/em&gt; 일 경우 &lt;code&gt;~/.bashrc&lt;/code&gt; 가 실행된다. &lt;em&gt;Non-interactive shell&lt;/em&gt; 은 $BASH_ENV (script 를 sh 로 실행한 경우는 $ENV) Environment variable 을 찾아서 이 변수에서 지정하는 파일 내의 명령들을 실행한다. 대부분의 경우 System-wide environment variables 는 &lt;code&gt;/etc/profile&lt;/code&gt; 에 설정하고, 각 사용자가 필요한 내용은 &lt;code&gt;~/.bash_profile&lt;/code&gt; 에서 설정한다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Zsh&lt;/em&gt; 은 &lt;code&gt;/etc/profile&lt;/code&gt; 대신 &lt;code&gt;/etc/zprofile&lt;/code&gt;, &lt;code&gt;~/.bash_profile&lt;/code&gt; 대신 &lt;code&gt;~/.zprofile&lt;/code&gt;, &lt;code&gt;~/.bashrc&lt;/code&gt; 대신 &lt;code&gt;~/.zshrc&lt;/code&gt; 를 사용한다.&lt;/p&gt;
&lt;h2&gt;Prompt&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Interactive Shell&lt;/em&gt; 이 실행된 경우 사용자의 입력을 기다리고 있음을 나타내기 위해 &lt;code&gt;&amp;lt;username@hostname&amp;gt;&lt;/code&gt; 과 같은 내용을 표시하는데 이를 Prompt 라고 한다. 이 프롬프트는 $PS1 환경 변수에 의해 설정된다. 만약 &lt;code&gt;export PS1="\$? &amp;gt; "&lt;/code&gt; 를 실행하면 프롬프트는 &lt;code&gt;0 &amp;gt;&lt;/code&gt; 와 같이 출력된다. 숫자 0은 이전 명령에 대한 리턴값이다.&lt;/p&gt;
&lt;p&gt;나는 bash prompt 를 다음과 같이 설정해서 사용한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# Colorize bash prompt using ANSI escape codes.&lt;/span&gt;
&lt;span class="c1"&gt;#     below print : username@hostname:cwd $&lt;/span&gt;
&lt;span class="nb"&gt;export&lt;/span&gt; &lt;span class="nv"&gt;PS1&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;\[\033[36m\]\u\[\033[m\]@\[\033[32m\]\h:\[\033[33;1m\]\w\[\033[m\]\$ &amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;alias&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;alias&lt;/code&gt; 명령을 사용하면 긴 명령이나 자주 사용하는 명령을 내가 원하는 명령으로 지정할 수 있다. &lt;code&gt;alias ll='ls -GFhil'&lt;/code&gt; 을 실행하면 이후부터 &lt;code&gt;ll&lt;/code&gt; 을 입력했을 때 &lt;code&gt;ls -GFhil&lt;/code&gt; 가 실행된다.&lt;/p&gt;
&lt;p&gt;내가 주로 사용하는 &lt;code&gt;alias&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;alias ll=&amp;#39;ls -GFhil&amp;#39;
alias lt=&amp;#39;ls -altr&amp;#39;
alias vi=&amp;#39;vim&amp;#39;
ssh=&amp;#39;ssh -o StrictHostKeyChecking=no -t&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Bash&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;Bash&lt;/em&gt; 는 최초의 &lt;em&gt;Shell&lt;/em&gt; 인 Bourne shell 을 다시 만든 &lt;em&gt;Shell&lt;/em&gt; 로 Bourne-again Shell 을 줄여서 &lt;em&gt;Bash&lt;/em&gt; 라고 한다. Linux 와 OS X 에는 Default shell 이며 다른 Unix 에서는 Csh 을 쓰는 듯 하다.&lt;/p&gt;
&lt;p&gt;요즘 대부분 개발자들이 사용하는 환경은 Linux, OS X, Windows 라서 &lt;em&gt;Bash&lt;/em&gt; 는 따로 설치해본 적이 없다. Linux 와 OS X 응 Default shell 이고 Windows 는 Bash 안쓰니까.. 그러니까 &lt;em&gt;Bash&lt;/em&gt; 에 대한 얘기는 넘어가자.&lt;/p&gt;
&lt;h1&gt;Zsh&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;Zsh&lt;/em&gt; 은 &lt;em&gt;Bash&lt;/em&gt; 의 확장판 같은 거라고 한다(그렇다고 함..). 사실 &lt;em&gt;Zsh&lt;/em&gt; 을 사용하는 이유는 &lt;em&gt;oh-my-zsh&lt;/em&gt; 때문이다. &lt;em&gt;Zsh&lt;/em&gt; 자체도 (자기들 주장에는) 좋다고 하는데 사실 나는 &lt;em&gt;Bash&lt;/em&gt; 와 비교해서 딱히 뛰어난 걸 잘 못느꼈다. 게다가 대부분의 Shell script 는 &lt;em&gt;Bash&lt;/em&gt; 를 기준으로 하기 때문에 &lt;em&gt;Zsh&lt;/em&gt; 이 아무리 &lt;em&gt;Bash&lt;/em&gt; 와 호환된다 해도 사용할 이유를 느끼지 못했었다. &lt;em&gt;oh-my-zsh&lt;/em&gt; 이 없었으면 아마 사용 안했을 듯 하다.&lt;/p&gt;
&lt;h2&gt;Zsh + oh-my-zsh 설치 및 설정&lt;/h2&gt;
&lt;p&gt;zsh 설치는 &lt;code&gt;yum install zsh&lt;/code&gt;, &lt;code&gt;apt-get install zsh&lt;/code&gt;, &lt;code&gt;brew install zsh&lt;/code&gt; 중 자기 OS 에 맞는 걸로 사용해서 설치하자. zsh 소스를 받아서 컴파일 하여 설치하는 것은 &lt;a href="http://www.zsh.org"&gt;Zsh Homepage&lt;/a&gt; 가서 알아보자.&lt;/p&gt;
&lt;p&gt;이제 oh-my-zsh 을 설치하자. &lt;a href="https://github.com/robbyrussell/oh-my-zsh"&gt;oh-my-zsh github&lt;/a&gt; 에 설명이 잘 나와있으니 자세한 내용은 가서 읽어보자. 나는 curl 을 이용해서 설치했다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ curl -L https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh &lt;span class="p"&gt;|&lt;/span&gt; sh
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;위 명령을 실행하면 git repository 가 ~/.oh-my-zsh 디렉터리에 clone 되고 설치 작업이 수행된다. 그리고 ~/.zshrc 파일이 자동으로 생성된다.&lt;/p&gt;
&lt;p&gt;설치는 이렇게 쉽게 끝났고, oh-my-zsh 은 다양한 theme plugin 을 지원하므로 내가 원하는 theme 를 적용해보자. 나는 &lt;a href="https://gist.github.com/agnoster/3712874"&gt;agnoster&lt;/a&gt; theme 가 마음에 들어서 아래와 같이 ~/.zshrc 파일을 변경하였다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ZSH_THEME=&amp;quot;agnoster&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;변경 후 &lt;code&gt;~/.zshrc&lt;/code&gt; 파일을 다시 적용하면 theme 가 적용된다. 만약 &lt;code&gt;ZSH_THEME="random"&lt;/code&gt; 으로 하면 여러 테마들이 로그인할 때마다 랜덤으로 적용된다.&lt;/p&gt;
&lt;p&gt;agnoster 테마는 Powerline font 를 필요로 한다. 이 폰트는 &lt;a href="https://github.com/powerline/fonts"&gt;Powerline github&lt;/a&gt; 에서 받을 수 있다. 이 저장소를 clone 한 후 &lt;code&gt;install.sh&lt;/code&gt; 파일을 실행하면 알아서 폰트를 설치해준다.&lt;/p&gt;
&lt;p&gt;OS X 의 경우 터미널 앱의 환경설정으로 가서 테마에서 서체를 새로 설치한 &lt;em&gt;Meslo LG M for Powerline&lt;/em&gt; 으로 바꿔주자.&lt;/p&gt;</content><category term="shell"></category><category term="bash"></category><category term="zsh"></category></entry><entry><title>특수 문자들의 영어 이름</title><link href="https://imjang57.github.io/garret/name-of-special-characters.html" rel="alternate"></link><published>2016-12-31T00:00:00+09:00</published><updated>2016-12-31T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2016-12-31:/garret/name-of-special-characters.html</id><summary type="html">&lt;p&gt;특수 문자들의 영어 이름&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Special characters name&lt;/h1&gt;
&lt;p&gt;개발자로 살면 다양한 특수문자들을 사용하게 되는데 구글링하거나 다른 사람과 대화할 때 이들의 이름이 기억안나 당황하는 경우가 많다. 그래서 이들의 영어 이름을 메모한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;#39; : single quotation mark, single quote
&amp;quot; : double quotation mark, double quote
* : asterisk, bullet
$ : dollar
- : dash, hyphen, minus sign
_ : underscore
% : percent sign
# : pound sign, number of, hashtag
&amp;amp; : ampersand
: : colon
; : semi-colon
| : vertical bar, pipe
\ : backslash
/ : slash, divide
&amp;lt; : less than sign
&amp;gt; : greater than sign
? : question mark
! : exclamation mark
() : parentheses, bracket
( : open parenthesss
) : close parenthesss
[] : square bracket
{} : curly bracket
+ : plus sign
= : equal sign
. : dot, period
, : comma
^ : caret, modifier letter, circumflex accent
` : grave accent, back tick, back quote
~ : tilde
@ : at symbol
&lt;/pre&gt;&lt;/div&gt;</content><category term="special characters"></category></entry><entry><title>System Integrity Protection (Rootless)</title><link href="https://imjang57.github.io/garret/system-integrity-protection-rootless.html" rel="alternate"></link><published>2016-12-31T00:00:00+09:00</published><updated>2016-12-31T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2016-12-31:/garret/system-integrity-protection-rootless.html</id><summary type="html">&lt;p&gt;Mac 의 Rootless 기능을 enable 및 disable 하기&lt;/p&gt;</summary><content type="html">&lt;h1&gt;System Integrity Protection (Rootless)&lt;/h1&gt;
&lt;p&gt;예전에 (2015년 인가..??) OS X 가 &lt;em&gt;El Capitan&lt;/em&gt; 으로 업데이트되면서 새롭게 생겨난 시스템 보안 관련 기능이다. &lt;em&gt;Rootless&lt;/em&gt; 라고도 하는 기능이다.&lt;/p&gt;
&lt;p&gt;보통 Linux/Unix 시스템은 root 사용자가 모든 파일을 읽고 쓸 수 있는데, 이 기능은 &lt;em&gt;Kernel&lt;/em&gt; 자체가 System file 들에 대한 쓰기 작업을 아예 막아 버리는 기능이다. 따라서, 이전에는 sudo 등으로 시스템 파일들을 수정할 수 있었지만 이제는 불가능하다.&lt;/p&gt;
&lt;p&gt;Rootless 에 의해 보호되는 파일 목록:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/System&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/bin&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/usr&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/sbin&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;sudo touch /bin/rootlesstest&lt;/code&gt; 를 실행하면 &lt;em&gt;Operation not permitted&lt;/em&gt; 메시지를 볼 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Rootless&lt;/em&gt; 에 의해 보호되는 파일 목록들은 &lt;code&gt;/System/Library/Sandbox/rootless.conf&lt;/code&gt; 에 모두 저장되어 있다.&lt;/p&gt;
&lt;p&gt;예전에 HomeBrew 때문에 Rootless 를 disable 한 적이 있었는데 이번에 또 필요해져서 다시 찾아봤다. 그리고 이왕 찾아본 김에 기록으로 남긴다.&lt;/p&gt;
&lt;h2&gt;Disable Rootless&lt;/h2&gt;
&lt;p&gt;현재 &lt;em&gt;Rootless&lt;/em&gt; 기능의 상태는 아래와 같이 확인할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ csrutil status
System Integrity Protection status: enabled.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;em&gt;Rootless&lt;/em&gt; 기능을 끄려면 &lt;em&gt;Recovery Mode&lt;/em&gt; 로 부팅해야 한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;맥 restart&lt;/li&gt;
&lt;li&gt;부팅시작되자마자 &lt;code&gt;option&lt;/code&gt; 키를 누른 후 &lt;code&gt;Recovery HD&lt;/code&gt; 를 선택하여 부팅한다. 아니면 &lt;code&gt;Command&lt;/code&gt; + &lt;code&gt;R&lt;/code&gt; 을 길게 누르면 파티션 선택 화면을 생략하고 바로 &lt;em&gt;Recovery Mode&lt;/em&gt; 로 부팅한다.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Recovery Mode&lt;/em&gt; 에서 상단 Menu bar 에서 유틸리티(Utilities)메뉴의 터미널(terminal)을 실행한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;csrutil disable [--without debug]&lt;/code&gt; 실행한다.&lt;/li&gt;
&lt;li&gt;restart 해서 일반 모드로 부팅한 후 필요한 작업 수행한다.&lt;/li&gt;
&lt;li&gt;필요한 작업 끝난 후 다시 재부팅하여 복구 모드로 들어온 뒤 &lt;code&gt;csrutil enable&lt;/code&gt; 을 실행한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;References&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.howtogeek.com/230424/how-to-disable-system-integrity-protection-on-a-mac-and-why-you-shouldnt/"&gt;How to Disable System Integrity Protection on a Mac (and Why You Shouldn’t)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="mac"></category><category term="os x"></category><category term="rootless"></category></entry><entry><title>TMUX Introduction</title><link href="https://imjang57.github.io/garret/tmux-introduction.html" rel="alternate"></link><published>2016-12-31T00:00:00+09:00</published><updated>2017-05-05T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2016-12-31:/garret/tmux-introduction.html</id><summary type="html">&lt;p&gt;TMUX 설치 및 사용법에 대한 간단한 소개&lt;/p&gt;</summary><content type="html">&lt;h1&gt;TMUX (Terminal Multiplexer)&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;tmux&lt;/em&gt; 는 terminal session 을 관리하기 위한 tool 이다. 여러 session 을 생성하여 서로 다른 workspace 를 만들 수 있고, session 을 유지시켜서 server 가 완전히 power off 되지않는다면 workspace 를 유지할 수도 있다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;tmux&lt;/em&gt; + &lt;em&gt;vim&lt;/em&gt; + &lt;em&gt;bash&lt;/em&gt; 는 매우 강력한 linux environment 를 제공한다.&lt;/p&gt;
&lt;h2&gt;설치&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;OS X: &lt;code&gt;brew install tmux&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Ubuntu: &lt;code&gt;apt-get install libevent-dev tmux&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;CentOS: &lt;code&gt;yum install libevent-dev tmux&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Linux 에서는 환경에 따라서 libncurses 모듈이 필요할 수 있다&lt;/p&gt;
&lt;h1&gt;tmux basic concepts&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;tmux&lt;/em&gt; 를 이용하기 전에 아래와 같은 개념에 대해 알고 가자.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;session&lt;/em&gt; : &lt;em&gt;tmux&lt;/em&gt; 실행 단위이다. 하나의 workspace 라고 생각할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;window&lt;/em&gt; : &lt;em&gt;session&lt;/em&gt; 내에 생성되는 하나의 terminal&lt;/li&gt;
&lt;li&gt;&lt;em&gt;pane&lt;/em&gt; : terminal 화면을 분할한 단위&lt;/li&gt;
&lt;li&gt;&lt;em&gt;status bar&lt;/em&gt; : 화면 아래부분에 표시되는 &lt;em&gt;session&lt;/em&gt; 의 status bar&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;99% 정도되는 대부분의 command 는 &lt;code&gt;ctrl + b&lt;/code&gt; 를 누른다음 이어서 command key 를 입력하여 실행된다. 예를 들어 command mode 로 직접 명령어를 입력하고 싶을 때는 &lt;code&gt;ctrl + b, :&lt;/code&gt; 와 같이 키를 입력한다. 정확하게는 &lt;code&gt;ctrl + b&lt;/code&gt; 를 누른 후 5초 내에 &lt;code&gt;:&lt;/code&gt; 를 입력한다. 5초 내에 command key 를 입력하면 된다.&lt;/p&gt;
&lt;h2&gt;Session&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;tmux&lt;/em&gt; 를 실행하면 &lt;em&gt;session&lt;/em&gt; 이라는 것이 생성된다. &lt;em&gt;session&lt;/em&gt; 은 실제 작업이 이루어지는 workspace 이며, &lt;em&gt;tmux&lt;/em&gt; 는 이 &lt;em&gt;session&lt;/em&gt; 을 관리하는 tool 이다.&lt;/p&gt;
&lt;h3&gt;create, rename, exit session&lt;/h3&gt;
&lt;p&gt;새로운 session 을 생성:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ tmux
$ tmux new-session -s &amp;lt;session name&amp;gt;
$ tmux new -s &amp;lt;session name&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;session name 을 직접 정하지 않았을 경우 숫자가 기본 session name 이 된다. 변경하고 싶으면 아래와 같은 command 를 입력한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ tmux rename-session -t &amp;lt;target session&amp;gt; &amp;lt;new session name&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;위의 명령에서 &lt;code&gt;tmux&lt;/code&gt; 를 제외한 부분(&lt;code&gt;rename-session&lt;/code&gt; 부터)을 &lt;em&gt;session&lt;/em&gt; 내에서 command mode(&lt;code&gt;ctrl + b, :&lt;/code&gt;) 에서 사용해도 된다.
또는 session 내에서 &lt;code&gt;ctrl + b, $&lt;/code&gt; 를 입력한다. 그러면 status bar 가 아래처럼 나타난다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(rename-session) 0
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;기존의 session name 인 0 을 삭제하고 새로운 session name 을 입력한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(rename-session) testsession
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;생성된 session 을 종료하고 싶으면 session 내에서 &lt;code&gt;exit&lt;/code&gt; 를 실행한다. 또는 &lt;code&gt;ctrl + d&lt;/code&gt; 를 입력한다.&lt;/p&gt;
&lt;p&gt;생성되어 있는 session 을 없애려면 다음을 실행한다:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ tmux kill-session -t &amp;lt;session name&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;attach and detach session&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;session&lt;/em&gt; 을 실행한 후 이를 유지하고 &lt;em&gt;session&lt;/em&gt; 밖으로 나갈 수도 있다. 서버만 내려가지 않는다면 이 &lt;em&gt;session&lt;/em&gt; 을 계속 유지시킬 수 있다. 이렇게 동작하는 것을 &lt;em&gt;session&lt;/em&gt; 을 detach 한다고 하는데 command mode 에서 &lt;code&gt;detach&lt;/code&gt; 를 입력하여 실행할 수 있다. 또는 &lt;code&gt;ctrl + b, d&lt;/code&gt; 를 입력해도 된다.&lt;/p&gt;
&lt;p&gt;이미 생성된 session 의 목록을 확인하려면 아래 명령을 실행한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ tmux list-sessions
testsession: &lt;span class="m"&gt;1&lt;/span&gt; windows &lt;span class="o"&gt;(&lt;/span&gt;created Thu Dec &lt;span class="m"&gt;22&lt;/span&gt; 09:31:45 2016&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;224x41&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;특정 session 에 다시 접속하려면 아래 명령을 실행한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ tmux attach-session -t testsession
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;위 명령을 아래 처럼 짧게 사용할 수도 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ tmux attach -t testsession
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Window&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;window&lt;/em&gt; 는 &lt;em&gt;session&lt;/em&gt; 내에서 나누어지는 공간이다. 일반적으로 인터넷 브라우저나 다른 어플리케이션에서 볼 수 있는 탭과 같은 것이다. &lt;em&gt;session&lt;/em&gt; 이라는 workspace 에 여러 &lt;em&gt;window&lt;/em&gt; 를 생성하여 한번에 여러가지 일들을 동시에 할 수 있게 된다.&lt;/p&gt;
&lt;h3&gt;create, rename, close window&lt;/h3&gt;
&lt;p&gt;최초에 &lt;em&gt;session&lt;/em&gt; 이 생성되면 무조건 1 개의 &lt;em&gt;window&lt;/em&gt; 가 생성된다. 최대 10개까지 생성할 수 있다. 화면 아래에 있는 status bar 에서 현재 &lt;em&gt;window&lt;/em&gt; 는 &lt;code&gt;*&lt;/code&gt; 가 window name 옆에 표시된다.&lt;/p&gt;
&lt;p&gt;현재 &lt;em&gt;session&lt;/em&gt; 에서 새로운 &lt;em&gt;window&lt;/em&gt; 를 생성하려면 &lt;code&gt;ctrl + b, c&lt;/code&gt; 를 입력한다. &lt;em&gt;tmux&lt;/em&gt; 로 새로운 &lt;em&gt;session&lt;/em&gt; 을 생성하면서 동시에 &lt;em&gt;session&lt;/em&gt; 과 &lt;em&gt;window&lt;/em&gt; 의 이름을 지정하려면 &lt;code&gt;tmux new-session -s testsession -n testwindow&lt;/code&gt; 명령으로 &lt;em&gt;tmux&lt;/em&gt; 를 실행하면 된다:&lt;/p&gt;
&lt;p&gt;현재 활성화된(&lt;code&gt;*&lt;/code&gt; 로 표시된) &lt;em&gt;window&lt;/em&gt; 의 name 을 변경하려면 &lt;code&gt;ctrl + b, ,&lt;/code&gt; 을 입력한다.&lt;/p&gt;
&lt;p&gt;현재 활성화된 &lt;em&gt;window&lt;/em&gt; 를 삭제하려면 &lt;code&gt;ctrl + b, &amp;amp;&lt;/code&gt; 를 입력하거나 &lt;code&gt;ctrl + d&lt;/code&gt; 를 입력한다.&lt;/p&gt;
&lt;h3&gt;Move to window&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;window&lt;/em&gt; 사이를 이동하려면 &lt;code&gt;ctrl + b, &amp;lt;window number: 0–9&amp;gt;&lt;/code&gt; 를 입력한다. 또는 &lt;code&gt;ctrl + b, n&lt;/code&gt; 으로 다음 &lt;em&gt;window&lt;/em&gt; 로, &lt;code&gt;ctrl + b, p&lt;/code&gt; 로 이전 &lt;em&gt;window&lt;/em&gt; 로 이동할 수 있다. 바로 직전에 작업하고 있던 &lt;em&gt;window&lt;/em&gt; 로 가려면 &lt;code&gt;ctrl + b, l&lt;/code&gt; 을 사용한다. l 의 의미는 last-window 이다.&lt;/p&gt;
&lt;p&gt;또 다른 &lt;em&gt;window&lt;/em&gt; 를 이동하는 방법은 &lt;code&gt;ctrl + b, w&lt;/code&gt; 를 사용하는 방법이다. 이 키를 입력하면 화면에 현재 &lt;em&gt;session&lt;/em&gt; 내에 열려 있는 &lt;em&gt;window&lt;/em&gt; 들이 list-up 된다. 원하는 &lt;em&gt;window&lt;/em&gt; 를 선택하여 바로 이동할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ctrl + b, f&lt;/code&gt; 를 이용하면 검색을 이용하여 &lt;em&gt;window&lt;/em&gt; 를 이동할 수 있다. 검색 결과가 복수이면 해당 &lt;em&gt;window&lt;/em&gt; 들이 list-up 된다. 원하는 &lt;em&gt;window&lt;/em&gt; 를 선택해서 이동할 수 있다.&lt;/p&gt;
&lt;h3&gt;Exit window&lt;/h3&gt;
&lt;p&gt;현재 &lt;em&gt;window&lt;/em&gt; 를 종료하려면 terminal 에서 &lt;code&gt;exit&lt;/code&gt; command 를 실행한다. 또는 &lt;code&gt;ctrl + d&lt;/code&gt; 를 입력한다. 모든 &lt;em&gt;window&lt;/em&gt; 가 종료되면 &lt;em&gt;session&lt;/em&gt; 도 종료된다.&lt;/p&gt;
&lt;h2&gt;Pane&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;pane&lt;/em&gt; 은 &lt;em&gt;windows&lt;/em&gt; 를 구성하는 화면들이다. &lt;em&gt;windows&lt;/em&gt; 는 1개 또는 여러 개의 pane 들로 구성될 수 있다. 때문에 2개의 &lt;em&gt;pane&lt;/em&gt; 을 만들어서 &lt;em&gt;window&lt;/em&gt; 를 좌우로 나누어 사용할 수도 있다.&lt;/p&gt;
&lt;h3&gt;Split&lt;/h3&gt;
&lt;p&gt;좌우로 window 분할(Split vertical)하려면 &lt;code&gt;ctrl + b, %&lt;/code&gt; 를 입력한다. 또는 command mode 로 &lt;code&gt;split-window -h&lt;/code&gt; 를 입력한다.&lt;/p&gt;
&lt;p&gt;상하로 window 분할(Split horizontal)하려면 &lt;code&gt;ctrl + b, "&lt;/code&gt; 를 입력한다. 또는 command mode 로 &lt;code&gt;split-window -v&lt;/code&gt; 를 입력한다.&lt;/p&gt;
&lt;h3&gt;Move to pane&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ctrl + b, q&lt;/code&gt; 를 입력하면 각 &lt;em&gt;pane&lt;/em&gt; 에 숫자가 잠시 표시된다. 이 때 원하는 pane 의 숫자를 입력하면 해당 &lt;em&gt;pane&lt;/em&gt; 으로 이동한다. 2초 간의 timeout 내에 입력해야 한다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ctrl + b, o&lt;/code&gt; 를 입력하면 정해진 순서에 따라 현재 &lt;em&gt;window&lt;/em&gt; 에 생성된 &lt;em&gt;pane&lt;/em&gt; 들을 차례대로 이동한다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ctrl + b, 방향키(Arrow key)&lt;/code&gt; 를 입력하면 인접한 방향의 &lt;em&gt;pane&lt;/em&gt; 으로 이동한다.&lt;/p&gt;
&lt;h3&gt;Exit pane&lt;/h3&gt;
&lt;p&gt;현재 &lt;em&gt;pane&lt;/em&gt; 을 종료시키려면 terminal 에서 &lt;code&gt;exit&lt;/code&gt; command 를 실행한다. 또는 &lt;code&gt;ctrl + d&lt;/code&gt; 를 입력한다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ctrl + b, x&lt;/code&gt; 를 입력하면 status bar 에 y/n 을 묻는 prompt 가 표시된다. y 를 선택하면 종료된다.&lt;/p&gt;
&lt;p&gt;모든 &lt;em&gt;pane&lt;/em&gt; 들이 종료되면 &lt;em&gt;window&lt;/em&gt; 도 종료된다.&lt;/p&gt;
&lt;h3&gt;Resizing pane&lt;/h3&gt;
&lt;p&gt;command mode 에서 명령을 입력하며 &lt;em&gt;pane&lt;/em&gt; 의 size 를 조절할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;왼쪽으로 10 줄이기 : &lt;code&gt;resize-pane -L 10&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;오른쪽으로 10 늘리기 : &lt;code&gt;resize-pane -R 10&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;아래쪽으로 10 늘리기 : &lt;code&gt;resize-pane -D 10&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;위쪽으로 10 늘리기 : &lt;code&gt;resize-pane -U 10&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Configuration file&lt;/h1&gt;
&lt;p&gt;tmux configuration file 은 &lt;code&gt;~/.tmux.conf&lt;/code&gt; 이다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;setw -g mode-keys vi
set -g status-keys vi

# 0 is too far from `.
set -g base-index 1

# To change prefix
set -g prefix C-a
unbind-key C-b
bind-key C-a send-prefix

bind-key v split-window -h
bind-key s split-window -v

bind-key J resize-pane -D 5
bind-key K resize-pane -U 5
bind-key H resize-pane -L 5
bind-key L resize-pane -R 5

bind-key M-j resize-pane -D
bind-key M-k resize-pane -U
bind-key M-h resize-pane -L
bind-key M-l resize-pane -R

# Vim style pane selection
bind h select-pane -L
bind j select-pane -D 
bind k select-pane -U
bind l select-pane -R

# Use Alt-vim keys without prefix key to switch panes
bind -n M-h select-pane -L
bind -n M-j select-pane -D 
bind -n M-k select-pane -U
bind -n M-l select-pane -R

# Use Alt-arrow keys without prefix key to switch panes
bind -n M-Left select-pane -L
bind -n M-Right select-pane -R
bind -n M-Up select-pane -U
bind -n M-Down select-pane -D

# Shift arrow to switch windows
bind -n S-Left  previous-window
bind -n S-Right next-window

# Reload tmux config
bind r source-file ~/.tmux.conf

# THEME
set -g status-bg black
set -g status-fg white
set -g window-status-current-bg white
set -g window-status-current-fg black
set -g window-status-current-attr bold
set -g status-interval 60
set -g status-left-length 30
set -g status-left &amp;#39;#[fg=green](#S) #(whoami)&amp;#39;
set -g status-right &amp;#39;#[fg=yellow]#(cut -d &amp;quot; &amp;quot; -f 1-3 /proc/loadavg)#[default] #[fg=white]%H:%M#[default]&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Key binding&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;ctrl + b + ?&lt;/code&gt; 을 입력하면 현재의 key binding 리스트를 볼 수 있다.&lt;/p&gt;
&lt;p&gt;사용자가 원하면 &lt;code&gt;~/.tmux.conf&lt;/code&gt; 파일에 key binding 를 설정할 수 있다. 자세한 내용은 tmux manpage 를 참고하자.&lt;/p&gt;
&lt;h1&gt;Copy mode&lt;/h1&gt;
&lt;p&gt;tmux 를 실행하고 있는 환경에서는 scroll bar 가 없다. 이때 &lt;em&gt;Copy mode&lt;/em&gt; 를 사용하면 이전 출력들을 볼 수 있다. 또한 &lt;em&gt;session&lt;/em&gt; 안에서 원하는 text 를 copy / paste 할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ctrl + b, [&lt;/code&gt; 를 입력하면 &lt;em&gt;Copy mode&lt;/em&gt; 로 진입한다. &lt;em&gt;pane&lt;/em&gt; 의 오른쪽 상단에 buffer 에 저장된 총 line 수가 출력된다. &lt;em&gt;Copy mode&lt;/em&gt; 를 종료하고 싶으면 &lt;code&gt;Enter&lt;/code&gt; 를 입력하거나 &lt;code&gt;q&lt;/code&gt; 를 입력한다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Copy mode&lt;/em&gt; 에서 이동은 &lt;code&gt;방향키(Arrow key)&lt;/code&gt;, &lt;code&gt;PageUp&lt;/code&gt;, &lt;code&gt;PageDown&lt;/code&gt; 키들을 사용한다. 만약 vi editor 의 방식으로 이동하고 싶으면 &lt;code&gt;~/.tmux.conf&lt;/code&gt; 파일에 &lt;code&gt;setw -g mode-keys vi&lt;/code&gt; 를 추가한다. 이 설정을 하면 &lt;code&gt;h&lt;/code&gt;, &lt;code&gt;j&lt;/code&gt;, &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;l&lt;/code&gt;, &lt;code&gt;G&lt;/code&gt;, &lt;code&gt;g&lt;/code&gt;, &lt;code&gt;ctrl + f&lt;/code&gt;, &lt;code&gt;ctrl + b&lt;/code&gt; 등 vi editor 에서 cursor 이동에 사용되는 key 들을 사용할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Copy mode&lt;/em&gt; 에서 검색은 &lt;code&gt;?&lt;/code&gt; 와 &lt;code&gt;/&lt;/code&gt; 를 사용한다. &lt;code&gt;?&lt;/code&gt; 또는 &lt;code&gt;/&lt;/code&gt; 를 입력하면 &lt;em&gt;pane&lt;/em&gt; 왼쪽 아래부분에 &lt;code&gt;Search Up:&lt;/code&gt; 이라고 표시된다. 여기에 검색어를 입력한다. &lt;code&gt;?&lt;/code&gt; 를 입력하면 위로 검색, &lt;code&gt;/&lt;/code&gt; 를 입력하면 아래로 검색한다. 다음, 이전 검색은 &lt;code&gt;N&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt; 을 입력한다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Copy mode&lt;/em&gt; 에서 &lt;code&gt;SPACEBAR&lt;/code&gt; 키를 입력하면 &lt;em&gt;Visual mode&lt;/em&gt; 가 되며, Text 를 선택할 수 있게 된다. 선택한 Text 를 복사하고 싶으면 &lt;code&gt;Enter&lt;/code&gt; 키를 입력한다. &lt;em&gt;Copy mode&lt;/em&gt; 에서는 quit 의 의미이지만 &lt;em&gt;Visual mode&lt;/em&gt; 에서는 복사와 함꼐 quit 를 수행한다. 복사한 Text 를 붙여넣고 싶다면 &lt;code&gt;ctrl + b, ]&lt;/code&gt; 를 입력한다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ctrl + b, :&lt;/code&gt; 를 입력하여 command mode 를 실행한 후 &lt;code&gt;list-buffers&lt;/code&gt; 를 실행하면 현재 저장된 모든 buffer 들을 볼 수 있다. &lt;code&gt;choose-buffer&lt;/code&gt; 를 입력하면 모든 buffer 들의 리스트가 출력되고 원하는 buffer 를 선택할 수 있다. &lt;code&gt;show-buffer&lt;/code&gt; 를 입력하면 0번째 buffer 의 내용을 보여준다. 참고로 &lt;code&gt;ctrl + b, ]&lt;/code&gt; 는 무조건 0번째 buffer 를 붙여넣기 한다.&lt;/p&gt;
&lt;h1&gt;Start with script&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;session&lt;/em&gt; 을 만들고, 화면을 분할하고, 특정 directory 를 생성하고, 패키지를 설치하고, 기타 필요한 작업들을 script 로 작성하여 &lt;em&gt;session&lt;/em&gt; 을 생성할 때 한꺼번에 수행되도록 할 수 있다.&lt;/p&gt;
&lt;p&gt;tmux initilizing automation script example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ cat start_with_tmux.sh
&lt;span class="c1"&gt;#!/bin/bash&lt;/span&gt;
&lt;span class="nv"&gt;SESSION&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;tmuxtest
&lt;span class="nv"&gt;PROJECT_HOME&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;~/Projects&amp;quot;&lt;/span&gt;
&lt;span class="nv"&gt;PROJECT_NAME&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;1&lt;/span&gt;&lt;span class="k"&gt;:-&lt;/span&gt;&lt;span class="nv"&gt;node&lt;/span&gt;&lt;span class="p"&gt;-project&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;
&lt;span class="nv"&gt;TMUX&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;tmux&amp;quot;&lt;/span&gt;
&lt;span class="c1"&gt;# Create new session&lt;/span&gt;
&lt;span class="nv"&gt;$TMUX&lt;/span&gt; new-session -d -s &lt;span class="nv"&gt;$SESSION&lt;/span&gt;
&lt;span class="c1"&gt;# Create new windows&lt;/span&gt;
&lt;span class="nv"&gt;$TMUX&lt;/span&gt; new-window -t &lt;span class="nv"&gt;$SESSION&lt;/span&gt;:1 -n withindex
&lt;span class="nv"&gt;$TMUX&lt;/span&gt; new-window -t &lt;span class="nv"&gt;$SESSION&lt;/span&gt; -n withoutindex
&lt;span class="c1"&gt;# Select window&lt;/span&gt;
&lt;span class="nv"&gt;$TMUX&lt;/span&gt; &lt;span class="k"&gt;select&lt;/span&gt;-window -t withindex
&lt;span class="c1"&gt;# Split window&lt;/span&gt;
&lt;span class="nv"&gt;$TMUX&lt;/span&gt; split-window -h
&lt;span class="c1"&gt;# Select pane and run commands&lt;/span&gt;
&lt;span class="nv"&gt;$TMUX&lt;/span&gt; &lt;span class="k"&gt;select&lt;/span&gt;-pane -t 0
&lt;span class="nv"&gt;$TMUX&lt;/span&gt; send-keys &lt;span class="s2"&gt;&amp;quot;mkdir -p &lt;/span&gt;&lt;span class="nv"&gt;$PROJECT_HOME&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; Enter
&lt;span class="nv"&gt;$TMUX&lt;/span&gt; send-keys &lt;span class="s2"&gt;&amp;quot;cd &lt;/span&gt;&lt;span class="nv"&gt;$PROJECT_HOME&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; Enter
&lt;span class="nv"&gt;$TMUX&lt;/span&gt; send-keys &lt;span class="s2"&gt;&amp;quot;echo &amp;#39;date&amp;#39; &amp;gt; test.txt&amp;quot;&lt;/span&gt; Enter
&lt;span class="nv"&gt;$TMUX&lt;/span&gt; split-window -v
&lt;span class="c1"&gt;# C-m means Carriage Return (one of control characters)&lt;/span&gt;
&lt;span class="nv"&gt;$TMUX&lt;/span&gt; send-keys &lt;span class="s2"&gt;&amp;quot;cd &lt;/span&gt;&lt;span class="nv"&gt;$PROJECT_HOME&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; Enter
&lt;span class="nv"&gt;$TMUX&lt;/span&gt; send-keys &lt;span class="s2"&gt;&amp;quot;tail -f test.txt&amp;quot;&lt;/span&gt; C-m
&lt;span class="c1"&gt;# Select pane and run commands&lt;/span&gt;
&lt;span class="nv"&gt;$TMUX&lt;/span&gt; &lt;span class="k"&gt;select&lt;/span&gt;-pane -t 2
&lt;span class="nv"&gt;$TMUX&lt;/span&gt; send-keys &lt;span class="s2"&gt;&amp;quot;ls -ail&amp;quot;&lt;/span&gt; Enter
References
http://tmux.github.io/
https://github.com/tmux/tmux
http://haruair.com/blog/2124
http://nodeqa.com/nodejs_ref/99
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;References&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://tmux.github.io"&gt;tmux web&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/tmux/tmux"&gt;tmux github&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="tmux"></category></entry><entry><title>Java version 을 체크하는 bash script</title><link href="https://imjang57.github.io/garret/bash-script-checking-java-version.html" rel="alternate"></link><published>2016-12-30T00:00:00+09:00</published><updated>2016-12-30T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2016-12-30:/garret/bash-script-checking-java-version.html</id><summary type="html">&lt;p&gt;Java version 을 체크하기 위한 bash script&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Check Java version from bash script&lt;/h1&gt;
&lt;p&gt;리눅스에서 자바 버전을 체크하기 위한 꼼수 스크립트를 간단하게 작성해서 저장하기 위한 글입니다.&lt;/p&gt;
&lt;p&gt;java -version 명령의 결과:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ java -version
java version &lt;span class="s2"&gt;&amp;quot;1.8.0_73&amp;quot;&lt;/span&gt;
Java&lt;span class="o"&gt;(&lt;/span&gt;TM&lt;span class="o"&gt;)&lt;/span&gt; SE Runtime Environment &lt;span class="o"&gt;(&lt;/span&gt;build 1.8.0_73-b02&lt;span class="o"&gt;)&lt;/span&gt;
Java HotSpot&lt;span class="o"&gt;(&lt;/span&gt;TM&lt;span class="o"&gt;)&lt;/span&gt; 64-Bit Server VM &lt;span class="o"&gt;(&lt;/span&gt;build 25.73-b02, mixed mode&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;환경변수 $JAVA_HOME을 찾아서 하는 bash script:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/bin/bash&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; -n &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$JAVA_HOME&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;then&lt;/span&gt;
  &lt;span class="nv"&gt;JAVA_CMD&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$JAVA_HOME&lt;/span&gt;&lt;span class="s2"&gt;/bin/java&amp;quot;&lt;/span&gt;
  &lt;span class="nv"&gt;JAVA_VERSION&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;&lt;span class="nv"&gt;$JAVA_CMD&lt;/span&gt; -version 2&amp;gt;&lt;span class="p"&gt;&amp;amp;&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; awk -F&lt;span class="s1"&gt;&amp;#39;&amp;quot;&amp;#39;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;/version/ {print $2}&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; awk -F&lt;span class="s1"&gt;&amp;#39;_&amp;#39;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;{print $1}&amp;#39;&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;
  &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Run using java version &lt;/span&gt;&lt;span class="nv"&gt;$JAVA_VERSION&lt;/span&gt;&lt;span class="s2"&gt; (JAVA_HOME is &lt;/span&gt;&lt;span class="nv"&gt;$JAVA_HOME&lt;/span&gt;&lt;span class="s2"&gt;)&amp;quot;&lt;/span&gt;
  &lt;span class="o"&gt;[[&lt;/span&gt; &lt;span class="nv"&gt;$JAVA_VERSION&lt;/span&gt; &amp;gt; 1.8 &lt;span class="o"&gt;]]&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="nv"&gt;$?&lt;/span&gt; -eq &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
  &lt;span class="k"&gt;then&lt;/span&gt;
    &lt;span class="nb"&gt;echo&lt;/span&gt; This java version is greater than 1.8.
  &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="nb"&gt;echo&lt;/span&gt; This java version is not supported.
  &lt;span class="k"&gt;fi&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;
  &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Java doesn&amp;#39;t exists.&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;fi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;자바 실행 파일 위치를 찾아서 하는 bash script:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/bin/bash&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="k"&gt;$(&lt;/span&gt;which java&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;then&lt;/span&gt;
  &lt;span class="nv"&gt;JAVA_PATH&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;whereis java&lt;span class="k"&gt;)&lt;/span&gt;
  &lt;span class="nv"&gt;JAVA_VERSION&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;java -version 2&amp;gt;&lt;span class="p"&gt;&amp;amp;&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; awk -F&lt;span class="s1"&gt;&amp;#39;&amp;quot;&amp;#39;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;/version/ {print $2}&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; awk -F&lt;span class="s1"&gt;&amp;#39;_&amp;#39;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;{print $1}&amp;#39;&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;
  &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Run using java version &lt;/span&gt;&lt;span class="nv"&gt;$JAVA_VERSION&lt;/span&gt;&lt;span class="s2"&gt; (&lt;/span&gt;&lt;span class="nv"&gt;$JAVA_PATH&lt;/span&gt;&lt;span class="s2"&gt;)&amp;quot;&lt;/span&gt;
  &lt;span class="o"&gt;[[&lt;/span&gt; &lt;span class="nv"&gt;$JAVA_VERSION&lt;/span&gt; &amp;gt; 1.8 &lt;span class="o"&gt;]]&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="nv"&gt;$?&lt;/span&gt; -eq &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
  &lt;span class="k"&gt;then&lt;/span&gt;
    &lt;span class="nb"&gt;echo&lt;/span&gt; This java version is greater than 1.8.
  &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="nb"&gt;echo&lt;/span&gt; This java version is not supported.
  &lt;span class="k"&gt;fi&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;
  &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Java doesn&amp;#39;t exists.&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;fi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;두 방법이 사실 거의 똑같다. 그냥 whereis 명령을 이용하느냐, JAVA_HOME 이라는 환경변수를 이용하느냐만 다르다.&lt;/p&gt;
&lt;p&gt;다른 방법으로는 sort 명령을 이용해서 가장 앞에 위치하는 녀석을 비교하는 방법도 있다.&lt;/p&gt;
&lt;p&gt;처음에는 bc 명령을 사용하려 했는데 버전은 보통 여러 개의 comma(.)로 되어있어서 bc 로 사용은 불가능했다. 사실 comma(.) 단위로 나눠서 각각 비교하는 로직 구현하면 되는데 귀찮음이 커서..&lt;/p&gt;
&lt;p&gt;이 방법은 사실 완벽한 방법은 아니다. awk 로 추출한 문자열이 x.y.z 형태라는 걸 알고 있기 때문에 가능한 방법이다. 만약 1.8 로 버전이 추출되면 제대로 동작 안할 것이다. 제대로 하려면 comma(.) 단위로 나눠서 제대로 비교하는 함수를 만들어야 겠지..&lt;/p&gt;</content><category term="bash"></category></entry><entry><title>자바에서 % 출력하기</title><link href="https://imjang57.github.io/garret/print-percent-sign-in-java.html" rel="alternate"></link><published>2016-12-30T00:00:00+09:00</published><updated>2016-12-30T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2016-12-30:/garret/print-percent-sign-in-java.html</id><summary type="html">&lt;p&gt;자바에서 % 문자 출력하기&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Java String 에서 % 문자 출력하기&lt;/h1&gt;
&lt;p&gt;오늘 개발하다가 &lt;code&gt;%&lt;/code&gt; 문자가 들어가는 문자열을 처리할 일이 있었다. 처음에 아무 생각없이 아래처럼 작성했다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;str1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;test&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;str2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;format&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;string is \&amp;quot;%%s%\&amp;quot;.&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;str1&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;원하는 결과는 아래와 같이 나오는 것이었다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;string is &amp;quot;%test%&amp;quot;.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;당연히 String.format 에서 에러가 발생했다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Exception in thread &amp;quot;main&amp;quot; java.util.UnknownFormatConversionException: Conversion = &amp;#39;&amp;quot;&amp;#39;
 at java.util.Formatter.checkText(Formatter.java:2579)
 at java.util.Formatter.parse(Formatter.java:2565)
 at java.util.Formatter.format(Formatter.java:2501)
 at java.util.Formatter.format(Formatter.java:2455)
 at java.lang.String.format(String.java:2940)
 at StringTest.main(StringTest.java:7)
 at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
 at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
 at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
 at java.lang.reflect.Method.invoke(Method.java:497)
 at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;\&lt;/code&gt; 는 특정 &lt;em&gt;espace character&lt;/em&gt; 로 이미 약속된 문자들과 사용돼야 한다. 그런데 그 문자들 중에 &lt;code&gt;%&lt;/code&gt; 는 없다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;%&lt;/code&gt; 는 &lt;em&gt;Formatting&lt;/em&gt; 을 위한 문자로, &lt;code&gt;String.format("%d", 123);&lt;/code&gt; 과 같이 사용된다. 이 때 &lt;code&gt;%&lt;/code&gt; 자체를 출력하기 위해서도 &lt;code&gt;%&lt;/code&gt; 를 prefix 로 사용하여 &lt;code&gt;%%&lt;/code&gt; 와 같이 처리해야 한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;str1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;test&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;str2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;format&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;string is %%%s%%.&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;str1&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;%&lt;/code&gt; 는 그냥 문자가 아니라 포맷을 지정하기 위한 포맷 지시자 (format specifier 또는 format string) 역할을 하는 특수한 문자이기 때문이다.&lt;/p&gt;
&lt;p&gt;알고 있던 거였는데.. 역시 오래동안 안쓰면 머리에서 삭제되어 버린다. ㅠㅠ&lt;/p&gt;</content></entry><entry><title>SSH Host-key identification</title><link href="https://imjang57.github.io/garret/ssh-host-key-identification.html" rel="alternate"></link><published>2016-12-30T00:00:00+09:00</published><updated>2016-12-30T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2016-12-30:/garret/ssh-host-key-identification.html</id><summary type="html">&lt;p&gt;This is about SSH Host-key identification.&lt;/p&gt;</summary><content type="html">&lt;h1&gt;SSH host key&lt;/h1&gt;
&lt;p&gt;가끔 SSH Client 로 Remote 에 있는 SSH Server 에 접속할 때 아래와 같은 에러를 볼 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;imjang57@myserver:~$ ssh administrator@192.168.0.5
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!              @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now &lt;span class="o"&gt;(&lt;/span&gt;man-in-the-middle
attack&lt;span class="o"&gt;)&lt;/span&gt;!
It is also possible that a host key has just been changed.
The fingerprint &lt;span class="k"&gt;for&lt;/span&gt; the ECDSA key sent by the remote host is
bf:e3:d3:21:c4:3c:60:cd:d9:2b:bb:a4:d1:6e:1f:df.
Please contact your system administrator.
Add correct host key in /home/imjang57/.ssh/known_hosts to get rid of
this message.
Offending ECDSA key in /home/imjang57/.ssh/known_hosts:8
  remove with: ssh-keygen -f &lt;span class="s2"&gt;&amp;quot;/home/imjang57/.ssh/known_hosts&amp;quot;&lt;/span&gt; -R
192.168.0.5
ECDSA host key &lt;span class="k"&gt;for&lt;/span&gt; 192.168.0.5 has changed and you have
requested strict checking.
Host key verification failed.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;em&gt;Host Key&lt;/em&gt; 가 달라서 발생하는 문제다. 자세히 말하면, 클라이언트 측에 등록된 SSH 서버의 호스트 키가 현재 접속 시도하면서 새롭게 받은 호스크 키와 달라서 발생한 문제이다.&lt;/p&gt;
&lt;p&gt;SSH 서버에서 호스트 키를 새롭게 생성했거나, 클라이언트 측에서 SSH 서버의 호스트 키를 수동으로 입력했는데 잘못입력했거나, 서버를 재설치했거나, 기타 등등의 이유로 기존에 저장된 호스트 키와 연결시도하면서 새롭게 받은 호스트 키가 다를 수 있다.&lt;/p&gt;
&lt;p&gt;이는 SSH 연결을 시도하는 서버가 정말 내가 연결하려는 서버가 맞는지를 체크할 수 있는 기능이다. HTTPS 를 사용할 때 신뢰할 수 있는 사이트인지 확인하는 것과 비슷한 이유로 제공되는 기능이다.&lt;/p&gt;
&lt;h2&gt;해결 방법&lt;/h2&gt;
&lt;p&gt;해결하는 방법은 여러개가 있다.&lt;/p&gt;
&lt;h3&gt;known_host 삭제하여 해결&lt;/h3&gt;
&lt;p&gt;보통 사용자의 홈 디렉터리에 .ssh 라는 디렉터리가 있고, 여기에 사용자를 위한 SSH 설정이나 사용자 인증을 위한 키 파일이 저장된다. 그리고 &lt;user_home&gt;/.ssh 디렉터리 밑에 known_hosts 라는 파일이 있는데 여기에 SSH 서버의 호스트 키들이 저장되어 있다. 여기서 에러가 나는 SSH 서버의 호스트 키를 삭제하면 다시 연결할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ssh-keygen -f &lt;span class="s2"&gt;&amp;quot;/home/imjang57/.ssh/known_hosts&amp;quot;&lt;/span&gt; -R 192.168.0.5
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;위 명령으로 저장된 서버의 호스트 키를 삭제한 후 SSH 서버에 다시 접속하면 아래와 같이 호스트 키를 등록하냐고 물어보는 메시지가 나타난다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;imjang57@myserver:~$ ssh administrator@192.168.0.5
The authenticity of host &lt;span class="s1"&gt;&amp;#39;192.168.0.5&amp;#39;&lt;/span&gt; can&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;t be established.
ECDSA key fingerprint is
bf:e3:d3:21:c4:3c:60:cd:d9:2b:bb:a4:d1:6e:1f:df.
Are you sure you want to &lt;span class="k"&gt;continue&lt;/span&gt; connecting &lt;span class="o"&gt;(&lt;/span&gt;yes/no&lt;span class="o"&gt;)&lt;/span&gt;?
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;yes 를 입력하면 호스트 키를 &lt;user_home&gt;/.ssh/known_hosts 파일에 저장하고 SSH 접속하게 된다.&lt;/p&gt;
&lt;p&gt;만약 명령어 치는게 귀찮으면 그냥 known_hosts 파일 삭제하면 된다.&lt;/p&gt;
&lt;h3&gt;StrictHostKeyChecking 설정을 off 하여 해결&lt;/h3&gt;
&lt;p&gt;리눅스에서 ssh 설정은 보통 &lt;code&gt;/etc/ssh&lt;/code&gt; 디렉터리에 있다. &lt;code&gt;ssh_config&lt;/code&gt; 파일은 클라이언트 설정 파일, &lt;code&gt;sshd_config&lt;/code&gt; 는 서버(데몬) 설정 파일이다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ssh_config&lt;/code&gt; 파일에서 아래 내용을 찾아서 호스트 키 검사를 하지 않도록 설정하면 된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;StrictHostKeyChecking no
&lt;span class="nv"&gt;UserKnownHostsFile&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/dev/null
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;호스트 키 새로 생성하는 방법&lt;/h2&gt;
&lt;p&gt;서버를 운영하는 입장에서 서버를 추가할 때 기존 서버의 이미지를 사용해서 새로운 서버를 구성할 수 있다. 이 때 호스트 키를 새롭게 생성해야 한다.&lt;/p&gt;
&lt;p&gt;호스트 키는 보통 &lt;code&gt;/etc/ssh&lt;/code&gt; 에 저장되어 있다. &lt;em&gt;RSA&lt;/em&gt;, &lt;em&gt;DSA&lt;/em&gt;, &lt;em&gt;ECDSA&lt;/em&gt; 세 가지 종류의 키 파일들이 보통 생성되어 있다.&lt;/p&gt;
&lt;p&gt;새로 호스트 키를 생성하기 위해 아래 명령을 실행해서 세 가지 종류의 호스트 키 파일들을 생성하면 된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo ssh-keygen -f /etc/ssh/ssh_host_rsa_key -N &lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt; -t rsa
sudo ssh-keygen -f /etc/ssh/ssh_host_dsa_key -N &lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt; -t dsa
sudo ssh-keygen -f /etc/ssh/ssh_host_ecdsa_key -N &lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt; -t ecdsa -b 521
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;기존에 파일들이 있으면 overwrite 할 거냐고 묻는데 당연히 &lt;code&gt;y&lt;/code&gt; 를 입력하자.&lt;/p&gt;</content><category term="SSH"></category></entry><entry><title>Integer types header file (stdint.h)</title><link href="https://imjang57.github.io/garret/integer-types-header-file-stdint.html" rel="alternate"></link><published>2016-01-02T00:00:00+09:00</published><updated>2016-01-02T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2016-01-02:/garret/integer-types-header-file-stdint.html</id><summary type="html">&lt;p&gt;C 언어의 Integer data type 의 크기를 정의한 stdint.h 헤더파일&lt;/p&gt;</summary><content type="html">&lt;h1&gt;uintXX_t data types in stdint.h&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;_t&lt;/code&gt; 는 구조체에 붙이는 것이라기 보다는 user-defined type 에 붙이는 것이다. &lt;code&gt;uint8_t&lt;/code&gt;, &lt;code&gt;uint32_t&lt;/code&gt; 등은 &lt;code&gt;stdint.h&lt;/code&gt; 헤더파일에 정의되어 있으며 C99 표준에서 도입되었다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;stdint.h&lt;/code&gt; : This header defines a set of integral type aliases with specific width requirements, along with macros specifying their limits and macro functions to create values of these types.&lt;/p&gt;
&lt;p&gt;C 언어 표준에는 &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt; 등과 같은 Primitive data type 을 지원한다. 하지만 표준에서 이런 type 들이 몇 bytes 를 필요로 하는지 정확한 정의를 하지 않았다. 때문에 Machine (CPU) 의 종류에 따라 &lt;code&gt;int&lt;/code&gt; 나 &lt;code&gt;long&lt;/code&gt; 등의 크기가 달라지게 되었다. (대부분은 &lt;code&gt;char&lt;/code&gt; 1 byte, &lt;code&gt;short&lt;/code&gt; 2 bytes, &lt;code&gt;int&lt;/code&gt; 4 bytes 로 알고 가르치지만 대부분의 machine 에서 이렇게 사용할 뿐이지 다 똑같은 건 아니다. 표준은 &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt; 에 대해 &lt;code&gt;short&lt;/code&gt; 은 최소 &lt;code&gt;int&lt;/code&gt; 보다 같거나 작아야 한다고 정의되어 있으며, &lt;code&gt;long&lt;/code&gt; 은 &lt;code&gt;int&lt;/code&gt; 보다 같거나 커야 한다고 정의되어 있을 뿐이다.) 이는 C 언어로 작성된 프로그램의 호환성(Portability) 에 매우 큰 악영향을 미칠 수 있는 요소였다.&lt;/p&gt;
&lt;p&gt;이러한 machine 에 따른 호환성 문제를 해결하기 위해 C99 표준에서는 &lt;code&gt;int8_t&lt;/code&gt;, &lt;code&gt;uint8_t&lt;/code&gt;, &lt;code&gt;int16_t&lt;/code&gt;, &lt;code&gt;uint16_t&lt;/code&gt;, &lt;code&gt;int32_t&lt;/code&gt;, &lt;code&gt;uint32_t&lt;/code&gt;, &lt;code&gt;int64_t&lt;/code&gt;, &lt;code&gt;uint64_t&lt;/code&gt; 등을 도입하였다.&lt;/p&gt;
&lt;p&gt;C99 에서 도입된 &lt;code&gt;stdint.h&lt;/code&gt; 는 이전에 존재하던 &lt;code&gt;limits.h&lt;/code&gt; 와는 성격이 다르다. 기존의 &lt;code&gt;limits.h&lt;/code&gt; 가 machine-dependent data type 의 크기를 서술한 것이라면, &lt;code&gt;stdint.h&lt;/code&gt; 는 data type 의 size 를 명확하게 정의한다. &lt;code&gt;limits.h&lt;/code&gt; 는 기계마다 다르게 정의되는 각 data type 의 크기만 알려줄 뿐이며, 원하는 크기의 자료형을 선언하는데는 크게 도움이 되지 않는다. 반면 &lt;code&gt;stdint.h&lt;/code&gt; 는 기존의 &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt; 과 같은 자료형을 보다 명확하게 수치로 나타낸다.&lt;/p&gt;
&lt;p&gt;32 비트 기계에서 16 비트 크기를 가지는 정수 자료형을 명확하게 선언하고 싶다면, &lt;code&gt;int16_t&lt;/code&gt; 를 사용하고, 32 비트 정수 자료형이라면 &lt;code&gt;int32_t&lt;/code&gt; 를 사용하여 선언한다. 기본 자료형을 다시 재정의하는 것은 쓸데없이 혼란을 가중시킬거라 생각할지도 모르지만, 이런 식으로 보다 명확하게 자료형을 재정의하는 것은 훨씬 명확한 코드를 작성하는데 도움이 된다. 부동소수점 자료형을 제외한 정수 자료형들은 모두 이런 &lt;code&gt;intN_t&lt;/code&gt; 스타일로 정의할 수 있는데, &lt;code&gt;char&lt;/code&gt; 도 &lt;code&gt;int8_t&lt;/code&gt; 와 같이 선언할 수 있다. C 에서 &lt;code&gt;char&lt;/code&gt; 타입은 정수형으로도 간주될 수 있기 때문이다. 자료형의 크기를 명확하게 밝혀준다는 장점 외에도, &lt;code&gt;unsigned int&lt;/code&gt; 와 같은 긴 문장을 간단하게 &lt;code&gt;uint32_t&lt;/code&gt; 로 표현할 수 있다는 장점도 있다. 호환성을 염두에 둔 코드를 작성한다면, &lt;code&gt;stdint.h&lt;/code&gt; 는 매우 편리한 존재가 아닐 수 없다. C99 에서 새롭게 도입된 &lt;code&gt;stdint.h&lt;/code&gt; 는 C++ 에도 &lt;code&gt;cstdint&lt;/code&gt; 헤더 파일로 포함되어 있다.&lt;/p&gt;</content><category term="c programming language"></category><category term="stdint.h"></category></entry></feed>