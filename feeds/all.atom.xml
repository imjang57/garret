<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>garret</title><link href="https://imjang57.github.io/garret/" rel="alternate"></link><link href="https://imjang57.github.io/garret/feeds/all.atom.xml" rel="self"></link><id>https://imjang57.github.io/garret/</id><updated>2017-12-19T00:00:00+09:00</updated><entry><title>MacOS initial settings</title><link href="https://imjang57.github.io/garret/macos-initial-settings.html" rel="alternate"></link><published>2017-12-19T00:00:00+09:00</published><updated>2017-12-19T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-12-19:/garret/macos-initial-settings.html</id><summary type="html">&lt;p&gt;MacOS에서 가장 처음에 하는 환경설정 내용을 요약&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Mac Development Environment&lt;/h1&gt;
&lt;p&gt;Keyboard notation examples :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Control + b, c&lt;/code&gt;는 &lt;code&gt;Control&lt;/code&gt; 키를 누른 상태에서 &lt;code&gt;b&lt;/code&gt;를 누르고, &lt;code&gt;Control&lt;/code&gt; 키와 &lt;code&gt;b&lt;/code&gt;에서 손을 뗀 후 &lt;code&gt;c&lt;/code&gt;를 눌러라는 의미&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Control + b, Control + c&lt;/code&gt;는 &lt;code&gt;Control&lt;/code&gt; 키를 누른 상태에서 &lt;code&gt;b&lt;/code&gt;를 누르고, &lt;code&gt;b&lt;/code&gt;에서 손을 뗀 후 &lt;code&gt;c&lt;/code&gt;를 눌러라는 의미&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;System Preferences&lt;/h2&gt;
&lt;p&gt;언어 우선순위를 영어, 한국어 순서로 변경 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Language &amp;amp; Region&lt;/code&gt; &amp;gt; &lt;code&gt;Preferred languages&lt;/code&gt; : English &amp;gt; 한국어 (드래그로 순서 조정)&lt;/li&gt;
&lt;li&gt;locale 설정 때문에 오류가 발생하는 걸 방지&lt;/li&gt;
&lt;li&gt;영어 에러가 구글검색이 잘됨&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;보안 설정 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Security &amp;amp; Privacy&lt;/code&gt; &amp;gt; &lt;code&gt;General&lt;/code&gt; &amp;gt; &lt;code&gt;Require password&lt;/code&gt; : select &lt;code&gt;immediately&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Security &amp;amp; Privacy&lt;/code&gt; &amp;gt; &lt;code&gt;General&lt;/code&gt; &amp;gt; &lt;code&gt;Show a message when the screen is locked&lt;/code&gt; : input phone number, name, etc&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Keyboard :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Keyboard&lt;/code&gt; &amp;gt; &lt;code&gt;Text&lt;/code&gt; : disable all automatic and smart options&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Trackpad :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Trackpad&lt;/code&gt; &amp;gt; &lt;code&gt;Point &amp;amp; Click&lt;/code&gt; &amp;gt; &lt;code&gt;Tab to click&lt;/code&gt; : Enable&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Accessibility&lt;/code&gt; &amp;gt; &lt;code&gt;Mouse &amp;amp; Trackpad&lt;/code&gt; &amp;gt; &lt;code&gt;Trackpad options...&lt;/code&gt; : check &lt;code&gt;Enable dragging&lt;/code&gt; &amp;gt; select &lt;code&gt;three finger drag&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Dark menu bar :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;General&lt;/code&gt; &amp;gt; &lt;code&gt;Use dark menu bar and Dock&lt;/code&gt; : Enable&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Scroll bar :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;General&lt;/code&gt; &amp;gt; &lt;code&gt;Show scroll bars&lt;/code&gt; : select &lt;code&gt;Always&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Screen Saver:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Desktop &amp;amp; Screen Saver&lt;/code&gt; &amp;gt; &lt;code&gt;Screen Saver&lt;/code&gt; &amp;gt; Start after : &lt;code&gt;10 Minutes&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Finder Preferences&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;General&lt;/code&gt; &amp;gt; &lt;code&gt;New Finder windows show&lt;/code&gt; : your home directory&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Advanced&lt;/code&gt; &amp;gt; &lt;code&gt;Show all filename extensions&lt;/code&gt; : Enable&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Sidebar&lt;/code&gt; &amp;gt; &lt;code&gt;Favorites&lt;/code&gt; &amp;gt; check your home directory and others you want to add sidebar&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Install Magnet&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;web site : http://magnet.crowdcafe.com&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;My Key settings:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Control + Option + h&lt;/code&gt; : Left&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Control + Option + j&lt;/code&gt; : Up&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Control + Option + k&lt;/code&gt; : Down&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Control + Option + l&lt;/code&gt; : Right&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Control + Option + u&lt;/code&gt; : Top Left&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Control + Option + i&lt;/code&gt; : Top Right&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Control + Option + m&lt;/code&gt; : Bottom Left&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Control + Option + ,&lt;/code&gt; : Bottom Right&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Control + Option + y&lt;/code&gt; : Left Two Third&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Control + Option + o&lt;/code&gt; : Right Two Third&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Control + Option + c&lt;/code&gt; : Cender&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Control + Option + Enter&lt;/code&gt; : Maximize&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Control + Option + Delete&lt;/code&gt; : Restore&lt;/li&gt;
&lt;li&gt;Disable others&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Install Xcode Command Line Tools&lt;/h2&gt;
&lt;p&gt;Xcode를 설치해야 gcc 등의 개발 도구를 사용할 수 있다. Xcode 전체를 설치할 필요가 없다면 Xcode Command Line Tools만 따로 설치할 수도 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;gt; xcode-select --install
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;참고로 Mac 에서는 gcc가 아니라 llvm을 사용한다. &lt;code&gt;gcc&lt;/code&gt; 명령을 실행하면 실제로는 llvm의 C언어 front-end인 &lt;code&gt;clang&lt;/code&gt; 명령이 실행된다.&lt;/p&gt;
&lt;h2&gt;Install Homebrew&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;web site : https://brew.sh&lt;/li&gt;
&lt;li&gt;GitHub : https://github.com/Homebrew/brew/&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Homebrew는 Mac에서 패키지 설치와 관리를 쉽게 해주는 도구이다. 다양한 개발 도구들을 쉽게 구성할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;gt; /usr/bin/ruby -e &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;quot; 
&amp;gt; brew help
&amp;gt; brew cask
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Install packages&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ brew install git vim python3 node@8 wget maven
$ brew cask install iterm2 sublime-text google-chrome evernote java slack intellij-idea-ce docker
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;맥북 터치바 모델일 경우&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;System Preferences&lt;/code&gt; - &lt;code&gt;Keyboard&lt;/code&gt; &amp;gt; &lt;code&gt;Shortcuts&lt;/code&gt; &amp;gt; &lt;code&gt;Function Keys&lt;/code&gt; &amp;gt; iTerm.app 및 &lt;code&gt;Sublime Text&lt;/code&gt; 등 추가&lt;/li&gt;
&lt;/ul&gt;</content><category term="mac"></category><category term="macos"></category></entry><entry><title>iTerm2</title><link href="https://imjang57.github.io/garret/iterm2.html" rel="alternate"></link><published>2017-12-18T00:00:00+09:00</published><updated>2017-12-18T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-12-18:/garret/iterm2.html</id><summary type="html">&lt;p&gt;iTerm2 설치 및 사용법&lt;/p&gt;</summary><content type="html">&lt;h1&gt;iTerm2&lt;/h1&gt;
&lt;p&gt;iTerm2 는 맥에서 가장 많이 사용되는 터미널(Terminal) 프로그램이다.&lt;/p&gt;
&lt;h2&gt;Installation&lt;/h2&gt;
&lt;p&gt;iTerm2 에서 제공하는 공식 바이너리로 쉽게 설치할 수도 있지만 나는 왠만하면 모든 패키지들을 &lt;code&gt;brew&lt;/code&gt;로 관리하기를 원해서 &lt;code&gt;brew-cask&lt;/code&gt;로 설치했다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ brew cask install iterm2
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Configuration&lt;/h2&gt;
&lt;p&gt;내가 사용하는 환경을 위한 설정들을 해보자.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Preferences(cmd + ,)&lt;/code&gt; =&amp;gt; &lt;code&gt;Profiles&lt;/code&gt; =&amp;gt; &lt;code&gt;Colors&lt;/code&gt; =&amp;gt; &lt;code&gt;Tango Dark&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Preferences(cmd + ,)&lt;/code&gt; =&amp;gt; &lt;code&gt;Profiles&lt;/code&gt; =&amp;gt; &lt;code&gt;Text&lt;/code&gt; =&amp;gt; &lt;code&gt;Font&lt;/code&gt; =&amp;gt; &lt;code&gt;Change Font&lt;/code&gt; =&amp;gt; 13pt, Meslo LG M Regular for Powerline&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Preferences(cmd + ,)&lt;/code&gt; =&amp;gt; &lt;code&gt;Profiles&lt;/code&gt; =&amp;gt; &lt;code&gt;Window&lt;/code&gt; =&amp;gt; &lt;code&gt;Window Appearance&lt;/code&gt; =&amp;gt; &lt;code&gt;Transparency&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Preferences(cmd + ,)&lt;/code&gt; =&amp;gt; &lt;code&gt;Profiles&lt;/code&gt; =&amp;gt; &lt;code&gt;Window&lt;/code&gt; =&amp;gt; &lt;code&gt;Settings for New Windows&lt;/code&gt; =&amp;gt; &lt;code&gt;Columns&lt;/code&gt; : 200, &lt;code&gt;Rows&lt;/code&gt; : 50&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Preferences(cmd + ,)&lt;/code&gt; =&amp;gt; &lt;code&gt;Profiles&lt;/code&gt; =&amp;gt; &lt;code&gt;Terminal&lt;/code&gt; =&amp;gt; &lt;code&gt;Scrollback Buffer&lt;/code&gt; =&amp;gt; check &lt;code&gt;Unlimited scrollback&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Key Mappings&lt;/h2&gt;
&lt;p&gt;자주 사용하는 단축키들은 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;새 창 : &lt;code&gt;Command + n&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;새 탭 : &lt;code&gt;Command + t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;탭 닫기 : &lt;code&gt;Command + w&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;전체 창 전환 : &lt;code&gt;Command + enter&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;탭 순환 이동 : &lt;code&gt;Command + tab&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;탭 이동 : &lt;code&gt;Command + 번호&lt;/code&gt;, &lt;code&gt;Command + 방향키&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;탭 세로 분할 : &lt;code&gt;Command + d&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;탭 가로 분할 : &lt;code&gt;Command + Shift + d&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;탭 분할 시 포커스 찾기 : &lt;code&gt;Command + /&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;탭 분할 포커스 이동 : &lt;code&gt;Command + [&lt;/code&gt; , &lt;code&gt;Command + ]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;탭 투명하게 설정 : &lt;code&gt;Command + i&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;탭 투명하게 on/off : &lt;code&gt;Command + u&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;검색 : &lt;code&gt;Command + f&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;검색 결과 탐색 : &lt;code&gt;Command + g&lt;/code&gt;, &lt;code&gt;Command + Shift + g&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;전체 검색 : &lt;code&gt;Command + Option + e&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;클립보드 : &lt;code&gt;Command + Shift + h&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;자동완성 : &lt;code&gt;Command + ;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;작업시간 보여주기 : &lt;code&gt;Command + Shift + e&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Preferences : &lt;code&gt;Command + ,&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Profiles Preferences : &lt;code&gt;Command + i&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;iTerm2 종료 : &lt;code&gt;Command + q&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;References&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;https://www.iterm2.com&lt;/li&gt;
&lt;/ul&gt;</content><category term="mac"></category><category term="iterm2"></category><category term="terminal"></category></entry><entry><title>Git Submodule</title><link href="https://imjang57.github.io/garret/git-submodule.html" rel="alternate"></link><published>2017-12-16T00:00:00+09:00</published><updated>2017-12-16T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-12-16:/garret/git-submodule.html</id><summary type="html">&lt;p&gt;Git Submodule 사용법&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Git submodule&lt;/h1&gt;
&lt;p&gt;Git 서브모듈(Git submodule)은  Git 저장소(Git Repository)에 다른 Git 저장소를 포함시키기 위한 도구이다. 이렇게 다른 저장소를 저장소 내부에 추가하여도 각 저장소는 독립적으로 관리된다. 보통 서브모듈을 포함하는 저장소를 슈퍼프로젝트(Super-project)라고 한다.&lt;/p&gt;
&lt;h2&gt;Add submodule&lt;/h2&gt;
&lt;p&gt;서브모듈을 추가하려면 저장소에서 다음과 같이 실행하면 된다. 예를 들어 서브모듈로 추가하려는 저장소의 이름을 &lt;code&gt;yourtheme&lt;/code&gt; 라고 하자.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ git submodule add https://github.com/imjang57/yourtheme theme/yourtheme
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;theme/yourtheme&lt;/code&gt;에 서브모듈 저장소가 생성된다. 슈퍼프로젝트에서 &lt;code&gt;git status&lt;/code&gt; 명령을 실행하면 &lt;code&gt;.gitmodules&lt;/code&gt; 파일과 &lt;code&gt;theme/yourtheme&lt;/code&gt; 파일이 새로 생성된 것을 확인할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ git status
&lt;span class="c1"&gt;# On branch master&lt;/span&gt;
&lt;span class="c1"&gt;# Changes to be committed:&lt;/span&gt;
&lt;span class="c1"&gt;#   (use &amp;quot;git reset HEAD &amp;lt;file&amp;gt;...&amp;quot; to unstage)&lt;/span&gt;
&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;span class="c1"&gt;#      new file:   .gitmodules&lt;/span&gt;
&lt;span class="c1"&gt;#      new file:   theme/yourtheme&lt;/span&gt;
&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;.gitmodules&lt;/code&gt; 파일의 내용은 다음과 같다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;[submodule &amp;quot;theme/yourtheme&amp;quot;]&lt;/span&gt;
    &lt;span class="na"&gt;path&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;theme/yourtheme&lt;/span&gt;
&lt;span class="s"&gt;    url = https://github.com/imjang57/yourtheme&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;그리고 &lt;code&gt;theme/yourtheme&lt;/code&gt; 파일을 확인하면 다음과 같이 출력된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ git diff --cached theme/yourtheme
diff --git a/theme/yourtheme b/theme/yourtheme
new file mode 160000
index 0000000..08d709f
--- /dev/null
+++ b/theme/yourtheme
@@ -0,0 +1 @@
+Subproject commit 08d709f78b8c5b0fbeb7821e37fa53e69afcf433
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;git diff&lt;/code&gt; 명령의 결과가 파일의 내용이 아니라 &lt;code&gt;Subproject commit 08d709f78b8c5b0fbeb7821e37fa53e69afcf433&lt;/code&gt; 와 같이 출력되는 것을 확인할 수 있다. 이것은 Git이 &lt;code&gt;theme/yourtheme&lt;/code&gt;를 서브모듈로 인식해서 서브모듈의 어느 커밋(commit)을 참조하고 있는지만 관리하기 때문이다. 또한, file mode 가 &lt;code&gt;160000&lt;/code&gt;으로 나오는 것을 확이할 수 있는데, 이는 일반적인 파일이나 디렉터리가 아니라는 의미이다.&lt;/p&gt;
&lt;p&gt;즉, 실제 작업 디렉터리(Working directory)에는 &lt;code&gt;theme/yourtheme&lt;/code&gt;라는 이름의 디렉터리가 있고, 그 안에 또 하나의 Git 저장소가 있다. 하지만 슈퍼프로젝트의 관점에서는 &lt;code&gt;theme/yourtheme&lt;/code&gt;는 서브모듈이기 때문에 참조하는 값만 관리하는 것이다.&lt;/p&gt;
&lt;p&gt;서브모듈을 추가하면 서브모듈 내에서 해당 프로젝트의 내용을 수정하고 커밋(commit)이나 푸시(push) 할 수도 있다. 즉, 서브모듈도 일반적인 다른 저장소와 똑같이 사용할 수 있다. 그리고 이렇게 서브모둘을 수정하면 수정된 서브모듈의 커밋 해시(commit hash)가 새롭게 슈퍼프로젝트에 저장된다. 따라서 슈퍼프로젝트도 커밋해주어야 이 변경된 참조가 저장된다.&lt;/p&gt;
&lt;h2&gt;서브모듈을 가진 저장소를 클론(clone)하기&lt;/h2&gt;
&lt;p&gt;서브모듈을 사용하는 프로젝트를 Clone하면 해당 서브모듈 디렉토리는 빈 디렉터리다. 이떄는 먼저 &lt;code&gt;git submodule init&lt;/code&gt; 명령으로 서브모듈을 초기화하고, &lt;code&gt;git submodule update&lt;/code&gt; 명령으로 서브모듈 저장소를 가져와야 한다. 이 때 슈퍼프로젝트에 저장된 커밋 해시값을 참고하여 각 서브모듈들을 체크아웃(checkout)한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ git submodule init
Submodule &lt;span class="s1"&gt;&amp;#39;theme/yourtheme&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;https://github.com/imjang57/yourtheme.git&lt;span class="o"&gt;)&lt;/span&gt; registered &lt;span class="k"&gt;for&lt;/span&gt; path &lt;span class="s1"&gt;&amp;#39;theme/yourtheme&amp;#39;&lt;/span&gt;
$ git submodule update
Cloning into &lt;span class="s1"&gt;&amp;#39;/home/imjang57/mysite/themes/yourtheme&amp;#39;&lt;/span&gt;...
Submodule path &lt;span class="s1"&gt;&amp;#39;themes/yourtheme&amp;#39;&lt;/span&gt;: checked out &lt;span class="s1"&gt;&amp;#39;08d709f78b8c5b0fbeb7821e37fa53e69afcf433&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Submodule Update&lt;/h2&gt;
&lt;p&gt;서브모듈을 최신 버전으로 업데이트하려면 서브모듈 디렉터리에서 &lt;code&gt;git fetch&lt;/code&gt; 명령을 실행하고 &lt;code&gt;git merge&lt;/code&gt; 명령으로 머지한다.&lt;/p&gt;
&lt;p&gt;이후 메인 프로젝트(슈퍼프로젝트)에서 &lt;code&gt;git diff --submodule&lt;/code&gt; 명령을 실행하면 업데이트된 서브모듈과 각 서브모듈에 추가된 커밋을 볼 수 있다. 이 상태에서 메인 프로젝트에서 &lt;code&gt;git commit&lt;/code&gt; 명령으로 커밋하면 변경된 서브모듈 내용(커밋 해시)이 메인 프로젝트에 적용된다.&lt;/p&gt;
&lt;p&gt;간단하게 이 작업을 하려면 &lt;code&gt;git submodule update --remote&lt;/code&gt; 명령을 실행한다. 이 명령을 실행하면 Git이 스스로 서브모듈을 Fetch하고 업데이트한다. 이 명령을 기본적으로 &lt;code&gt;master&lt;/code&gt; 브랜치를 체크아웃하고 업데이트를 수행한다. 브랜치를 바꾸려면 &lt;code&gt;.gitmodules&lt;/code&gt; 파일을 다음과 같이 수정한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;[submodule &amp;quot;theme/yourtheme&amp;quot;]&lt;/span&gt;
    &lt;span class="na"&gt;path&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;theme/yourtheme&lt;/span&gt;
&lt;span class="s"&gt;    url = https://github.com/imjang57/yourtheme&lt;/span&gt;
&lt;span class="s"&gt;    branch = stable&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;References&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;https://git-scm.com/book/en/v2/Git-Tools-Submodules&lt;/li&gt;
&lt;li&gt;https://git-scm.com/book/ko/v2/Git-도구-서브모듈&lt;/li&gt;
&lt;/ul&gt;</content><category term="git"></category></entry><entry><title>PKI, SSL/TLS, 인증서(Certificate), HTTPS</title><link href="https://imjang57.github.io/garret/ssl-pubic-key-infrastructure.html" rel="alternate"></link><published>2017-11-01T00:00:00+09:00</published><updated>2017-11-01T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-11-01:/garret/ssl-pubic-key-infrastructure.html</id><summary type="html">&lt;p&gt;PKI, SSL/TLS, 인증서, HTTPS 등 인터넷 상의 보안과 인증이 어떤 원리로 동작하는지에 대한 설명&lt;/p&gt;</summary><content type="html">&lt;h1&gt;암호화 (Encryption) : SSL and TLS&lt;/h1&gt;
&lt;p&gt;TCP/IP 로 패킷(Packet)들이 전송될 때 인터넷 상의 수많은 라우터와 노드들을 지나가게 된다. 그리고 이들 중 어떤 노드에서는 패킷 감청(Package Sniffing)을 하기도 하는데, 암호화가 되어있지 않은 패킷들은 이러한 감청에 속수무책으로 당할 수 밖에 없다. 감청을 통해 정보를 훔치는 것 외에 가로챈 패킷을 변조할 수도 있다. 그래서 이를 막기 위해 네트웍(Network) 상에서 흐르는 패킷들을 암호화하는 기술들이 등장했고 TCP/IP Layer 와 Application Layer 사이에서 데이터를 암호화하는 SSL(Secure Sockets Layer)가 등장했다.&lt;/p&gt;
&lt;p&gt;SSL은 현재에는 TLS(Transport Layer Security)로 이름이 바뀌었지만 많은 사람들이 아직도 SSL이라는 이름을 많이 사용하고 있다. 그래서 보통 SSL/TLS 등과 같이 표기를 많이 한다. 즉, SSL과 TLS는 같은 녀석이다.&lt;/p&gt;
&lt;h2&gt;인코딩과 디코딩 (Encoding and Decoding)&lt;/h2&gt;
&lt;p&gt;정보의 형태를 임의로 변환하는 것을 인코딩(Encoding)이라고 한다. 그리고 인코딩된 정보를 다시 원래대로 되돌리는 것을 디코딩(Decoding)이라고 한다.&lt;/p&gt;
&lt;p&gt;인코딩의 방법에 따라 디코딩이 될 수도 있고 안될 수도 있다. 예를 들어 가장 기초적인 인코딩 방법인 Base64는 쉽게 원래의 데이터로 디코딩할 수 있지만 해싱(Hashing)은 서로 다른 정보도 같은 값으로 인코딩될 수 있기 때문에 디코딩이 불가능하다.&lt;/p&gt;
&lt;h2&gt;Base64&lt;/h2&gt;
&lt;p&gt;Base64는 8 bits 바이너리 데이터(Binary data)를 문자 코드에 영향을 받지 않는 공통 ASCII 문자들로만 이루어진 문자열로 바꾸는 인코딩 방식이다. Base 64 라는 단어를 글자 그대로 번역하여 보면 64진법이란 뜻이다. 64가 2의 제곱수(64 = 2^6)이며, 2의 제곱수들에 기반한 진법들 중에서 화면에 표시되는 ASCII 문자들을 써서 표현할 수 있는 가장 큰 진법이기 때문에 Base64라는 이름이 되었다.&lt;/p&gt;
&lt;p&gt;Base 64에는 어떤 문자와 기호를 쓰느냐에 따라 여러 변종이 있지만, 잘 알려진 것은 모두 처음 62개는 알파벳 A-Z, a-z와 0-9를 사용하고 있으며 마지막 두 개를 어떤 기호를 쓰느냐의 차이만 있다.&lt;/p&gt;
&lt;p&gt;베이스64의 정확한 규격은 &lt;a href="https://tools.ietf.org/html/rfc1421"&gt;RFC 1421&lt;/a&gt;, &lt;a href="https://tools.ietf.org/html/rfc2045"&gt;RFC 2045&lt;/a&gt;에 정의된다. 연속된 8 bits 단위로 인코딩하도록 정의되어 있으며, 이는 대부분 시스템에서 파일의 정의와 들어맞는다. 베이스64코딩을 거친 결과물은 원본보다 대략 4/3 정도 크기가 늘어나게 되며, 보통 의미없어 보이는 문자열이 나열된 형태가 된다.&lt;/p&gt;
&lt;p&gt;데이터를 베이스64로 바꾸는 과정은 다음과 같다. 우선 24 bits 버퍼에 위쪽(MSB)부터 한 바이트(byte)씩 3 바이트를 집어넣는다. 그리고 남은 바이트가 3 바이트 미만이라면, 버퍼의 남은 부분은 0으로 채워넣게 된다. 그리고, 버퍼의 위쪽부터 6 bits씩 잘라 그 값을 읽어, 다음에 정렬된 64개 "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"의 문자 중에서 읽은 값 번째 문자를 골라 출력한다. 만약 입력된 바이트가 하나라면 출력 중 두 개만이 사용되고 나머지 둘은 "="으로 패딩되며, 입력된 바이트가 둘이라면 출력 중 세 개 만이 사용되고 나머지 하나는 "="으로 패딩되게 된다. 이것은 원본으로 되돌릴 때 원본에는 없던 비트가 생기는 것을 방지하기 위함이다. 이 과정은 입력 데이터가 끝날 때까지 반복하면 인코딩이 된다.&lt;/p&gt;
&lt;p&gt;예를 들어 아래의 문장이 있다고 하자.&lt;/p&gt;
&lt;p&gt;Man is distinguished, not only by his reason, but by this singular passion from other animals, which is a lust of the mind, that by a perseverance of delight in the continued and indefatigable generation of knowledge, exceeds the short vehemence of any carnal pleasure.&lt;/p&gt;
&lt;p&gt;이를 Base64로 인코딩하면 다음과 같다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0
aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1
c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0
aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdl
LCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;이렇게 특정한 패턴으로 인코딩 및 디코딩하는 것이 가장 기초적인 방법이다.&lt;/p&gt;
&lt;h2&gt;암호화와 복호화 (Encryption and Decryption)&lt;/h2&gt;
&lt;p&gt;위의 특정한 패턴을 이용한 인코딩/디코딩 방법은 패턴이 파악될 경우 의미가 없어진다. 실제로 2차 세계대전이 발생했을 때 서로 적국의 통신 내용을 파악하기 위해 패턴으로 암호화된 내용을 도청하여 인력을 투입하여 분석했었다. 그래서 매일 패턴을 바꿔가며 통신을 했었다.&lt;/p&gt;
&lt;p&gt;보안을 위한 암호화/복호화에는 더 복잡하고 어려운 방법이 필요하다. 이를 위해 키(Key)를 이용한 방법이 사용된다. 현대에 암호화라고 하면 보통 이 키를 이용한 인코딩/디코딩 방법을 의미한다.&lt;/p&gt;
&lt;p&gt;키를 이용한 암호화 방법에는 대칭키 암호화(Symmetric Key Encryption), 비대칭키 암호화(Asymmetric Key Encryption)이 있다. 키를 생성하는 방법은 매우 수학적 이론이 필요한 내용이므로 따로 자료를 찾아보고 여기서는 인코딩/디코딩으로 암호화되는 과정에 집중해서 보자.&lt;/p&gt;
&lt;h2&gt;대칭키 암호화&lt;/h2&gt;
&lt;p&gt;대칭키 암호화는 발신자와 수신자가 동일한 알고리즘과 키를 공유하는 방식이다. 이 방법을 사용해서 제대로 보안을 유지하려면 직접 만나서 대칭키를 전달받는 것이 가장 안전한 방법이지만 사람이 많아질 수록 번거로운 방법이 되며, 누군가 키를 유출했을 경우 속수무책으로 당할 수 있다. 키를 잘 관리한다면 충분히 안전할 수도 있지만, 사실 모두가 공개된 환경인 인터넷에서 대칭키를 어떻게 배포하느냐는 중요한 문제를 해결하지 못하면 사용할 수가 없는 방법이기도 하다.&lt;/p&gt;
&lt;h2&gt;비대칭키 암호화&lt;/h2&gt;
&lt;p&gt;공개키(Public Key)와 비밀키(Private Key)라고 불리는 두 가지 종류의 키를 사용하는 방식이다. 참고로 비밀키는 개인키라고도 불린다. 공개키로 암호화된 데이터는 비밀키로만 복호화가 되고, 비밀키로 암호화된 데이터는 공개키로만 복호화된다. 이러한 특성을 통해 비대칭키 암호화는 대칭키 안호화가 가지고 있던 고질적 문제(키를 어떻게 배포할 것인가)를 해결하였다.&lt;/p&gt;
&lt;p&gt;수신자는 비밀키를 갖고 이를 절대 외부로 유출하지 않는다. 그리고 공개키를 인터넷에 공개하여 발신자가 가져갈 수 있도록 한다. 발신자는 인터넷에서 공개키를 가져간 후 공개키로 데이터를 암호화하여 수신자에게 전송한다. 수신자는 본인이 가진 비밀키로 데이터를 복호화한다. 공개키는 아무나 가져가도 암호화만 가능할 뿐 복호화를 할 수 없기 때문에 키의 배포 문제도 해결하면서 높은 보안성도 얻을 수 있다.&lt;/p&gt;
&lt;p&gt;하지만 비대칭키 암호화는 대칭키 암호화 방법보다도 복잡한 수학적 이론을 사용하기 때문에 속도가 느리고 연산량이 많다. 때문에 보통 비대칭키 암호화 방식으로 둘만의 대칭키를 교환하고 실제 데이터 통신은 둘만 공유하는 대칭키를 이용하여 하는 경우가 많다.&lt;/p&gt;
&lt;p&gt;보통 비대칭키 알고리즘이라고 하면 RSA 알고리즘을 말한다. RSA 알고리즘은 로널드 라이베스트(Ron Rivest), 아디 샤미르(Adi Shamir), 레너드 애들먼(Leonard Adleman)의 연구에 의해 체계화되었으며, RSA라는 이름은 이들 3명의 이름 앞글자를 딴 것이다.&lt;/p&gt;
&lt;h2&gt;전자서명 (Digital Signature)&lt;/h2&gt;
&lt;p&gt;전자서명은 인터넷 상에서 본인을 증빙하기 위한 방법이다. RSA 알고리즘을 이용하여 구현되었으며, 전자서명은 오프라인에서의 수기서명과 동일하다. 보통 인터넷 상에서 어떠한 파일을 배포하거나 서비스를 제공할 때 제공자가 본인이 배포한 것이 맞음을 증빙하고, 데이터가 변조되지 않았음을 증명하는 수단으로 사용된다.&lt;/p&gt;
&lt;p&gt;예를 들어, 문서 내용을 A라고 하면 잘 알려진 Hash 함수인 SHA1 같은 함수 하나를 정해서 문서 A의 Hash 값을 구하고 이 Hash 값을, 보내는 사람의 비밀키로 암호화 한다. 이런 다음 이렇게 암호화된 Hash값을 원래 문서 A의 끝에 첨부하여 이 문서 전체를 받는 사람에게 보낸다.&lt;/p&gt;
&lt;p&gt;받는 사람은 먼저 메시지가 오면 해쉬값을 뺀 앞부분의 문서에 대해 보내는 사람이 사용했던 Hash함수를 이용해 받은 문서의 Hash값을 구한다. 그 다음 문서 뒤에 달린 암호화된 Hash값을 보내는 사람의 공개키로 복호화한 다음 이 복호화된 Hash값을, 받은 문서의 Hash값과 비교하게된다. 이 두개의 Hash값이 동일한 값이면 서명이 올바른 것이고 값이 서로 다르거나 변환에 오류가 있으면 서명이 틀린 것이다.&lt;/p&gt;
&lt;h2&gt;인증서 (Certificate)&lt;/h2&gt;
&lt;p&gt;전자서명은 데이터가 제공자가 제공한 것이 맞고 변조되지 않았음을 보장해줄 수 있다. 하지만 데이터 제공자, 즉 공개키의 실제 소유자가 실제로 누군지를 증명해주지는 않는다. 그래서 인증서라는 개념이 등장하게 되었다.&lt;/p&gt;
&lt;p&gt;인증서는 정부기관이나 은행 등 공인된 기관에서 발급받을 수 있다. 기관은 신청자에게 생성된 비밀키와 인증서를 제공해준다. 이때 받는 인증서에는 신청자에 대한 정보, 신청자의 공개키, 유효기간, 인증기관 정보, 인증서에 대한 인증기관의 전자서명 등이 포함되어 있다. 즉, 인증서는 공인된 인증기관이 인증서의 소유자에 대한 신원을 보증해주는 것이다. 그리고 이를 위해 세계적으로 몇몇 인증기관(CA, Certification Authority)들이 존재하고 있으며, 이렇게 비대칭키 암호화 방법을 기반으로 공개키와 인증서를 활용하는 환경을 공개키 기반 구조(PKI, Public Key Infrastructure)라고 한다. HTTPS, SFTP, SSH, SCP 등 현대에서 인터넷 상의 모든 보안 관련된 기능들은 모두 PKI 기반이라고 볼 수 있다.&lt;/p&gt;
&lt;p&gt;인증기관은 범국제적인 PKI를 위해서 X.509라는 인증서의 국제 표준 규격을 따르고 있다. X.509 는 &lt;a href="https://tools.ietf.org/html/rfc5280"&gt;RFC 5280&lt;/a&gt;에 의해 정의되어 있다. X.509 규격에 따르면 인증서는 최상위 인증기관(Root CA)의 루트 인증서(Root Certificate)를 시작으로 하위 인증기관들의 인증서들이 존재하고 일반 사용자들의 인증서도 존재한다. 루트 인증서를 제공하는 최상위 인증기관은 하위 인증기관들을 인증하고, 하위 인증기관들은 다른 하위 인증기관 또는 일반 사용자들을 인증한다. 즉, 인증기관들의 인증서에는 상위 인증기관의 전자서명이 포함되어 있고, 일반 사용자들의 인증서에는 인증기관의 전자서명이 포함되어 있다. 예외적으로 루트 인증서만 자가서명(Self-signed)되어 있다. 그리고 이러한 PKI 기반 구조에서 사용자가 상위 인증서를 신뢰한다면 그 하위의 모든 인증서도 신뢰하는 것으로 받아들여 진다. 요즘의 시스템들은 모두 신뢰할 수 있는 CA 리스트를 갖고 있어서 이들 하위의 인증서들은 신뢰할 수 있다고 판단한다.&lt;/p&gt;
&lt;p&gt;일반적으로 인증서는 인증기관에서 유료로 발급받을 수 있다. 인증기관들도 무료 자원봉사를 하는 것은 아니기 떄문에 인증 서비스를 위한 비용을 지불해야 한다. 한국에서는 한국인터넷진흥원(KISA)가 최상위 인증기관(Root CA)이 되는 별도의 PKI 시스템이 있지만, KISA가 아직 국제 최상위 인증기관(Root CA)의 인증을 받지 못해서 (병신같지만) 국내 인증기관(CA)에서 발급받은 인증서는 특정 웹 브라우저들에게는 신뢰받지 못할 수도 있다.&lt;/p&gt;
&lt;p&gt;참고로 개인도 자가서명된 인증서(Self-signed certificate)를 가질 수 있다. &lt;code&gt;openssl&lt;/code&gt; 등과 같이 SSL 규격을 구현한 프로그램들을 사용하여 생성할 수 있다. 단, 자가서명된 인증서를 사용하려면 시스템(운영체제, 가상머신 등)에 인증서를 추가하는 작업을 별도로 해야 한다.&lt;/p&gt;
&lt;p&gt;2016년에는 Mozilla, Sisco, Akamai 등이 HTTPS의 보급을 위하여 &lt;a href="https://letsencrypt.org"&gt;Let's Encrypt&lt;/a&gt;라는 비영리 인증기관을 설립하고 무료로 인증서를 발급해주고 있다. 여기서 받은 인증서는 별도의 과정없이 신뢰할 수 있는 인증서로 사용될 수 있다.&lt;/p&gt;
&lt;h2&gt;SSL/TLS&lt;/h2&gt;
&lt;p&gt;SSL/TLS는 TCP Layer와 Application Layer 사이에서 비대칭키 암호화를 이용하여 데이터들을 암호화하여 감청을 방지하고, 전송하는 데이터에 전자서명을 첨부하여 변조를 방지하고, 인증서를 이용하여 서버에 대한 인증을 담당한다.&lt;/p&gt;
&lt;p&gt;SSL Handshake :&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;서버가 클라이언트에게 공개키가 포함되어 있는 인증서를 전달한다.&lt;/li&gt;
&lt;li&gt;클라이언트는 신뢰하는 CA 리스트를 확인하여 서버의 인증서를 신뢰할 수 있는지 판단한다.&lt;/li&gt;
&lt;li&gt;클라이언트는 대칭키를 생성하여 서버의 공개키로 암호화하여 서버에게 전달한다.&lt;/li&gt;
&lt;li&gt;서버아 클라이언트는 대칭키를 이용하여 데이터를 주고받는다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;SSH (Secure SHell) and SSL/TLS&lt;/h2&gt;
&lt;p&gt;SSH는 보안이 강화된 텔넷(Telnet)이라고 볼 수도 있다. 물론 SSH는 Port Forwarding 등 더 다양한 기능을 제공하고 쓰임새가 더 많지만 어찌되었든 본질은 보안이 강화된 텔넷과도 같다. 그리고 SSH도 보안을 위해 비대칭키 방식과 대칭키 방식을 SSL/TLS와 같은 방법으로 사용한다. 단지 키를 주고받는 메시지의 포맷이 다를 뿐이다. 위에서 언급한 것과 같이 SSL/TLS는 X.509 규격을 따르고 &lt;code&gt;openssl&lt;/code&gt; 등과 같은 프로그램으로 인증서를 생성할 수 있다. SSH는 독자적인 포맷을 따르고 &lt;code&gt;ssh-keygen&lt;/code&gt; 프로그램을 통해서 SSH Key 파일을 생성할 수 있다.&lt;/p&gt;
&lt;p&gt;어찌되었든 SSH도 SSL/TLS와 똑같은 보안 체계이기 때문에 보안성이 높다. 그래서 보통 보안이 약한 네트웍 통신을 하게 될 경우 SSH Port Forwarding 기능을 통해 Tunneling하여 사용하기도 한다.&lt;/p&gt;</content><category term="ssl"></category><category term="tls"></category><category term="certificate"></category><category term="https"></category></entry><entry><title>Vim Plugin</title><link href="https://imjang57.github.io/garret/vim-plugin.html" rel="alternate"></link><published>2017-05-05T00:00:00+09:00</published><updated>2017-05-05T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-05-05:/garret/vim-plugin.html</id><summary type="html">&lt;p&gt;Vim Plugin&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Vim Plugin&lt;/h1&gt;
&lt;p&gt;Vim 은 &lt;em&gt;Vim script&lt;/em&gt; 라는 자체 스크립트 언어를 제공하여 Plugin 을 만들 수 있게 한다. 이 스크립트들은 &lt;code&gt;plugin-name.vim&lt;/code&gt; 과 같이 vim 이라는 확장자(extension) 을 갖는다. &lt;em&gt;Vim script&lt;/em&gt; 는 &lt;a href="http://www.vim.org/scripts/index.php"&gt;Vim script page&lt;/a&gt; 에 많이 업로드되어 있다.&lt;/p&gt;
&lt;p&gt;환경 설정을 위해 사용되는 &lt;code&gt;.vimrc&lt;/code&gt; 파일도 사실은 &lt;em&gt;Vim script&lt;/em&gt; 이다.&lt;/p&gt;
&lt;p&gt;Vim plugin 은 2가지 종류가 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;filetype plugin : 특정 file type 에 대해서 동작하는 plugin. Default 로 &lt;code&gt;$VIMRUNTIME/ftplugin&lt;/code&gt; directory 에서 관리된다.&lt;/li&gt;
&lt;li&gt;global plugin : 모든 file type 에 대해서 동작하는 plugin. Default 로 &lt;code&gt;$VIMRUNTIME/plugin&lt;/code&gt; directory 에서 관리된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;각 plugin 의 위치가 &lt;code&gt;$VIMRUNTIME&lt;/code&gt; 밑에 꼭 있어야 하는 것은 아니다. Vim plugin 을 관리하는 plugin 을 설치하면 각자가 Runtime path 를 관리하여 &lt;code&gt;~/.vim/bundle&lt;/code&gt; 에 각 plugin 디렉터리를 생성하고 그 하위에 &lt;code&gt;ftplugin&lt;/code&gt; 과 &lt;code&gt;plugin&lt;/code&gt; 등 필요한 디렉터리들을 생성해서 사용하기도 한다.&lt;/p&gt;
&lt;h1&gt;Vundle&lt;/h1&gt;
&lt;p&gt;Vim plugin 을 관리하기 위한 여러 plugin 들이 있는데 나는 &lt;a href="https://github.com/VundleVim/Vundle.vim"&gt;Vundle&lt;/a&gt; 을 사용한다.&lt;/p&gt;
&lt;p&gt;자세한 내용은 &lt;a href="https://github.com/VundleVim/Vundle.vim"&gt;Vundle&lt;/a&gt; 에 가면 설치 방법부터 잘 나와있으니 참고하자.&lt;/p&gt;
&lt;p&gt;설치는 매우 쉽다. git clone 하여 &lt;code&gt;~/.vim/bundle/Vundle.vim&lt;/code&gt; 에 설치하고 &lt;code&gt;~/.vimrc&lt;/code&gt; 파일에 Vundle 을 위한 설정과 설치하여 사용할 Plugin 목록을 입력해주기만 하면 된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Vundle 은 인터넷을 통해 각 plugin 들을 받아서 &lt;code&gt;~/.vim/bundle&lt;/code&gt; 에 설치한다.&lt;/p&gt;
&lt;h2&gt;My &lt;code&gt;.vimrc&lt;/code&gt; including Vundle&lt;/h2&gt;
&lt;p&gt;아래 내용은 Vundle 과 Vundle 로 설치한 Plugin 들을 위한 &lt;code&gt;.vimrc&lt;/code&gt; 파일 내용이다. (기본적인 &lt;code&gt;.vimrc&lt;/code&gt; 파일 내용은 &lt;a href="https://imjang57.github.io/garret/vim-configuration.html"&gt;vim configuration&lt;/a&gt; 을 참고하자):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;
&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;Belows are Vundle Plugin configurations
filetype off

&amp;quot; set the runtime path to include Vundle and initialize
set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()
&amp;quot; alternatively, pass a path where Vundle should install plugins
&amp;quot;call vundle#begin(&amp;#39;~/some/path/here&amp;#39;)

&amp;quot; let Vundle manage Vundle, required
Plugin &amp;#39;VundleVim/Vundle.vim&amp;#39;

&amp;quot; The following are examples of different formats supported.
&amp;quot; Keep Plugin commands between vundle#begin/end.
&amp;quot; plugin on GitHub repo
&amp;quot;Plugin &amp;#39;tpope/vim-fugitive&amp;#39;
&amp;quot; plugin from http://vim-scripts.org/vim/scripts.html
&amp;quot;Plugin &amp;#39;L9&amp;#39;
&amp;quot; Git plugin not hosted on GitHub
&amp;quot;Plugin &amp;#39;git://git.wincent.com/command-t.git&amp;#39;
&amp;quot; git repos on your local machine (i.e. when working on your own plugin)
&amp;quot;Plugin &amp;#39;file:///home/gmarik/path/to/plugin&amp;#39;
&amp;quot; The sparkup vim script is in a subdirectory of this repo called vim.
&amp;quot; Pass the path to set the runtimepath properly.
&amp;quot;Plugin &amp;#39;rstacruz/sparkup&amp;#39;, {&amp;#39;rtp&amp;#39;: &amp;#39;vim/&amp;#39;}
&amp;quot; Install L9 and avoid a Naming conflict if you&amp;#39;ve already installed a
&amp;quot; different version somewhere else.
&amp;quot;Plugin &amp;#39;ascenator/L9&amp;#39;, {&amp;#39;name&amp;#39;: &amp;#39;newL9&amp;#39;}

Plugin &amp;#39;The-NERD-tree&amp;#39;
Plugin &amp;#39;AutoComplPop&amp;#39;
Plugin &amp;#39;majutsushi/tagbar&amp;#39;
Plugin &amp;#39;airblade/vim-gitgutter&amp;#39;
Plugin &amp;#39;vim-airline/vim-airline&amp;#39;
Plugin &amp;#39;vim-airline/vim-airline-themes&amp;#39;
Plugin &amp;#39;kien/ctrlp.vim&amp;#39;
Plugin &amp;#39;pathogen.vim&amp;#39;

let g:airline#extensions#tabline#enabled = 1

let NERDTreeWinPost = &amp;quot;left&amp;quot;

nmap &amp;lt;F6&amp;gt; :NERDTreeFind&amp;lt;CR&amp;gt;
nmap &amp;lt;F7&amp;gt; :NERDTree&amp;lt;CR&amp;gt;
nmap &amp;lt;F8&amp;gt; :TagbarToggle&amp;lt;CR&amp;gt;

filetype on

&amp;quot; All of your Plugins must be added before the following line
call vundle#end()            &amp;quot; required
filetype plugin indent on    &amp;quot; required
&amp;quot; To ignore plugin indent changes, instead use:
&amp;quot;filetype plugin on
&amp;quot;
&amp;quot; Brief help
&amp;quot; :PluginList       - lists configured plugins
&amp;quot; :PluginInstall    - installs plugins; append `!` to update or just
&amp;quot; :PluginUpdate
&amp;quot; :PluginSearch foo - searches for foo; append `!` to refresh local cache
&amp;quot; :PluginClean      - confirms removal of unused plugins; append `!` to
&amp;quot;auto-approve removal
&amp;quot;
&amp;quot; see :h vundle for more details or wiki for FAQ
&amp;quot; Put your non-Plugin stuff after this line

let g:ctrlp_custom_ignore = {
    \ &amp;#39;dir&amp;#39;: &amp;#39;\.git$\|vendor$&amp;#39;,
    \ &amp;#39;file&amp;#39;: &amp;#39;\v\.(exe|so|dll)$&amp;#39;
        \ }
&lt;/pre&gt;&lt;/div&gt;</content><category term="vim"></category></entry><entry><title>Vim Basic Regular Expression</title><link href="https://imjang57.github.io/garret/vim-basic-regular-expression.html" rel="alternate"></link><published>2017-05-04T00:00:00+09:00</published><updated>2017-05-07T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-05-04:/garret/vim-basic-regular-expression.html</id><summary type="html">&lt;p&gt;Vim 에서 사용가능한 정규표현식의 기본 사용법에 대한 글이다.&lt;/p&gt;</summary><content type="html">&lt;h1&gt;정규 표현식 (regular expression)&lt;/h1&gt;
&lt;p&gt;정규표현식이란 주로 문자열 내에서 검색이나 조작에 사용되는 표현식으로써 특정한 패턴을 가지고 그 패턴에 부합되는 문자열을 찾아내 원하는 일을 수행 할 수가 있다.&lt;/p&gt;
&lt;p&gt;정규표현식은 vim, sed, grep, emacs, perl 등 프로그램이나 프로그래밍 언어 등에서 문자열을 다루는 용도로 사용되고 있다.&lt;/p&gt;
&lt;p&gt;정규표현식이 쓰이는 모든 프로그램에서 동일한 문법으로 정규표현식을 규정하고 있지는 않는다. 기본적인 내용은 모두 같지만 약간의 표현 형식이 다르다. 즉, 이 글에 작성한 내용은 다른 프로그램이나 언어에서 사용하는 정규표현식과 다를 수 있다.&lt;/p&gt;
&lt;p&gt;Vim 의 &lt;code&gt;:help pattern&lt;/code&gt; 을 참고하자.&lt;/p&gt;
&lt;h1&gt;Basic Vim Regular Expression&lt;/h1&gt;
&lt;p&gt;여기에 나오는 정규표현식은 Vim 뿐만 아니라 Vim 의 전신인 Vi 에서도 사용되는 정규표현식이다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[ ]&lt;/code&gt; 안에는 알파벳이나 숫자가 올 수 있고 이 안에 나열되어 있는 문자 중 한 문자를 가리킨다. 즉 [abc] 는 검색에서 한 문자처럼 취급을 받는다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[abc]&lt;/code&gt; : a, b, c 문자 중 한 문자&lt;/li&gt;
&lt;li&gt;&lt;code&gt;b[abc]ll&lt;/code&gt; : ball, bbll, bcll 중 하나&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;[ ]&lt;/code&gt; 안에는 문자의 범위가 들어 갈 수도 있다. 대소문자를 구분하니 주의해야 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[a-z]&lt;/code&gt; : 소문자 a 부터 z 중 한 문자&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[a-f]&lt;/code&gt; : 소문자 a 부터 f 중 한 문자&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[0-9]&lt;/code&gt; : 숫자 0 부터 9 중 한 문자&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[A-Z0-9]&lt;/code&gt; : 대문자 A 부터 Z 와 숫자 0 부터 9 중 한 문자&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[A-Z][0-9][0-9]&lt;/code&gt; : 첫문자는 무조건 대문자로 시작하고 곧바로 숫자가 2자리 오는 패턴&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;정규표현식에서 &lt;code&gt;.&lt;/code&gt; 은 new line 을 제외한 모든 문자 하나를 가리킨다. 즉 알파벳, 공백과 같은 특수문자, 숫자 모두 &lt;code&gt;.&lt;/code&gt; 로 표현할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;a.d&lt;/code&gt; : &lt;code&gt;aad&lt;/code&gt;, &lt;code&gt;abd&lt;/code&gt;, &lt;code&gt;acd&lt;/code&gt;, &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;aed&lt;/code&gt;, ..., &lt;code&gt;a1d&lt;/code&gt;, &lt;code&gt;a2d&lt;/code&gt;, &lt;code&gt;a3d&lt;/code&gt;, ..., &lt;code&gt;a d&lt;/code&gt;, etc&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;^&lt;/code&gt; 가 &lt;code&gt;[ ]&lt;/code&gt; 안에 들어오면 안에 나열되어 있는 문자를 제외한 다른 모든 문자를 나타낸다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[^a-z]&lt;/code&gt; : 알파벳 소문자를 제외한 모든 문자&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;특수문자는 항상 &lt;code&gt;\&lt;/code&gt; 와 같이 쓰여야 문자 그대로의 의미를 나타낸다. 예를 들어, 공백(Space)는 &lt;code&gt;\&lt;/code&gt; 로 Space 앞에 &lt;code&gt;\&lt;/code&gt; 를 붙여주면 된다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;^&lt;/code&gt; 는 문자열의 가장 처음을 의미한다. Vim 에서 &lt;code&gt;/^The&lt;/code&gt; 로 검색을 하게 되면 줄의 맨 처음에 위치한 The 만 찾게 된다. &lt;code&gt;[ ]&lt;/code&gt; 내에 있던 &lt;code&gt;^&lt;/code&gt; 과 다른 의미이다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$&lt;/code&gt; 는 문자열의 가장 마지막을 의미한다. &lt;code&gt;/today$&lt;/code&gt; 로 검색하면 줄의 마지막에 위치한 today 만 찾게 된다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;*&lt;/code&gt; 는 0번 이상의 반복을 의미한다. 만약 단순히 &lt;code&gt;[a-z]*&lt;/code&gt; 라고 검색하게 되면 전체 문서가 선택된다. &lt;code&gt;*&lt;/code&gt; 는 0번 이상을 뜻하기 때문에 모든 문자들이 이 조건을 만족하게 된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;a*&lt;/code&gt; : null string, a, aa, aaa, aaaa, etc&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ab*&lt;/code&gt; : b 라는 문자가 없을 수도 있고 한번 이상 올 수도 있다. &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;ab&lt;/code&gt;, &lt;code&gt;abb&lt;/code&gt;, &lt;code&gt;abbb&lt;/code&gt;, &lt;code&gt;abbbb&lt;/code&gt;, etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Extended Vim Regular Expression&lt;/h1&gt;
&lt;p&gt;기존의 Vi 정규표현식만으로는 표현할 수 있는 패턴에 한계가 있어서 Vim 에서는 몇가지 패턴이 추가되었다. 사실 이 추가된 내용도 다른 대부분의 프로그램이나 언어에서 지원하는 정규표현식이다. 다만, 이 추가적인 정규표현식을 Vim 에서 사용하려면 정규표현식 문법을 위한 각 문자 앞에 &lt;code&gt;\&lt;/code&gt; 을 붙여야 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;+&lt;/code&gt; : 1번 이상&lt;/li&gt;
&lt;li&gt;&lt;code&gt;?&lt;/code&gt; : 0번 혹은 1번&lt;/li&gt;
&lt;li&gt;&lt;code&gt;( )&lt;/code&gt; : 여러 문자들을 group 으로 만듬&lt;/li&gt;
&lt;li&gt;&lt;code&gt;|&lt;/code&gt; : 논리연산자 or 와 같은 역할&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt; &amp;gt;&lt;/code&gt; : 문자열의 범위를 한정&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{n,m}&lt;/code&gt; : n번 이상 m 번 이하 반복 (matching 되는 가능한 긴 길이의 문자열을 나타냄)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{n}&lt;/code&gt; : n번 반복&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{n,}&lt;/code&gt; : n번 이상 반복 (matching 되는 가능한 긴 길이의 문자열을 나타냄)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{,m}&lt;/code&gt; : m번 이하 반복 (matching 되는 가능한 긴 길이의 문자열을 나타냄)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{}&lt;/code&gt; : 0번 이상 반복 (&lt;code&gt;*&lt;/code&gt; 와 같음)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{-n, m}&lt;/code&gt; : n번 이상 m 번 이하 반복 (matching 되는 가능한 짧은 길이의 문자열을 나타냄)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{-n}&lt;/code&gt; : n번 반복&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{-n,}&lt;/code&gt; : n번 이상 반복 (matching 되는 가능한 짧은 길이의 문자열을 나타냄)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{-,m}&lt;/code&gt; : m번 이하 반복 (matching 되는 가능한 짧은 길이의 문자열을 나타냄)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{-}&lt;/code&gt; : 0번 이상 반복&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;예를 들면 아래와 같이 사용할 수 있다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ab\+&lt;/code&gt; : 반드시 b 라는 문자가 한번 이상 와야 한다. &lt;code&gt;ab&lt;/code&gt;, &lt;code&gt;abb&lt;/code&gt;, &lt;code&gt;abbb&lt;/code&gt;, &lt;code&gt;abbbb&lt;/code&gt;, etc.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ab\?&lt;/code&gt; : a 뒤에 b가 올 수도 오지 않을 수 도 있다. &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;ab&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\(abc\)*&lt;/code&gt; : abc 문자열이 0번 이상 반복된다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\(abc\)\+&lt;/code&gt; : abc 문자열이 1번 이상 반복된다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DEB\|GIT&lt;/code&gt; : DEB 또는 GIT 을 찾는다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GIT\(HUB\|TER\)&lt;/code&gt; : GIT 으로 시작되고 HUB 또는 TER 가 이어지는 문자열을 검색한다. 즉, GITHUB, GITTER 가 검색된다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\&amp;lt;abc\&amp;gt;&lt;/code&gt; : 정확하게 abc 인 것만 찾는다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\&amp;lt;GIT\(HUB\|TER\)\&amp;gt;&lt;/code&gt; : 정확하게 GITHUB, GITTER 인 것만 검색한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;S\{2,4}&lt;/code&gt; : S 가 2번 이상 4번 이하 반복되는 문자열을 검색한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A.\{}A&lt;/code&gt; : ASSSSASSSSASSSASSSSSA 라는 문자열이 있으면 문자열 전체가 패턴 매치되는 하나의 결과가 된다. &lt;code&gt;A.*A&lt;/code&gt; 와 같다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A.\{-}A&lt;/code&gt; : ASSSSASSSSASSSASSSSSA 라는 문자열이 있으면 처음 ASSSSA 는 패턴 매치되는 하나의 결과, 그 다음 SSSS 는 매치 되지 않는 문자열, 그 다음 ASSSA 는 패턴 매치되는 하나의 결과, 그 다음 SSSSSA 는 매치 되지 않는 문자열이 된다. 즉, 매치되는 최소 길이의 문자열을 찾는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Replace&lt;/h1&gt;
&lt;p&gt;Vim 은 검색과 동시에 치환도 가능하다 : &lt;code&gt;:&amp;lt;시작줄 번호&amp;gt;,&amp;lt;끝 번호&amp;gt; s/검색어/바꿀단어/옵션&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:1,10 s/The/the/gc&lt;/code&gt; : 1번째 줄에서 10번째 줄 사이에 있는 "The" 라는 단어를 "the"로 치환&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;g&lt;/code&gt; 라는 옵션은 모든 검색어에 대해 변경을 실시하게 해준다. 만약 &lt;code&gt;g&lt;/code&gt; 옵션이 없을 경우 한 줄에 2 개 이상의 The 가 있을 경우 첫 번째 &lt;code&gt;The&lt;/code&gt; 만 &lt;code&gt;the&lt;/code&gt; 로 변경을 하게 된다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;c&lt;/code&gt; 라는 옵션은 치환이 발생할 때마다 정말 치환할 것인지를 묻는 prompt 를 출력한다.&lt;/p&gt;
&lt;p&gt;이외에 줄 번호를 가리키는 특별한 문자가 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.&lt;/code&gt; : 현재 커서가 놓여 있는 줄의 번호 &lt;/li&gt;
&lt;li&gt;&lt;code&gt;$&lt;/code&gt; : 마지막 줄&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:.,$ s/The/the/g&lt;/code&gt; : 현재에서 마지막 줄까지 모든 &lt;code&gt;The&lt;/code&gt; 를 &lt;code&gt;the&lt;/code&gt; 로 치환&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:1,$ s/\&amp;lt;be\&amp;gt;/BE/g&lt;/code&gt; : 모든 줄에서 다른 단어에 포함되지 않은 &lt;code&gt;be&lt;/code&gt; 라는 단어를 검색하여 대문자 &lt;code&gt;BE&lt;/code&gt; 로 변경&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;또는 아래와 같이 한번에 전체 문서에 대해서 치환을 수행할 수도 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:%s/The/the/g&lt;/code&gt; : 현재에서 마지막 줄까지 모든 &lt;code&gt;The&lt;/code&gt; 를 &lt;code&gt;the&lt;/code&gt; 로 치환. &lt;code&gt;:1,$ s/The/the/g&lt;/code&gt; 와 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;정규표현식과 변수&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;( )&lt;/code&gt; 는 문자열을 하나의 단위로 보게 하는 역할을 하였다. 하지만 치환에 사용 될 경우 변수 역할도 하게 된다.&lt;/p&gt;
&lt;p&gt;정규표현식 &lt;code&gt;([a-z]+) ([0-9]+)&lt;/code&gt; 를 만족하는 문자열 &lt;code&gt;abcd 100&lt;/code&gt; 가 있을 때, 정규표현식에서는 각 &lt;code&gt;( )&lt;/code&gt; 을 하나의 단위로 묶으면서 &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt; 와 같은 변수에 대응을 시킨다. 즉, 첫 번째 &lt;code&gt;( )&lt;/code&gt; 는 &lt;code&gt;1&lt;/code&gt; 이라는 변수에, 두 번째 &lt;code&gt;( )&lt;/code&gt; 는 &lt;code&gt;2&lt;/code&gt; 라는 변수에 저장된다.&lt;/p&gt;
&lt;p&gt;정규표현식의 변수와 Vim 의 치환을 사용하여 앞 뒤 순서를 바꿀 수 있다 : &lt;code&gt;:1,$ s/\([a-z]\+\)\( \+\)\([0-9]\+\)/321/g&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;s/.../.../g&lt;/code&gt; 와 같은 치환 형식에서 찾을 문자열 부분은 세 개의 &lt;code&gt;( )&lt;/code&gt; 로 이루어져 있어서 각각 변수 &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt; 에 저장된다. 그리고 치환할 문자열 부분에서 &lt;code&gt;321&lt;/code&gt; 과 같이 반대 순서로 변수를 나열하여 각 문자열들의 순서를 변경할 수 있게 된다.&lt;/p&gt;</content><category term="vim"></category></entry><entry><title>Vim Configuration</title><link href="https://imjang57.github.io/garret/vim-configuration.html" rel="alternate"></link><published>2017-05-04T00:00:00+09:00</published><updated>2017-05-05T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-05-04:/garret/vim-configuration.html</id><summary type="html">&lt;p&gt;Vim 설정&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Vim Configuration&lt;/h1&gt;
&lt;p&gt;Vim 은 실행 중에 여러 설정들을 필요에따라 바꿔서 사용할 수 있다. 그리고 설정 파일을 생성하여 원하는 설정을 적용할 수도 있다.&lt;/p&gt;
&lt;p&gt;Vim 설정 파일은 보통 &lt;code&gt;.vimrc&lt;/code&gt; 라는 이름으로 생성되는데, 사용자의 Home 밑에 &lt;code&gt;~/.vimrc&lt;/code&gt; 로 생성하면 Vim 이 자동으로 이 파일을 찾아서 파일이 있으면 파일의 내용을 확인하여 설정을 적용한다.&lt;/p&gt;
&lt;h2&gt;Key mapping&lt;/h2&gt;
&lt;p&gt;Vim 에서 Key mapping 할 때 &lt;code&gt;map&lt;/code&gt; 또는 &lt;code&gt;noremap&lt;/code&gt; 을 사용하게 된다.&lt;/p&gt;
&lt;p&gt;Vim 에서 &lt;code&gt;:map j gg&lt;/code&gt; 를 실행하면 &lt;code&gt;j&lt;/code&gt; 가 &lt;code&gt;gg&lt;/code&gt; 로 mapping 되어서 &lt;em&gt;Normal mode&lt;/em&gt; 에서 &lt;code&gt;j&lt;/code&gt; 를 입력하면 &lt;code&gt;gg&lt;/code&gt; 가 실행된다.&lt;/p&gt;
&lt;p&gt;만약 &lt;code&gt;:map j gg&lt;/code&gt;, &lt;code&gt;:map Q j&lt;/code&gt; 를 실행하면 &lt;code&gt;j&lt;/code&gt; 를 눌러도, &lt;code&gt;Q&lt;/code&gt; 를 눌러도 &lt;code&gt;gg&lt;/code&gt; 가 실행된다. &lt;code&gt;Q&lt;/code&gt; 가 &lt;code&gt;j&lt;/code&gt; 로 mapping 되고, 다시 &lt;code&gt;j&lt;/code&gt; 가 &lt;code&gt;gg&lt;/code&gt; 로 mapping 되는 것이다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;:map j gg&lt;/code&gt;, &lt;code&gt;:map Q j&lt;/code&gt;, &lt;code&gt;:map gg Q&lt;/code&gt; 와 같이 무한으로 재귀적으로 참조하게 되면 오류가 발생한다. &lt;code&gt;map&lt;/code&gt; 은 recursive key mapping 을 하기 때문이다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;:map&lt;/code&gt; 과 반대로 &lt;code&gt;:noremap&lt;/code&gt; 은 non-recursive key mapping 이다. &lt;code&gt;:map j gg&lt;/code&gt;, &lt;code&gt;:map Q j&lt;/code&gt;, &lt;code&gt;:map gg Q&lt;/code&gt; 를 해도 오류가 발생하지 않는다. &lt;code&gt;Q&lt;/code&gt; 를 누르면 &lt;code&gt;j&lt;/code&gt; 를 누른 것과 같다. 한 번 key mapping 하여 변환되면 끝이다.&lt;/p&gt;
&lt;p&gt;Vim 은 또한 각 mode 별로 key mapping 을 설정할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;nmap&lt;/code&gt; : display normal mode maps&lt;/li&gt;
&lt;li&gt;&lt;code&gt;imap&lt;/code&gt; : display insert mode maps&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vmap&lt;/code&gt; : display visual and select mode maps&lt;/li&gt;
&lt;li&gt;&lt;code&gt;smap&lt;/code&gt; : display select mode maps&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xmap&lt;/code&gt; : display visual mode maps&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cmap&lt;/code&gt; : display command-line mode maps&lt;/li&gt;
&lt;li&gt;&lt;code&gt;omap&lt;/code&gt; : display operator pending mode maps&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;예를 들어, &lt;code&gt;:nnoremap g gg&lt;/code&gt; 를 실행하면 &lt;em&gt;Normal mode&lt;/em&gt; 에서 &lt;code&gt;g&lt;/code&gt; 를 누르면 &lt;code&gt;gg&lt;/code&gt; 로 non-recursive mapping 을 한다.&lt;/p&gt;
&lt;p&gt;key mapping 을 할 때 특수 기능 키에 대해 mapping 을 하려면 아래 내용을 참고하여 mapping 하자.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;BS&amp;gt;&lt;/code&gt; : Backspace&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Tab&amp;gt;&lt;/code&gt; : Tab&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;CR&amp;gt;&lt;/code&gt; : Enter&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Enter&amp;gt;&lt;/code&gt; : Enter&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Return&amp;gt;&lt;/code&gt; : Enter&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Esc&amp;gt;&lt;/code&gt; : Escape&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Space&amp;gt;&lt;/code&gt; : Space&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Up&amp;gt;&lt;/code&gt; : Up arrow&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Down&amp;gt;&lt;/code&gt; : Down arrow&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Left&amp;gt;&lt;/code&gt; : Left arrow&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Right&amp;gt;&lt;/code&gt; : Right arrow&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;F1&amp;gt;&lt;/code&gt; - &lt;code&gt;&amp;lt;F12&amp;gt;&lt;/code&gt; : Function keys 1 to 12&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#1&lt;/code&gt;, &lt;code&gt;#2&lt;/code&gt; .. &lt;code&gt;#9&lt;/code&gt;, &lt;code&gt;#0&lt;/code&gt; : Function keys F1 to F9, F10&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Insert&amp;gt;&lt;/code&gt; : Insert&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Del&amp;gt;&lt;/code&gt; : Delete&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Home&amp;gt;&lt;/code&gt; : Home&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;End&amp;gt;&lt;/code&gt; : End&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;PageUp&amp;gt;&lt;/code&gt; : Page-Up&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;PageDown&amp;gt;&lt;/code&gt; : Page-Down&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;만약 &lt;code&gt;:imap ,&amp;lt;Space&amp;gt; &amp;lt;Space&amp;gt;&amp;lt;Space&amp;gt;&amp;lt;Space&amp;gt;&amp;lt;Space&amp;gt;&lt;/code&gt; 와 같이 key mapping 을 하면, &lt;code&gt;,&amp;lt;Space&amp;gt;&lt;/code&gt; 를 입력할 때마다 4개의 Space 가 입력된다.&lt;/p&gt;
&lt;p&gt;key mapping 에 대한 자세한 내용은 &lt;code&gt;:help key-mapping&lt;/code&gt; 또는 &lt;a href="http://vim.wikia.com/wiki/Mapping_keys_in_Vim_-_Tutorial_%28Part_1%29"&gt;Mapping keys in Vim - Tutorial (Part 1)&lt;/a&gt; 을 참고하자.&lt;/p&gt;
&lt;h2&gt;&lt;leader&gt; key&lt;/h2&gt;
&lt;p&gt;Vim 에는 leader key 가 있다. Default 로 &lt;code&gt;\&lt;/code&gt; 가 leader key 로 되어 있는데, 설정에서 이 leader key 를 이용하여 많은 작업들에 대한 단축키를 생성할 수 있다.&lt;/p&gt;
&lt;p&gt;예를 들어, &lt;code&gt;:map &amp;lt;leader&amp;gt;A g&lt;/code&gt; 를 실행하면  &lt;code&gt;\A&lt;/code&gt; 를 입력했을 때 &lt;code&gt;g&lt;/code&gt; 를 실행한 것과 같은 결과를 얻을 수 있게 된다. 이때 leader key 를 누른 후 1초 내에 다음 key 를 입력해야 한다.&lt;/p&gt;
&lt;p&gt;leader key 를 &lt;code&gt;,&lt;/code&gt; 로 변경하려면 &lt;code&gt;:let mapleader=","&lt;/code&gt; 를 실행한다.&lt;/p&gt;
&lt;h1&gt;My &lt;code&gt;.vimrc&lt;/code&gt; file&lt;/h1&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="c"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;Belows are basic vim configurations&lt;/span&gt;
&lt;span class="c"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;Refer `:help quickref` (quickref.txt)&lt;/span&gt;
&lt;span class="nb"&gt;syntax&lt;/span&gt; &lt;span class="k"&gt;on&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="k"&gt;nu&lt;/span&gt;                   &lt;span class="c"&gt;&amp;quot;line numbers&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;tabstop&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="m"&gt;4&lt;/span&gt;            &lt;span class="c"&gt;&amp;quot;tab stop&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;softtabstop&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="m"&gt;4&lt;/span&gt;        &lt;span class="c"&gt;&amp;quot;soft tabstop&lt;/span&gt;
&lt;span class="c"&gt;&amp;quot;set expandtab            &amp;quot;soft tab: fill tab with blank characters(space)&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;shiftwidth&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="m"&gt;4&lt;/span&gt;         &lt;span class="c"&gt;&amp;quot;tab stop for &amp;#39;&amp;gt;&amp;#39; command&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;autoindent&lt;/span&gt;           &lt;span class="c"&gt;&amp;quot;Auto indentation&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;cindent&lt;/span&gt;              &lt;span class="c"&gt;&amp;quot;The C programming language indentation&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;smartindent&lt;/span&gt;          &lt;span class="c"&gt;&amp;quot;smart autoindenting for C programs&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="k"&gt;history&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="m"&gt;100&lt;/span&gt;          &lt;span class="c"&gt;&amp;quot;remember work history&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;hlsearch&lt;/span&gt;             &lt;span class="c"&gt;&amp;quot;hilighting search word&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;showmatch&lt;/span&gt;            &lt;span class="c"&gt;&amp;quot;hilighting matched parentheses : (),{}&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;ruler&lt;/span&gt;                &lt;span class="c"&gt;&amp;quot;show current cursor&amp;#39;s location at lower right side&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;showmode&lt;/span&gt;             &lt;span class="c"&gt;&amp;quot;To be able to see what mode you are in.&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;laststatus&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;         &lt;span class="c"&gt;&amp;quot;always show status bar&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;nobackup&lt;/span&gt;             &lt;span class="c"&gt;&amp;quot;don&amp;#39;t create backup file&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;relativenumber&lt;/span&gt;
&lt;span class="c"&gt;&amp;quot;&amp;quot;set backup               &amp;quot;create backup file&lt;/span&gt;
&lt;span class="c"&gt;&amp;quot;set backupdir=~/vim/backup &amp;quot;set directory where backup file is saved&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;nocompatible&lt;/span&gt;         &lt;span class="c"&gt;&amp;quot;be improved, required&lt;/span&gt;
&lt;span class="k"&gt;colorscheme&lt;/span&gt; desert
&lt;span class="c"&gt;&amp;quot;colorscheme evening&lt;/span&gt;


&lt;span class="c"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="c"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;belows are settings for gvim running on high resolution&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;guifont&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;Consolas:h11:cANSI
&lt;span class="c"&gt;&amp;quot;set guifontwide=Dotumche:h11:cDEFAULT&lt;/span&gt;


&lt;span class="c"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="c"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;belows are encoding configurations&lt;/span&gt;
&lt;span class="c"&gt;&amp;quot;auto detected file encoding list which is used when vim opens file&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;fencs&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;utf&lt;span class="m"&gt;-8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;euc&lt;span class="p"&gt;-&lt;/span&gt;kr&lt;span class="p"&gt;,&lt;/span&gt;cp949&lt;span class="p"&gt;,&lt;/span&gt;cp932&lt;span class="p"&gt;,&lt;/span&gt;euc&lt;span class="p"&gt;-&lt;/span&gt;jp&lt;span class="p"&gt;,&lt;/span&gt;shift&lt;span class="p"&gt;-&lt;/span&gt;jis&lt;span class="p"&gt;,&lt;/span&gt;big5&lt;span class="p"&gt;,&lt;/span&gt;latin1&lt;span class="p"&gt;,&lt;/span&gt;ucs&lt;span class="m"&gt;-2&lt;/span&gt;le
&lt;span class="c"&gt;&amp;quot;Use command :set fileencoding=utf-8 when you change current file&amp;#39;s encoding&lt;/span&gt;


&lt;span class="c"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="c"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;belows are key mappings&lt;/span&gt;
&lt;span class="nb"&gt;nnoremap&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;leader&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;&lt;span class="k"&gt;q&lt;/span&gt; :&lt;span class="k"&gt;bp&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nb"&gt;nnoremap&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;leader&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;&lt;span class="k"&gt;w&lt;/span&gt; :&lt;span class="k"&gt;bn&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nb"&gt;nnoremap&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;silent&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;Leader&lt;span class="p"&gt;&amp;gt;+&lt;/span&gt; :exe &lt;span class="s2"&gt;&amp;quot;resize &amp;quot;&lt;/span&gt; . &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;winheight&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; * &lt;span class="m"&gt;3&lt;/span&gt;/&lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nb"&gt;nnoremap&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;silent&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;Leader&lt;span class="p"&gt;&amp;gt;-&lt;/span&gt; :exe &lt;span class="s2"&gt;&amp;quot;resize &amp;quot;&lt;/span&gt; . &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;winheight&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; * &lt;span class="m"&gt;2&lt;/span&gt;/&lt;span class="m"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Vim 일반 설정 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;set nocompatible&lt;/code&gt; : vi 호환성을 위한 기능을 사용하지 않는다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;syntax on&lt;/code&gt; : syntax highlighing 을 사용한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set nu&lt;/code&gt; : 왼쪽에 line number 를 보여준다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set tabstop=4&lt;/code&gt; : tab size 를 4로 지정한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set softtabstop=4&lt;/code&gt; : tab size 를 4로 지정한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set shiftwidth=4&lt;/code&gt; : tab size 를 4로 지정한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set expandtab&lt;/code&gt; : tag 을 space 로 사용하도록 한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set relativenumber&lt;/code&gt; : line number 를 현재 위치한 line 에서 상대적인 값으로 보여준다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set hlsearch&lt;/code&gt; : &lt;code&gt;/&lt;/code&gt; 로 검색할 때 검색된 문자열에 highlight 를 해준다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set ignorecase&lt;/code&gt; : &lt;code&gt;/&lt;/code&gt; 로 검색할 때 대소문자를 구분하지 않는다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set autoindent&lt;/code&gt; : 새로운 line 을 입력할 때 자동으로 indent 를 적용한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set cindent&lt;/code&gt; : 새로운 line 을 입력할 때 C style 의 indent 를 적용한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set smartindent&lt;/code&gt; : &lt;/li&gt;
&lt;li&gt;&lt;code&gt;set showmode&lt;/code&gt; : 현재 어떤 mode 인지를 status bar 에 보여준다.(NORMAL, INSERT, VISUAL, etc)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set nobackup&lt;/code&gt; : 파일을 열어서 buffer 를 생성할 때 backup 파일을 만들지 않는다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set ruler&lt;/code&gt; : 현재 cursor 의 위치를 하단에 있는 status bar 의 오른쪽에 보여준다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set history=100&lt;/code&gt; : 100 개의 work history 를 저장한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set showmatch&lt;/code&gt; : &lt;code&gt;(&lt;/code&gt; 와 &lt;code&gt;)&lt;/code&gt;, &lt;code&gt;{&lt;/code&gt; 와 &lt;code&gt;}&lt;/code&gt; 등 matched parentheses 에 hlghlight 적용한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set colorscheme evening&lt;/code&gt; : evening color theme 를 사용한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set fences=utf-8,euc-kr,cp949,latin1&lt;/code&gt; : vim 이 파일을 열 때 자동으로 인식할 file encoding 목록을 지정한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Vim key 설정 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;let mapleader = ","&lt;/code&gt; : leader key 를 '\' 에서 ',' 로 변경한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nnoremap &amp;lt;leader&amp;gt;q :bp&amp;lt;CR&amp;gt;&lt;/code&gt; : &lt;code&gt;&amp;lt;leader key&amp;gt; + q&lt;/code&gt; 를 누르면 previous buffer 로 이동한다. &lt;code&gt;:bp&lt;/code&gt; 명령과 같은 일을 한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nnoremap &amp;lt;leader&amp;gt;w :bn&amp;lt;CR&amp;gt;&lt;/code&gt; : &lt;code&gt;&amp;lt;leader key&amp;gt; + w&lt;/code&gt; 를 누르면 next buffer 로 이동한다. &lt;code&gt;:bn&lt;/code&gt; 명령과 같은 일을 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;References&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://jaeheeship.github.io/console/2013/11/15/vimrc-configuration.html"&gt;vim 설정파일 알아보기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://vim.wikia.com/wiki/Mapping_keys_in_Vim_-_Tutorial_%28Part_1%29"&gt;Mapping keys in Vim - Tutorial (Part 1)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="vim"></category></entry><entry><title>Vim Basics</title><link href="https://imjang57.github.io/garret/vim-basics.html" rel="alternate"></link><published>2017-05-03T00:00:00+09:00</published><updated>2017-05-04T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-05-03:/garret/vim-basics.html</id><summary type="html">&lt;p&gt;Vim 기본 사용법&lt;/p&gt;</summary><content type="html">&lt;h1&gt;VIM (VI Improved)&lt;/h1&gt;
&lt;p&gt;이 문서는 Vim 의 가장 기본적인 사용법을 정리한 문서이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Web page : http://www.vim.org&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CLI(Command Line Interface) 기반의 Text editor 이다. Linux, Mac, Windows 모두 지원한다. 처음 사용법이 익숙해지기가 어렵지만 한번 익히면 마우스 없이 대부분의 작업들을 빠르게 수행할 수 있다. 리눅스 서버는 대부분 CLI 환경만 제공되기 때문에 리눅스 서버 관리자라면 거의 필수로 익혀야 하는 Text editor 이다.&lt;/p&gt;
&lt;p&gt;Vimscript 라는 것을 작성하여 플러그인을 만들 수 있다. 사용법을 손에 익히고 여러 플러그인을 설치하면 왠만한 IDE 뺨치는 기능을 사용할 수 있다.&lt;/p&gt;
&lt;h1&gt;Vim modes&lt;/h1&gt;
&lt;p&gt;Vim 은 여러가지 모드를 제공한다. 대표적으로 사용되는 모드는 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Normal mode&lt;/em&gt; : where you can execute commands. This is default mode in which Vim starts up.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Insert mode&lt;/em&gt; : where you are simply writing text.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Visual mode&lt;/em&gt; : where you visually select a bunch of text so that you can run a command or operation only on that part of the text.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Vim 을 실행하면 가장 먼저 &lt;em&gt;Normal mode&lt;/em&gt; 상태로 실행된다. 다른 모드에서 &lt;code&gt;ESC&lt;/code&gt; 를 입력하면 &lt;em&gt;Normal mode&lt;/em&gt; 로 돌아온다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Normal mode&lt;/em&gt; 에서 &lt;code&gt;:&lt;/code&gt; 를 입력하면 Command 를 입력할 수 있다. 보통 Command 를 실행할 때 2가지 방법으로 하게 되는데 하나는 &lt;code&gt;:&lt;/code&gt; 를 입력한 후 Command 를 직접 입력하는 것이고, 다른 하나는 단축키를 사용하는 것이다. 2가지 모두 많이 사용되는 방법이다.&lt;/p&gt;
&lt;p&gt;커서 이동, put, yank, delete, search, replace, 기타 등등 대부분의 작업은 &lt;em&gt;Normal mode&lt;/em&gt; 에서 실행된다.&lt;/p&gt;
&lt;h1&gt;Help page&lt;/h1&gt;
&lt;p&gt;Vim 은 기본적으로 built-in help documentation 을 내장하고 있어서 작업 도중에 수시로 help documentation 을 참고할 수 있다.&lt;/p&gt;
&lt;p&gt;Normal mode 에서 &lt;code&gt;:help&lt;/code&gt; command 를 실행하면 확인할 수 있다. 자주 보게 되는 help 내용은 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:help [keyword]&lt;/code&gt; : shows documentation [for keyword]&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:help abbreviation&lt;/code&gt; : help for abbreviations&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:help quickref&lt;/code&gt; : Quick Reference&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:help user-manual&lt;/code&gt; : User Manuals&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;만약 플러그인을 설치할 때 플러그인이 help 를 제공하면 해당 플러그인의 help 문서도 확인가능하다.&lt;/p&gt;
&lt;h1&gt;Switching between modes&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Normal mode&lt;/em&gt; --(&lt;code&gt;i&lt;/code&gt;, &lt;code&gt;I&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;o&lt;/code&gt;, &lt;code&gt;O&lt;/code&gt;, &lt;code&gt;r&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt;)--&amp;gt; Insert mode&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Normal mode&lt;/em&gt; --(&lt;code&gt;v&lt;/code&gt;, &lt;code&gt;V&lt;/code&gt;)--&amp;gt; Visual mode&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Insert mode&lt;/em&gt; --(&lt;code&gt;ESC&lt;/code&gt;)--&amp;gt; Normal mode&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Visual mode&lt;/em&gt; --(&lt;code&gt;ESC&lt;/code&gt;)--&amp;gt; Normal mode&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Move cursor&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;move left / up / right / down : &lt;code&gt;h&lt;/code&gt; / &lt;code&gt;j&lt;/code&gt; / &lt;code&gt;k&lt;/code&gt; / &lt;code&gt;l&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;move left / up / right / down 3 times repeatedly : &lt;code&gt;3h&lt;/code&gt; / &lt;code&gt;3j&lt;/code&gt; / &lt;code&gt;3k&lt;/code&gt; / &lt;code&gt;3l&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;move the cursor to the next word : &lt;code&gt;w&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;move the cursor to the previous word : &lt;code&gt;b&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;go to specific line number : &lt;code&gt;&amp;lt;line-number&amp;gt;G&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;go to head of line : &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;go to tail of line : &lt;code&gt;$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;page up / down : &lt;code&gt;ctrl + b&lt;/code&gt; / &lt;code&gt;ctrl + f&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;page up / down half : &lt;code&gt;ctrl + d&lt;/code&gt; / &lt;code&gt;ctrl + u&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;jump to start of file : &lt;code&gt;gg&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;jump to end of file : &lt;code&gt;G&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;jump to top / bottom / middle of window : &lt;code&gt;H&lt;/code&gt; / &lt;code&gt;L&lt;/code&gt; / &lt;code&gt;M&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;move to previous / next sentence : &lt;code&gt;(&lt;/code&gt; / &lt;code&gt;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;move to previous / next paragraph : &lt;code&gt;{&lt;/code&gt; / &lt;code&gt;}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Editing&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;insert before the curosr : &lt;code&gt;i&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;insert at the beginning of the line : &lt;code&gt;I&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;insert (append) after the cursor : &lt;code&gt;a&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;insert (append) at the End of the line : &lt;code&gt;A&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;append (open) a new line below the current line : &lt;code&gt;o&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;append (open) a new line above the current line : &lt;code&gt;O&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;replace a single character : &lt;code&gt;r&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;replace from current cursor : &lt;code&gt;R&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;join line below to the current one : &lt;code&gt;J&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;exit &lt;em&gt;Insert mode&lt;/em&gt; (swith to &lt;em&gt;Normal mode&lt;/em&gt;) : &lt;code&gt;ESC&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Open and Close file&lt;/h1&gt;
&lt;p&gt;Vim 에서 파일을 열면 &lt;em&gt;buffer&lt;/em&gt; 라는 것을 생성하여 파일의 내용을 메모리에 올린 후 작업을 수행하게 된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Open file (buffer) : &lt;code&gt;:e &amp;lt;path&amp;gt;&lt;/code&gt;, &lt;code&gt;:edit &amp;lt;path&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Save file (buffer) : &lt;code&gt;:w&lt;/code&gt;, &lt;code&gt;:write&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Save file (buffer) as : &lt;code&gt;:saveas &amp;lt;path&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Close file (buffer) : &lt;code&gt;:bd&lt;/code&gt;, &lt;code&gt;:bw&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Quit Vim : &lt;code&gt;:q&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Print Working Directory : &lt;code&gt;:pwd&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Print path of current file : &lt;code&gt;:echo @%&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Print absolute path of current file : &lt;code&gt;echo expand('%:p')&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Use Mark&lt;/h1&gt;
&lt;p&gt;Vim 에서 &lt;em&gt;buffer&lt;/em&gt; 의 특정 위치를 alphabet(a-zA-Z) 으로 마킹할 수 있다. 자세한 내용은 &lt;code&gt;:help mark&lt;/code&gt; 와 &lt;code&gt;:help mark-motions&lt;/code&gt; help page 를 참고하자.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mark current location as a : &lt;code&gt;ma&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;goto mark a : &lt;code&gt;'a&lt;/code&gt; (cursor located on first non-blank character), `a (cursor located on marked character)&lt;/li&gt;
&lt;li&gt;list of marks : &lt;code&gt;:marks&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Abbreviation&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;set abbreviation foo with foooo : &lt;code&gt;:ab foo foooo&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;unset abbreviation foo : &lt;code&gt;:unab foo&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;위의 예의 경우, &lt;em&gt;Insert mode&lt;/em&gt;  에서 foo 와 &lt;SPACEBAR|ENTER&gt; 를 입력하면 foooo 가 입력된다.&lt;/p&gt;
&lt;h1&gt;Cut (Delete), Copy (Yank) and Paste (Put)&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;cut (delete) word : &lt;code&gt;dw&lt;/code&gt; (start from cursor), &lt;code&gt;daw&lt;/code&gt; (whole word)&lt;/li&gt;
&lt;li&gt;cut (delete) current line : &lt;code&gt;dd&lt;/code&gt;, &lt;code&gt;:d&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;cut (delete) 4 lines : &lt;code&gt;4dd&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;cut (delete) to the end of the line : &lt;code&gt;d$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;cut (delete) from cursor to end of current line : &lt;code&gt;D&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;cut (delete) one character of cursor : &lt;code&gt;x&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;cut (delete) one character before cursor : &lt;code&gt;X&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;cut (delete) 3 character of cursor : &lt;code&gt;3x&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;cut (delete) 3 character before cursor : &lt;code&gt;3X&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;cut (delete) lines from 4 to 10 inclusive : &lt;code&gt;:4,10d&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;copy (yank) word : &lt;code&gt;yw&lt;/code&gt; (start from cursor), &lt;code&gt;yaw&lt;/code&gt; (whole word)&lt;/li&gt;
&lt;li&gt;copy (yank) current line : &lt;code&gt;yy&lt;/code&gt;, &lt;code&gt;Y&lt;/code&gt;, &lt;code&gt;:y&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;copy (yank) 4 lines : &lt;code&gt;4yy&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;copy (yank) lines from 4 to 10 inclusive : &lt;code&gt;:4,10y&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;paste (put) at after current : &lt;code&gt;p&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;paste (put) at before current : &lt;code&gt;P&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;cut (delete) from current line to end of text : &lt;code&gt;dG&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;cut (delete) from current line to start of text : &lt;code&gt;dgg&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Undo and Redo&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;undo : &lt;code&gt;u&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;redo : &lt;code&gt;ctrl + r&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Select&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;swith to visual mode to select texts : &lt;code&gt;v&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;swith to visual mode to select line by line : &lt;code&gt;V&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;swith to visual mode to select vertical : &lt;code&gt;Ctrl + v&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can select texts in visual mode using vi move keys such as &lt;code&gt;h&lt;/code&gt;, &lt;code&gt;j&lt;/code&gt;, &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;l&lt;/code&gt;, &lt;code&gt;G&lt;/code&gt;, &lt;code&gt;gg&lt;/code&gt;, &lt;code&gt;w&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;H&lt;/code&gt;, &lt;code&gt;L&lt;/code&gt;, &lt;code&gt;M&lt;/code&gt;, etc. After selection, you can use &lt;code&gt;d&lt;/code&gt; for cut, &lt;code&gt;y&lt;/code&gt; for copy, etc.&lt;/p&gt;
&lt;h1&gt;Search&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;search text : &lt;code&gt;/searchtext&lt;/code&gt; in &lt;em&gt;Normal mode&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you want to search text &lt;em&gt;Hotkeys&lt;/em&gt;, input &lt;code&gt;/Hotkeys&lt;/code&gt;. Searching text is case-sensitive. If you want to ignore case, input &lt;code&gt;:set ignorecase&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;After run &lt;code&gt;/searchtext&lt;/code&gt; command, you can move to next and previous occurrence by &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Vim provide incremental search. This is helpful when you know only a part of the phrase. After &lt;code&gt;:set incsearch&lt;/code&gt;, vim will start searching by everytime you type.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;searchtext&lt;/code&gt; can be regular expression. For example:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;delete lines which are matched to pattern : &lt;code&gt;:g/pattern/d&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;delete empty lines : &lt;code&gt;:g/^$/d&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;delete lines which are include hello : &lt;code&gt;:g/hello/d&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Macro&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;record macro as a : &lt;code&gt;qa&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;stop recording macro : &lt;code&gt;q&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;run macro a : &lt;code&gt;@a&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;rerun last run macro : &lt;code&gt;@@&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;References&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://vim.rtorr.com/"&gt;Vim Cheat Sheet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/rtorr/vim-cheat-sheet"&gt;Vim Cheat Sheet Github&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="vim"></category></entry><entry><title>Vim Basics More</title><link href="https://imjang57.github.io/garret/vim-basics-more.html" rel="alternate"></link><published>2017-05-03T00:00:00+09:00</published><updated>2017-05-04T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-05-03:/garret/vim-basics-more.html</id><summary type="html">&lt;p&gt;Vim 기본 사용법에 대해 더 알면 좋은 내용들에 대한 글이다.&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Vim Basics More&lt;/h1&gt;
&lt;p&gt;Vim 에 대해 추가적으로 알면 좋은 내용들에 대해 정리한 글이다.&lt;/p&gt;
&lt;h1&gt;&lt;em&gt;buffer&lt;/em&gt;, &lt;em&gt;window&lt;/em&gt;, &lt;em&gt;tab&lt;/em&gt;&lt;/h1&gt;
&lt;p&gt;Vim 에서 &lt;em&gt;buffer&lt;/em&gt;  는 열려 있는 파일(file which is opened)를 뜻한다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;window&lt;/em&gt; 는 Vim 이 어떤 것을 출력하기 위한 component 로 &lt;em&gt;buffer&lt;/em&gt; 를 출력하는 방법이다. 사실 Vim 의 &lt;em&gt;buffer&lt;/em&gt; 는 text 만 출력할 수 있는 것이 아니다. Vim 화면을 가로나 세로로 분할하면 이 &lt;em&gt;windows&lt;/em&gt; 가 새로 만들어 지고 각 &lt;em&gt;window&lt;/em&gt; 에 &lt;em&gt;buffer&lt;/em&gt; 가 출력된다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;tab&lt;/em&gt; 은 Vim 의 Layout 이다. 여러 &lt;em&gt;windows&lt;/em&gt; 들의 집합이다. 대부분의 Text editor 나 Internet browser 에서 사용하는 tab 과는 개념이 다르다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A buffer is the in-memory text of a file.&lt;/li&gt;
&lt;li&gt;A window is a viewport on a buffer.&lt;/li&gt;
&lt;li&gt;A tab page is a collection of windows.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;대충 간략하게 정리하면 파일은 &lt;em&gt;buffer&lt;/em&gt; 에 로드되고, &lt;em&gt;buffer&lt;/em&gt; 는 &lt;em&gt;window&lt;/em&gt; 에 의해 출력되고, &lt;em&gt;window&lt;/em&gt; 는 &lt;em&gt;tab&lt;/em&gt; 에 의해 layout 이 결정된다.&lt;/p&gt;
&lt;h2&gt;Vim &lt;em&gt;buffer&lt;/em&gt; management&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;list of current buffers : &lt;code&gt;:ls&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;open new file (buffer) : &lt;code&gt;:e &amp;lt;path&amp;gt;&lt;/code&gt;, &lt;code&gt;:edit &amp;lt;path&amp;gt;&lt;/code&gt; (with enhanced tab completion (put set wildmenu in your .vimrc))&lt;/li&gt;
&lt;li&gt;save file (buffer) : &lt;code&gt;:w&lt;/code&gt;, &lt;code&gt;:write&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;close file (buffer) : &lt;code&gt;:bd&lt;/code&gt;, &lt;code&gt;:bw&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;switch between all open files (buffers) : &lt;code&gt;:b&amp;lt;buffer number&amp;gt;&lt;/code&gt; (&lt;code&gt;:b#&lt;/code&gt; chooses the last visited file)&lt;/li&gt;
&lt;li&gt;previous buffer : &lt;code&gt;:bp&lt;/code&gt;, &lt;code&gt;:bprevious&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;next buffer : &lt;code&gt;:bn&lt;/code&gt;, &lt;code&gt;:bnext&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;delete buffer : &lt;code&gt;:bd [buffer numbers...]&lt;/code&gt;, &lt;code&gt;:bw&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Close all buffer : &lt;code&gt;:%bd&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Close buffer from buffer number 1 to 1000 : &lt;code&gt;:1,1000bd&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;:ls&lt;/code&gt; 를 실행하면 Vim 의 하단에 다음과 같이 현재 열려진 &lt;em&gt;buffer&lt;/em&gt; 들을 보여준다. 아래 화면에서 &lt;em&gt;buffer&lt;/em&gt; 를 선택하여 이동할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;1 %a   &amp;quot;./checkin.pl&amp;quot;            line 1
2 #    &amp;quot;./grabakamailogs.pl&amp;quot;     line 1
3      &amp;quot;./grabwmlogs.pl&amp;quot;         line 0
  etc.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;%&lt;/code&gt; 는 현재 편집 중인 &lt;em&gt;buffer&lt;/em&gt; (current buffer) 를 참조한다. &lt;code&gt;#&lt;/code&gt; 는 직전에 편집하던 &lt;em&gt;buffer&lt;/em&gt; (alternative buffer) 를 참조한다. &lt;code&gt;ctrl + shift + 6&lt;/code&gt; 를 실행하면 두 &lt;em&gt;buffer&lt;/em&gt; 사이를 switch 한다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;e &amp;lt;path&amp;gt;&lt;/code&gt; 를 실행하면 새로운 &lt;em&gt;buffer&lt;/em&gt; 를 만들고 전달 받은 파일의 내용을 로드한다. &lt;code&gt;:e foo.txt bar.txt&lt;/code&gt;, &lt;code&gt;e /foo/bar/*.txt&lt;/code&gt; 와 같이 한 번에 여러 &lt;em&gt;buffer&lt;/em&gt; 를 생성하지는 못한다. 만약, 여러 파일을 한 번에 열고 싶으면 처음에 Vim 을 실행할 때 &lt;code&gt;Vim file1.txt file2.txt&lt;/code&gt; 와 같이 실행하면 된다. 아니면 &lt;code&gt;arga [paths...]&lt;/code&gt; 를 실행하면 여러 파일들로 새로운 &lt;em&gt;buffer&lt;/em&gt; 를 생성하고 대신 새로운 &lt;em&gt;buffer&lt;/em&gt; 로 switch 를 하지는 않는다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;:arga foo.txt bar.txt
:argadd /foo/bar/*.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Install &lt;em&gt;BufOnly&lt;/em&gt; plugin&lt;/h2&gt;
&lt;p&gt;Vim 으로 &lt;em&gt;buffer&lt;/em&gt; 를 사용하다보면 불편할 때가 있는데, 예를 들면 지금 편집중인 &lt;em&gt;buffer&lt;/em&gt; 를 빼고 나머지 &lt;em&gt;buffer&lt;/em&gt; 들을 모두 닫고 싶을 때이다. &lt;code&gt;:ls&lt;/code&gt; 로 현재 생성되어 있는 &lt;em&gt;buffer&lt;/em&gt; 를 확인하고 &lt;code&gt;bd &amp;lt;buffer number&amp;gt;&lt;/code&gt; 로 일일이 하나씩 &lt;em&gt;buffer&lt;/em&gt; 를 삭제해야 한다. 그래서 나는 &lt;em&gt;BufOnly&lt;/em&gt; 라는 plugin 을 설치해서 사용한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Download &lt;code&gt;BufOnly.vim&lt;/code&gt; Vimscript at &lt;a href="http://www.vim.org/scripts/script.php?script_id=1071"&gt;BufOnly page&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Goto &lt;code&gt;$VIMRUNTIME&lt;/code&gt; : &lt;code&gt;:echo $VIMRUNTIME&lt;/code&gt;, &lt;code&gt;:!explorer $VIMRUNTIME&lt;/code&gt; in Vim.&lt;/li&gt;
&lt;li&gt;Copy downloaded &lt;code&gt;BufOnly.vim&lt;/code&gt; to &lt;code&gt;$VIMRUNTIME&lt;/code&gt; directory or &lt;code&gt;~/.vim/plugin/BufOnly.vim&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Restart Vim&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;참고로 &lt;code&gt;$VIMRUNTIME&lt;/code&gt; 은 Vim 실행 후 &lt;em&gt;Normal mode&lt;/em&gt; 에서 &lt;code&gt;:echo $VIMRUNTIME&lt;/code&gt; 으로 확인할 수 있으며 Vim 이 실행되는 root path 이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;close buffers : &lt;code&gt;:BufOnly [buffer number]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Vim &lt;em&gt;window&lt;/em&gt; management&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;split window horizontal : &lt;code&gt;:sp [path]&lt;/code&gt;, &lt;code&gt;:split [path]&lt;/code&gt;, &lt;code&gt;Ctrl + w, s&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;split window vertical : &lt;code&gt;vs [path]&lt;/code&gt;, &lt;code&gt;:vertical split [path]&lt;/code&gt;, &lt;code&gt;Ctrl + w, v&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;resize all windows same : &lt;code&gt;Ctrl - w, =&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;resize horizontal : &lt;code&gt;:resize 60&lt;/code&gt;, &lt;code&gt;:res 60&lt;/code&gt;, &lt;code&gt;:resize +5&lt;/code&gt;, &lt;code&gt;:res +5&lt;/code&gt;, &lt;code&gt;:resize -5&lt;/code&gt;, &lt;code&gt;:res -5&lt;/code&gt;, &lt;code&gt;ctrl + w, +&lt;/code&gt;, &lt;code&gt;ctrl + w, -&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;resize vertical :  &lt;code&gt;:vertical resize 60&lt;/code&gt;, &lt;code&gt;:vertical res 60&lt;/code&gt;, &lt;code&gt;:vertical resize +5&lt;/code&gt;, &lt;code&gt;:vertical res +5&lt;/code&gt;, &lt;code&gt;:vertical resize -5&lt;/code&gt;, &lt;code&gt;:vertical res -5&lt;/code&gt;, &lt;code&gt;ctrl + w, &amp;gt;&lt;/code&gt;, &lt;code&gt;ctrl + w, &amp;lt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;switch between splitscreens : &lt;code&gt;ctrl + w, arrow key&lt;/code&gt;, &lt;code&gt;ctrl + w, &amp;lt;h|j|k|l&amp;gt;&lt;/code&gt;, &lt;code&gt;ctrl + w, n&lt;/code&gt;, &lt;code&gt;ctrl + w, p&lt;/code&gt;, &lt;code&gt;ctrl + w, w&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;close the current window : &lt;code&gt;ctrl + w, c&lt;/code&gt;, &lt;code&gt;:q&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;close all windows except the current one : &lt;code&gt;ctrl + w, o&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To resize in different steps, you can create maps that will adjust the window size differently. For example to increase the window size by a factor of 1.5 and decrease the window size by 0.67, you can map this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;nnoremap &amp;lt;silent&amp;gt; &amp;lt;Leader&amp;gt;+ :exe &amp;quot;resize &amp;quot; . (winheight(0) * 3/2)&amp;lt;CR&amp;gt;
nnoremap &amp;lt;silent&amp;gt; &amp;lt;Leader&amp;gt;- :exe &amp;quot;resize &amp;quot; . (winheight(0) * 2/3)&amp;lt;CR&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Vim &lt;em&gt;tab&lt;/em&gt; management&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;add new tab : &lt;code&gt;:tabe &amp;lt;path&amp;gt;&lt;/code&gt;, &lt;code&gt;:tabedit &amp;lt;path&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;add buffer to tab : &lt;code&gt;:&amp;lt;tab number&amp;gt;tabe &amp;lt;path&amp;gt;&lt;/code&gt;, &lt;code&gt;:&amp;lt;tab number&amp;gt;tabedit &amp;lt;path&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;close tab : &lt;code&gt;:tabc&lt;/code&gt;, &lt;code&gt;:tabclose&lt;/code&gt;, &lt;code&gt;:&amp;lt;tab number&amp;gt;tabc&lt;/code&gt;, &lt;code&gt;:&amp;lt;tab number&amp;gt;tabclose&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;switch between tabs : &lt;code&gt;:tabn&lt;/code&gt;, &lt;code&gt;:tabnext&lt;/code&gt;, &lt;code&gt;:tabp&lt;/code&gt;, &lt;code&gt;:tabprevious&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;switch to next tab by number : &lt;code&gt;gt&lt;/code&gt;, &lt;code&gt;&amp;lt;number&amp;gt;gt&lt;/code&gt;, &lt;code&gt;ctrl + PageDown&lt;/code&gt;, &lt;code&gt;&amp;lt;number&amp;gt;ctrl + PageDown&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;switch to previous tab by number : &lt;code&gt;gT&lt;/code&gt;, &lt;code&gt;&amp;lt;number&amp;gt;gT&lt;/code&gt;, &lt;code&gt;ctrl + PageUp&lt;/code&gt;, &lt;code&gt;&amp;lt;number&amp;gt;ctrl + PageUp&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;go to tab : &lt;code&gt;:tabmove &amp;lt;tab number&amp;gt;&lt;/code&gt;, &lt;code&gt;:tabm &amp;lt;tab number&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you map &lt;code&gt;:tabn&lt;/code&gt; and &lt;code&gt;:tabp&lt;/code&gt; to your &lt;code&gt;F7&lt;/code&gt; and &lt;code&gt;F8&lt;/code&gt; keys you can easily switch between files.&lt;/p&gt;
&lt;h1&gt;Selection&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;- select : &lt;code&gt;v, [h|j|k|l|g|G|...]&lt;/code&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;- select vertical : &lt;code&gt;ctrl + v, [h|j|k|l|g|G|...]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1&gt;Indentation&lt;/h1&gt;
&lt;p&gt;In command mode,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;indent current line by shiftwidth spaces : &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;:&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;de-indent current line by shiftwidth spaces : &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;:&amp;lt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;re-indent current line : &lt;code&gt;==&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;indent 5 lines : &lt;code&gt;5&amp;gt;&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;de-indent 5 lines : &lt;code&gt;5&amp;lt;&amp;lt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;re-indent 5 lines : &lt;code&gt;5==&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;indent lines 4 to 8, inclusive : &lt;code&gt;:4,8&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;indent selected lines : Select lines and use &lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;increase indent of a curly-braces block : put cursor on one of the curly braces and use &lt;code&gt;&amp;gt;, %&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;decrease indent of a curly-braces block : put cursor on one of the curly braces and use &lt;code&gt;&amp;lt;, %&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;re-indent a curly-braces block : put cursor on one of the curly braces and use &lt;code&gt;=, %&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Paste text, aligning indentation with surroundings : &lt;code&gt;]p&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;re-indent entire buffer : &lt;code&gt;gg=G&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In insert mode,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;insert indent at start of line : &lt;code&gt;ctrl + t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;remove indent at start of line : &lt;code&gt;ctrl + d&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;vim settings in &lt;code&gt;.vimrc&lt;/code&gt; file for indentation:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;set expandtab       &amp;quot;Use softtabstop spaces instead of tab characters for indentation
set shiftwidth=4    &amp;quot;Indent by 4 spaces when using &amp;gt;&amp;gt;, &amp;lt;&amp;lt;, == etc.
set softtabstop=4   &amp;quot;Indent by 4 spaces when pressing &amp;lt;TAB&amp;gt;

set autoindent      &amp;quot;Keep indentation from previous line
set smartindent     &amp;quot;Automatically inserts indentation in some cases
set cindent         &amp;quot;Like smartindent, but stricter and more customisable
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Vim has intelligent indentation based on filetype. Try adding this to your &lt;code&gt;.vimrc&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="k"&gt;has&lt;/span&gt; (&lt;span class="s"&gt;&amp;quot;autocmd&amp;quot;&lt;/span&gt;)
    &amp;quot; &lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;detection&lt;/span&gt;. &lt;span class="n"&gt;Indent&lt;/span&gt; &lt;span class="n"&gt;based&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt; &lt;span class="n"&gt;filetype&lt;/span&gt;. &lt;span class="n"&gt;Recommended&lt;/span&gt;.
    &lt;span class="n"&gt;filetype&lt;/span&gt; &lt;span class="n"&gt;plugin&lt;/span&gt; &lt;span class="n"&gt;indent&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt;
&lt;span class="n"&gt;endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Folding&lt;/h1&gt;
&lt;p&gt;여러 line 들을 folding 하면 필요 없는 부분들을 숨겨서 긴 source code 등을 보는데 더 수월할 때가 많다.&lt;/p&gt;
&lt;p&gt;folding 을 하는 가장 기본적인 방법은 원하는 line 들을 선택한 후 &lt;code&gt;z, f&lt;/code&gt;, &lt;code&gt;:fold&lt;/code&gt;, &lt;code&gt;:fo&lt;/code&gt; 를 실행하는 것이다.&lt;/p&gt;
&lt;p&gt;unfolding 은 folding 된 line 에서 &lt;code&gt;z, o&lt;/code&gt;, &lt;code&gt;:foldopen&lt;/code&gt;, &lt;code&gt;:foldo&lt;/code&gt; 중 하나를 실행하면 된다.&lt;/p&gt;
&lt;p&gt;자세한 내용은 &lt;code&gt;:help fold&lt;/code&gt; 를 참고하자.&lt;/p&gt;
&lt;h1&gt;Get the name of the current file&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Register &lt;code&gt;%&lt;/code&gt; contains the name of the current file&lt;/li&gt;
&lt;li&gt;Register &lt;code&gt;#&lt;/code&gt; contains the name of the alternate file.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;현재 작업 중인 buffer 의 file name 을 확인하려면 register &lt;code&gt;%&lt;/code&gt; 를 확인하면 된다 : &lt;code&gt;:echo @%&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;기타 file path 를 확인하기 위한 command :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:echo expand('%:t')&lt;/code&gt; : &lt;code&gt;my.txt&lt;/code&gt;, name of file ('tail')&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:echo expand('%:p')&lt;/code&gt; : &lt;code&gt;/abc/def/my.txt&lt;/code&gt;, full path&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:echo expand('%:p:h')&lt;/code&gt; : &lt;code&gt;/abc/def&lt;/code&gt;, directory containing file ('head')&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:echo expand('%:p:h:t')&lt;/code&gt; : &lt;code&gt;dev&lt;/code&gt;, First get the full path with &lt;code&gt;:p&lt;/code&gt; (&lt;code&gt;/abc/def/my.txt&lt;/code&gt;), then get the head of that with &lt;code&gt;:h&lt;/code&gt; (&lt;code&gt;/abc/def&lt;/code&gt;), then get the tail of that with &lt;code&gt;:t&lt;/code&gt; (&lt;code&gt;def&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:echo expand('%:r')&lt;/code&gt; : &lt;code&gt;my&lt;/code&gt;, name of file less one extension ('root')&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:echo expand('%:e')&lt;/code&gt; : &lt;code&gt;txt&lt;/code&gt; name of file's extension ('extension')&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For more info run &lt;code&gt;:help expand&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;If all that is wanted is to display the name of the current file, type &lt;code&gt;Ctrl-G&lt;/code&gt; (or press &lt;code&gt;1 then Ctrl-G&lt;/code&gt; for the full path).&lt;/p&gt;
&lt;p&gt;When using &lt;code&gt;@%&lt;/code&gt;, the name is displayed relative to the current directory.&lt;/p&gt;</content><category term="vim"></category></entry><entry><title>Linux 에서 각 디렉터리들의 실제 사용량 조회하기</title><link href="https://imjang57.github.io/garret/linux-check-disk-usage-of-directories.html" rel="alternate"></link><published>2017-02-14T00:00:00+09:00</published><updated>2017-02-14T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-02-14:/garret/linux-check-disk-usage-of-directories.html</id><summary type="html">&lt;p&gt;Bash script 로 각 디렉터리들이 실제 사용하고 있는 디스크 크기를 알아보는 방법&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Linux 에서 각 디렉터리 별 디스크 사용량 확인하기&lt;/h1&gt;
&lt;p&gt;리눅스에서 각 디렉터리마다 디스크를 얼마나 사용하고 있는지 확인하기 위한 bash script 이다.&lt;/p&gt;
&lt;p&gt;스크립트:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# make newlines the only seperator (IFS : Internal Field Separator)&lt;/span&gt;
&lt;span class="nv"&gt;IFS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;$&amp;#39;\n&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; d in &lt;span class="k"&gt;$(&lt;/span&gt;ls -l &lt;span class="p"&gt;|&lt;/span&gt; grep &lt;span class="s1"&gt;&amp;#39;^d&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; awk &lt;span class="s1"&gt;&amp;#39;{ print substr($0, index($0, $9)) }&amp;#39;&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt; du -hs &lt;span class="nv"&gt;$d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;처음에 &lt;code&gt;IFS&lt;/code&gt; 를 지정해주지 않으면 디렉터리 이름에 공백이 들어간 경우 디렉터리 이름이 공백을 기준으로 split 되어 별도의 디렉터리처럼 동작하게 된다.&lt;/p&gt;
&lt;p&gt;나머지들은 워낙 기본적인 것들이니 간단하게 언급만 하면, 현재 디렉터리의 파일 목록을 조회하고, &lt;code&gt;grep&lt;/code&gt; 으로 디렉터리만 뽑아내고, &lt;code&gt;awk&lt;/code&gt; 로 파일 이름만 뽑아내고, &lt;code&gt;for&lt;/code&gt; statement 를 사용해서 각 디렉터리마다 &lt;code&gt;du&lt;/code&gt; 명령을 사용한다.&lt;/p&gt;</content><category term="bash"></category><category term="linux"></category><category term="du"></category><category term="disk"></category></entry><entry><title>Linux Memory overcommit</title><link href="https://imjang57.github.io/garret/linux-memory-overcommit.html" rel="alternate"></link><published>2017-01-23T00:00:00+09:00</published><updated>2017-01-23T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-23:/garret/linux-memory-overcommit.html</id><summary type="html">&lt;p&gt;리눅스에서 새로운 프로세스가 실행될 때 메모리 할당하는 과정과 overcommit 설정에 대한 설명&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Linux Memory and Over commit&lt;/h1&gt;
&lt;p&gt;개발한 자바 프로그램을 리눅스에서 실행시키려고 하는데 특정 서버에서만 계속 아래와 같은 메시지를 출력하면서 실행이 되지 않았다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;There is insufficient memory for the Java Runtime Environment to continue.
Native memory allocation (malloc) failed to allocate 4088 bytes for AllocateHeap
An error report file with more information is saved as:
/home/imjang57/hs_err_pid1234.log
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;잠시동안 삽질하다 보니 Linux 의 overcommit 설정때문이라는 것을 알았다.&lt;/p&gt;
&lt;h2&gt;Linux Memory&lt;/h2&gt;
&lt;p&gt;자세히 알아보기 전에 먼저 리눅스에서 프로세스가 실행될 때 어떻게 메모리가 할당되는지 얘기해보자.&lt;/p&gt;
&lt;p&gt;리눅스 시스템은 가상 메모리(Virtual Memory)라는 오래된 개념으로 물리 메모리(Physical Memory)보다 많은 메모리를 사용할 수 있다. (물론 윈도우도 똑같다.) 프로세스는 각각 독립적인 주소 공간을 가지고 있고, 메모리는 Page 라는 최소 단위로 할당된다. 이들 독립적인 주소 공간들은 가상 메모리에 할당된다. 그리고 실제로 프로세스가 필요한 부분만 물리 메모리에 할당하는 Demand-Paging 이라는 방법으로 메모리를 사용한다.&lt;/p&gt;
&lt;p&gt;물리 메모리를 넘어가는 메모리 공간을 저장하기 위해 Disk 의 특정 영역을 사용하게 되는데 이를 Swap 이라고 한다. 그리고 물리 메모리를 넘어가는 메모리 영역을 사용하기 위해 Disk 에 Page file 을 쓰고, 다시 메모리로 load 하는 작업들을 하게 된다. 이 작업들을 swap-in, swap-out 이라고 하고 Page 단위로 발생한다.&lt;/p&gt;
&lt;p&gt;자세히 들어가면 Page Table, Page, Page-in/Page-out, Copy on Write, Page replacement algorithm 등등 알아야 할게 많으니 넘어가자. 나도 오래되서 정확하게 기억 안난다. ^^;; 궁금한 내용은 Operating System 공부를 하자.&lt;/p&gt;
&lt;p&gt;참고로, 리눅스에서 Swap 을 사용하는 빈도를 확인할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ cat /proc/sys/vm/swappiness
60
$ sysctl vm.swappiness
vm.swappiness &lt;span class="o"&gt;=&lt;/span&gt; 60
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;일반적으로 위의 내용처럼 60이 기본값으로 되어 있다. &lt;code&gt;vm.swappiness&lt;/code&gt; 는 swap 영역을 얼마나 사용할 지를 나타내는 값이다. 0으로 설정하면 swap 을 최대한 사용하지 않는다는 뜻이고 100이면 swap 을 최대한 사용한다는 뜻이다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vm.swappiness&lt;/code&gt; 값 변경은 아래 명령을 실행하면 된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ sysctl vm.swappiness&lt;span class="o"&gt;=&lt;/span&gt;0
$ &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt; &amp;gt; /proc/sys/vm/swappiness
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;또는 &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; 에 &lt;code&gt;vm.swappiness=0&lt;/code&gt; 을 추가하면 된다.&lt;/p&gt;
&lt;p&gt;현재 사용되고 있는 swap 현황을 알고 싶으면 다음과 같이 하면 된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ cat /proc/meminfo &lt;span class="p"&gt;|&lt;/span&gt; grep Swap
SwapCached: &lt;span class="m"&gt;0&lt;/span&gt; kB
SwapTotal: &lt;span class="m"&gt;0&lt;/span&gt; kB
SwapFree: &lt;span class="m"&gt;0&lt;/span&gt; kB
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Linux Memory Commit&lt;/h2&gt;
&lt;p&gt;리눅스에서 프로세스가 실행될 때 Memory Commit 이라는 작업이 수행된다. &lt;code&gt;malloc()&lt;/code&gt; 등과 같은 시스템 콜(System call)을 사용하여 메모리 할당 요청을 할 때, 시스템 콜은 메모리 영역을 할당해서 주소를 리턴한다. 이때, 실제로 물리 메모리에 할당되는 것은 아니다. 단지 메모리 영역만 만들고 실제 사용될 때가 되어야 물리 메모리에 올라가게 된다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fork()&lt;/code&gt; 등의 시스템 콜로 새로운 자식 프로세스를 생성할 때, 자식 프로세스는 부모 프로세스의 메모리 영역을 그대로 복사한다. 그래서 메모리를 많이 쓰는 프로세스에서 &lt;code&gt;fork()&lt;/code&gt; System call 을 사용하면 매우 많은 메모리가 필요하게 된다. 즉, &lt;code&gt;fork&lt;/code&gt; 한 후에 &lt;code&gt;exec&lt;/code&gt; 가 수행되기 전까지 실제로는 자식 프로세스에서 사용되지 않는 메모리들을 commit 하게 된다.(참고로, &lt;code&gt;fork&lt;/code&gt; 는 새로운 프로세스를 시작할 때 메모리 공간을 복사하지만 &lt;code&gt;exec&lt;/code&gt; 는 새로운 프로세스를 실행할 때 현재 메모리 공간을 덮어쓴다. 하지만 &lt;code&gt;exec&lt;/code&gt; 는 &lt;code&gt;exec&lt;/code&gt; 가 실행된 이후의 로직들은 실행되지 않고 사라지게 된다.)&lt;/p&gt;
&lt;h2&gt;Linux overcommit&lt;/h2&gt;
&lt;p&gt;리눅스에서는 가상 메모리로 인해 물리 메모리보다 많은 메모리를 사용할 수 있다. 그리고 overcommit 이라는 개념을 적용하여 이를 제어할 수 있게 한다. 리눅스는 새로운 프로세스가 실행될 때 overcommit 설정에 따라서 다음과 같은 행동들 중 하나를 선택한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;메모리가 부족하면 임의의 프로세스를 종료시켜서 메모리를 확보&lt;/li&gt;
&lt;li&gt;메모리가 부족해도 일단 프로세스 실행&lt;/li&gt;
&lt;li&gt;프로세스 실행을 중지하고 에러 발생&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;리눅스가 임의로 프로세스를 종료시킬 때 사용되는 모듈을 &lt;strong&gt;OOM Killer(Out Of Memory Killer)&lt;/strong&gt; 라고 한다. OOM Killer 의 동작은 &lt;code&gt;vm.overcommit_memory&lt;/code&gt;, &lt;code&gt;vm.overcommit_ratio&lt;/code&gt; 설정에 의존적이다. &lt;code&gt;overcommit_memory&lt;/code&gt; 가 0이면 Heuristic method, 1 이면 overcommit 사용, 2는 overcommit_ratio 에 따라 제한하게 된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0: 휴리스틱하게 overcommit 여부를 결정한다. 보통 기본설정이다. 메모리에 대한 요구가 발생했을 때 메모리 공간이 부족하면 실행 중인 프로세스를 강제로 종료시켜 메모리를 확보한다. Page Cache + Swap Memory + Slab Reclaimable 값을 기준으로 결정한다. kernel 의 소스에서 &lt;code&gt;mm/mmap.c&lt;/code&gt; 를 참고하자.&lt;/li&gt;
&lt;li&gt;1: 항상 overcommit 을 허용한다. 메모리가 실제로 부족해도 충분한 메모리가 있는 것처럼 동작하게 된다.&lt;/li&gt;
&lt;li&gt;2: overcommit 허용하지 않는다. 메모리가 부족할 경우 메모리 할당 요청한 프로세스를 실행하는게 아니라 에러를 발생시킨다. Swap size + (Ram size * &lt;code&gt;vm.overcommit_ratio&lt;/code&gt;/100) 의 공식에 따라 결정된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;OOM Killer 에 의해 죽으면 아래와 같은 에러가 발생한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;May 8 11:18:50 mimul01 kernel: Out of memory: Kill process 3121
(malloc_test) score 884 or sacrifice child
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;프로세스가 Commit 요청 가능한 크기는 &lt;code&gt;/proc/meminfo&lt;/code&gt; 의 내용으로 확인할 수 있다. CommitLimit 은 요청 가능한 크기의 최대값, Committed_AS 는 사용량을 나타낸다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ cat /proc/meminfo &lt;span class="p"&gt;|&lt;/span&gt; grep Commit
CommitLimit: &lt;span class="m"&gt;4030664&lt;/span&gt; kB
Committed_AS: &lt;span class="m"&gt;67748&lt;/span&gt; kB
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Overcommit 설정은 제한된 메모리에서 보다 많은 프로세스를 띄우고 불필요한 메모리로 인한 공간 낭비를 줄일 수 있다는 장점이 있지만 OS 가 프로세스를 임의로 종료시켜 버릴 수 있다는 위험도 있다. 실제 운영에 사용되는 서버라면 매우 조심해야 할 상황이 발생할 수 있다.&lt;/p&gt;
&lt;p&gt;현재 overcommit 설정 혹인은 다음과 같이 하면 된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ sysctl -a &lt;span class="p"&gt;|&lt;/span&gt; grep overcommit
vm.overcommit_memory &lt;span class="o"&gt;=&lt;/span&gt; 0
vm.overcommit_ratio &lt;span class="o"&gt;=&lt;/span&gt; 50
vm.overcommit_kbytes &lt;span class="o"&gt;=&lt;/span&gt; 0
vm.nr_overcommit_hugepages &lt;span class="o"&gt;=&lt;/span&gt; 0
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;또는&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;cat /proc/sys/vm/overcommit_memory
0
cat /proc/sys/vm/overcommit_ratio
50
cat /proc/sys/vm/oom_kill_allocating_task
0
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;overcommit 설정을 변경하려면 다음과 같이 하면 된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ sysctl vm.overcommit_memory&lt;span class="o"&gt;=&lt;/span&gt;1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;또는 &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; 에 아래 내용을 추가&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vm.overcommit_memory=1
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Linux overcommit test&lt;/h2&gt;
&lt;p&gt;참고로 overcommit 동작에 대해 테스트해보자.&lt;/p&gt;
&lt;p&gt;다음 코드는 &lt;code&gt;malloc()&lt;/code&gt;만 하고 메모리에 쓰는 작업은 하지 않는 코드다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;while(1) {
  block = (void *) malloc((double) GIGABYTE);
  printf(&amp;quot;Allocated memory.\n&amp;quot;);
  sleep(1);
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;그리고 다음 코드는 메모리에 쓰는 작업까지 한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;while(1) {
  block = (void *) malloc((double) GIGABYTE);
  memset(block, 1, GIGABYTE);
  printf(&amp;quot;Allocated memory.\n&amp;quot;);
  sleep(1);
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;적절하게 할당하는 메모리 값을 변경해가며 테스트해보자.&lt;/p&gt;
&lt;h1&gt;References&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Linux overcommit handling modes 에 대한 문서: https://www.kernel.org/doc/Documentation/vm/overcommit-accounting&lt;/li&gt;
&lt;li&gt;vm.overcommit에 대한 짧은 이야기: https://brunch.co.kr/@alden/16&lt;/li&gt;
&lt;/ul&gt;</content><category term="linux"></category><category term="memory"></category><category term="overcommit"></category></entry><entry><title>NPE (NullPointerException) 을 피하자</title><link href="https://imjang57.github.io/garret/avoid-null-pointer-exception-in-java.html" rel="alternate"></link><published>2017-01-18T00:00:00+09:00</published><updated>2017-01-18T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-18:/garret/avoid-null-pointer-exception-in-java.html</id><summary type="html">&lt;p&gt;Java 에서 NPE (NullPointerException) 을 피하면서 코딩하기 위한 습관들&lt;/p&gt;</summary><content type="html">&lt;h1&gt;NPE(NullPointerException) 을 피하자.&lt;/h1&gt;
&lt;p&gt;자바 개발을 하다보면 가장 많이 만나고 영향이 큰 예외 중 하나가 &lt;em&gt;NPE&lt;/em&gt; 이다. NPE 는 개발자의 습관이나 부주의 등이 대부분 원인이다. 이를 예방하는 가장 좋은 방법은 NPE 를 피하는 코딩 습관을 갖는 것이다.&lt;/p&gt;
&lt;h2&gt;null 의 의미&lt;/h2&gt;
&lt;p&gt;자바에서 &lt;code&gt;null&lt;/code&gt; 이란 아래와 같은 상태를 의미한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;아직 object 가 생성되지 않은 상태, 즉 아직 memory 할당이 되지 않은 object 상태&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;NPE 는 null 상태인 object 를 참조하여 어떠한 행위(method 실행)를 하려할 때 발생하는 예외이다.&lt;/p&gt;
&lt;h2&gt;NPE가 발생하는 상황&lt;/h2&gt;
&lt;p&gt;NPE 는 아래와 같은 상황에서 발생할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;null object 의 method 를 호출&lt;/li&gt;
&lt;li&gt;null object 의 instance member 에 접근&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Avoid NPE in source code&lt;/h1&gt;
&lt;p&gt;NPE 는 대부분 개발자의 부주의로 발생하므로, 개발할 때 조금만 신경쓰면 대부분의 NPE 를 예방할 수 있다.&lt;/p&gt;
&lt;h2&gt;String 객체를 비교할 경우&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;equals()&lt;/code&gt;, &lt;code&gt;equalsIgnoreCase()&lt;/code&gt; 등을 사용할 때 null 이 아닌 것이 확실한 객체가 있다면 해당 객체의 method 를 호출하자.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Compare String&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;equals&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;testStr&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
 &lt;span class="c1"&gt;// logic&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;String.valueOf() 사용&lt;/h2&gt;
&lt;p&gt;로그 등을 남길 때 객체의 상태를 확인하기 위해 객체의 &lt;code&gt;toString()&lt;/code&gt; 을 호출하는 경우가 있는데, 객체가 null 일 경우 NPE 가 발생한다. 로그를 위해 null 을 체크하는 로직을 추가하는 것은 불필요한 코드가 될 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;toString()&lt;/code&gt; method 보다는 &lt;code&gt;String.valueOf()&lt;/code&gt; 를 사용하자.&lt;/p&gt;
&lt;h2&gt;Primitive type 사용&lt;/h2&gt;
&lt;p&gt;꼭 필요한 경우가 아니라면 Primitive type data 를 사용하자. NPE 를 줄이고 memory 도 더 효율적으로 사용할 수 있다.&lt;/p&gt;
&lt;h2&gt;return empty collection&lt;/h2&gt;
&lt;p&gt;List, Set, Map 등과 같은 Collection 을 return 하는 method 를 구현할 때, null 을 return 하지 말자. 대신 empty collection 을 return 하자. 그러면 함수를 사용하는 개발자는 불필요한 null 체크를 하지 않아도 된다.&lt;/p&gt;
&lt;h2&gt;Use null-safe stuffs&lt;/h2&gt;
&lt;p&gt;null 에 안전한 자바 내장 함수나 commons-lang 과 같은 helper class 를 사용하자. Apache Commons 도 좋고, 요즘은 Googld guava 가 매우 유용한 라이브러리들을 많이 제공한다.&lt;/p&gt;
&lt;h2&gt;Unit Test&lt;/h2&gt;
&lt;p&gt;Java assert, Unit test (JUnit) 등을 활용하여 사전 확인 및 다양한 상황에서의 테스트를 수행하자.&lt;/p&gt;
&lt;h2&gt;협업할 때는 기능 및 제약사항 등을 확실히 명시하자.&lt;/h2&gt;
&lt;p&gt;NPE 는 개발자의 부주의에 의해 대부분 발생하고, 개발자의 부주의는 정보가 없어서 발생하는 경우가 많다. 아래의 내용들은 명확하게 공유하자.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Method parameter 와 return value 에 대한 명세&lt;/li&gt;
&lt;li&gt;Method 에서 수행하는 validation 으로 인해 발생가능한 Exception 들&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="https://github.com/google/guava"&gt;Google guava&lt;/a&gt; 의 &lt;em&gt;Preconditions&lt;/em&gt; 등을 사용하면 parameter 에 대한 validation 을 쉽게 처리할 수 있다.&lt;/p&gt;
&lt;p&gt;또한 &lt;em&gt;Java Doc&lt;/em&gt; 등의 문서를 적절히 사용하자. 자동으로 Java doc 을 생성해주는 프로그램도 많다. 또는 &lt;a href="http://swagger.io"&gt;swagger&lt;/a&gt; 등을 이용하여 RestAPI 서비스의 API 에 대한 명세를 공유할 수도 있다.&lt;/p&gt;
&lt;p&gt;문서의 내용을 자세하게 채우지 않아도 된다. 위의 내용들에 대해서만이라도 명확하게 작성하자.&lt;/p&gt;
&lt;h2&gt;Optional class&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Optional&lt;/em&gt; 을 사용하면 null check 를 위한 코드를 상당히 줄일 수 있으며 코드의 Readability 를 높일 수 있다.&lt;/p&gt;
&lt;p&gt;Optional 은 원래 google guava 라이브러리에서 제공되었었는데 java 8 로 버전 업하면서 자바에서도 지원(&lt;code&gt;java.util.Optional&amp;lt;T&amp;gt;&lt;/code&gt;)하게 되었다.&lt;/p&gt;
&lt;p&gt;Optional object 생성:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;nStr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Test String&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;Optional&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;eOp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Optional&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;empty&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// empty Optional 객체 생성&lt;/span&gt;
&lt;span class="n"&gt;Optional&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;nullableOp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Optional&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ofNullable&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nStr&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// null 을 허용하는 Optional 객체 생성&lt;/span&gt;
&lt;span class="n"&gt;Optional&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;notNullableOp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Optional&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;of&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// str 에 접근하는 시점이 아니라 Optional 객체를 생성하는 이 순간 parameter 의 null 여부를 체크하여 NPE 가 발생&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt; &lt;span class="n"&gt;notNullableOp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;isPresent&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
 &lt;span class="c1"&gt;// Optional 객체에 값이 있는지 확인 후 아래 코드를 실행&lt;/span&gt;
 &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;notNullableOp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;get&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;notNullableOp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ifPresent&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Optional 객체에 값이 있는지 확인 후 전달받은 function 을 실행&lt;/span&gt;
&lt;span class="n"&gt;notNullableOp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ifPresent&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;});&lt;/span&gt;
&lt;span class="n"&gt;nullableOp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ifPresent&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// null 이므로 실행되지 않는다.&lt;/span&gt;
&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;emtpyStr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;eOp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;orElse&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Empty String&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Optional 객체가 empty 일 경우 (null 일 경우) &amp;quot;Empty String&amp;quot; 의 reference 를 return.&lt;/span&gt;
&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;exStr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;eOp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;orElseThrow&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Exception&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Optional 객체가 empty 일 경우 (null 일 경우) 지정된 Exception 을 throw.&lt;/span&gt;
&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;notNullableOp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;filter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;length&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="na"&gt;orElse&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Too long string&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Optional 과 map 을 이용하여 null check 없이 jsonNode 접근하기:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Optional&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;of&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rootNode&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
 &lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;map&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;get&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;secondNode&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
 &lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;map&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;get&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;thirdNode&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
 &lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ifPresent&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
 &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;get&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;value&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;
 &lt;span class="o"&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;if else 를 이용한 null 체크는 source code readability 를 떨어뜨린다. Optional 과 Java doc 을 이용한 직관적인 코드 작성을 하자.&lt;/p&gt;</content><category term="java"></category><category term="NPE"></category><category term="NullPointerException"></category><category term="null"></category></entry><entry><title>JVM Process monitoring with JDK tools</title><link href="https://imjang57.github.io/garret/jvm-process-monitoring-with-jdk-tools.html" rel="alternate"></link><published>2017-01-18T00:00:00+09:00</published><updated>2017-01-18T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-18:/garret/jvm-process-monitoring-with-jdk-tools.html</id><summary type="html">&lt;p&gt;JDK Tools 을 사용하여 JVM Process 를 모니터링하는 방법에 대한 소개&lt;/p&gt;</summary><content type="html">&lt;h1&gt;JVM Process monitoring&lt;/h1&gt;
&lt;p&gt;요즘 일 때문에 오랜만에 자바를 사용하고 있고, 스칼라에 관심이 생겨 공부해보고 있다. 그런데 둘다 &lt;em&gt;JVM&lt;/em&gt; 기반 언어다 보니 JVM 에 대해 알아야 겠다는 생각이 들었다. (사실 일하다가 JVM 모니터링 할 일이 생긴 김에 간단하게 정리한다.) 어쨌든 둘 다 JVM 에서 동작하는 녀석들이라 JVM 모니터링에 대해 간단하게 남겨보고자 한다.&lt;/p&gt;
&lt;p&gt;자바든 스칼라든 실행되면 JVM 프로세스이다. 자바나 스칼라로 쓰여진 코드는 Java Bytecode 로 컴파일되고, JVM 은 이 Bytecode 를 실행한다. 그러므로 컴파일 된 이후에는 자바로 작성했든 스칼라로 작성했든 JVM 입장에서는 그냥 똑같은 Bytecode 이다. 그러니 같은 방법(JVM Process monitoring)으로 모니터링할 수 있다.&lt;/p&gt;
&lt;h1&gt;JVM Monitoring tools&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;JDK (Java Development Kit)&lt;/em&gt; 를 설치하면 기본적으로 자바 코드를 컴파일하기 위한 &lt;code&gt;javac&lt;/code&gt;, 컴파일된 bytecode 를 실행하는 &lt;code&gt;java&lt;/code&gt; 를 제공한다. 그리고 개발자들을 위한 다양한 도구들을 기본적으로 제공한다. 모니터링을 위해서 아래 도구들을 사용가능하다.(물론 아래 도구들 외에 더 많다.)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;jps&lt;/code&gt; : JVM Process Status&lt;/li&gt;
&lt;li&gt;&lt;code&gt;jstat&lt;/code&gt; : JVM Statistics&lt;/li&gt;
&lt;li&gt;&lt;code&gt;jhat&lt;/code&gt; : Java Heap Analysis Tool&lt;/li&gt;
&lt;li&gt;&lt;code&gt;jstack&lt;/code&gt; : Java thread Stack traces&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;VisualVM&lt;/em&gt; 과 같은 GUI 도구도 있지만 어쨌든 기본은 CLI 도구들이고, GUI 도구들도 CLI 도구들을 이용하는 형태이다.&lt;/p&gt;
&lt;h1&gt;JVM Monitoring&lt;/h1&gt;
&lt;p&gt;JVM 프로세스를 모니터링하려면 당연히 JVM 프로세스가 있어야 한다. 테스트 프로그램은 임시로 tomcat 을 사용하였다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;yum install -y tomcat&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;passwd tomcat&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/etc/passwd&lt;/code&gt; 파일에서 tomcat 계정의 login shell 을 bash 로 지정&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sudo service tomcat start&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;tomcat 계정으로 전환(&lt;code&gt;su - tomcat&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;jps : JVM Process Status&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;jps&lt;/code&gt; 를 실행하면 JVM Process 목록과 PID 를 확인할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ jps
&lt;span class="m"&gt;17285&lt;/span&gt; Bootstrap
&lt;span class="m"&gt;17322&lt;/span&gt; Jps
$ jps -m
&lt;span class="m"&gt;17285&lt;/span&gt; Bootstrap start
&lt;span class="m"&gt;17398&lt;/span&gt; Jps -m
$ jps -ml
&lt;span class="m"&gt;17285&lt;/span&gt; org.apache.catalina.startup.Bootstrap start
&lt;span class="m"&gt;17413&lt;/span&gt; sun.tools.jps.Jps -ml
$
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;jstat: JVM Statistics&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;jps&lt;/code&gt; 에서 확인한 PID 로 &lt;code&gt;jstat&lt;/code&gt; 를 실행할 수 있다. 위에서 tomcat 을 실행하는 Bootstrap 의 PID 가 17285 이므로 이를 이용하여 &lt;code&gt;jstat&lt;/code&gt; 을 실행하였다. 그리고 1000 밀리초 단위로 통계치를 수집하도록 하였다. 결과는 퍼센트(%)로 출력된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ jstat -gcutil &lt;span class="m"&gt;17285&lt;/span&gt; 1000
  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT   
  0.00  98.44  60.41   5.27  96.61  89.46      &lt;span class="m"&gt;1&lt;/span&gt;    0.005     &lt;span class="m"&gt;0&lt;/span&gt;    0.000    0.005
  0.00  98.44  60.41   5.27  96.61  89.46      &lt;span class="m"&gt;1&lt;/span&gt;    0.005     &lt;span class="m"&gt;0&lt;/span&gt;    0.000    0.005
  0.00  98.44  60.41   5.27  96.61  89.46      &lt;span class="m"&gt;1&lt;/span&gt;    0.005     &lt;span class="m"&gt;0&lt;/span&gt;    0.000    0.005
  0.00  98.44  60.41   5.27  96.61  89.46      &lt;span class="m"&gt;1&lt;/span&gt;    0.005     &lt;span class="m"&gt;0&lt;/span&gt;    0.000    0.005
  0.00  98.44  60.41   5.27  96.61  89.46      &lt;span class="m"&gt;1&lt;/span&gt;    0.005     &lt;span class="m"&gt;0&lt;/span&gt;    0.000    0.005
$
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;위에서처럼 &lt;code&gt;-gcutil&lt;/code&gt; 옵션을 사용하면 Java Heap 현황을 확인할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;GCT&lt;/em&gt; : Garbage Collection Time (seconds, 누적)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;FGCT&lt;/em&gt; : Full GCT (seconds, 누적)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;FGC&lt;/em&gt; : Full Garbage Collection 발생 회수&lt;/li&gt;
&lt;li&gt;&lt;em&gt;M&lt;/em&gt; : Metaspace 영역의 사용률&lt;/li&gt;
&lt;li&gt;&lt;em&gt;S0&lt;/em&gt; : Survivor 0 영역의 사용률&lt;/li&gt;
&lt;li&gt;&lt;em&gt;S1&lt;/em&gt; : Survivor 1 영역의 사용률&lt;/li&gt;
&lt;li&gt;&lt;em&gt;E&lt;/em&gt; : Eden 영역의 사용률&lt;/li&gt;
&lt;li&gt;&lt;em&gt;O&lt;/em&gt; : Old 영역의 사용률&lt;/li&gt;
&lt;li&gt;&lt;em&gt;CCS&lt;/em&gt; : Compressed Class Space (part of metaspace)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;YGC&lt;/em&gt; : Young GC 발생 회수&lt;/li&gt;
&lt;li&gt;&lt;em&gt;YGCT&lt;/em&gt; : Young GC Time (seconds, 누적)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;FGCT 열의 값이 계속 증가하면 문제가 있는 것이다.&lt;/p&gt;
&lt;p&gt;M 열은 Metadata 를 위한 힙 영역이다. 이 영역은 자바8부터 M(Metaspace)로 표시되기 시작했고 이전 버전까지는 P(Permgen, Permanent Generation) 영역이라고 불리었다. 클래스의 Metadata, JVM 내부 객체 등이 저장되는 중요한 곳이다. 매우 무조건 자바 프로그램의 경우 이 영역에서 &lt;code&gt;java.lang.OutOfMemoryError&lt;/code&gt; 를 만날 수도 있다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-gcutil&lt;/code&gt; 대신 &lt;code&gt;-gccause&lt;/code&gt; 옵션을 사용하면 &lt;code&gt;-gcutil&lt;/code&gt; 의 결과에 GC 의 원인까지 확인할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ jstat -gccause &lt;span class="m"&gt;17285&lt;/span&gt; 1000
  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT    LGCC                 GCC                 
  0.00  98.44  61.41   5.27  96.61  89.46      &lt;span class="m"&gt;1&lt;/span&gt;    0.005     &lt;span class="m"&gt;0&lt;/span&gt;    0.000    0.005 Allocation Failure   No GC               
  0.00  98.44  61.41   5.27  96.61  89.46      &lt;span class="m"&gt;1&lt;/span&gt;    0.005     &lt;span class="m"&gt;0&lt;/span&gt;    0.000    0.005 Allocation Failure   No GC               
  0.00  98.44  61.41   5.27  96.61  89.46      &lt;span class="m"&gt;1&lt;/span&gt;    0.005     &lt;span class="m"&gt;0&lt;/span&gt;    0.000    0.005 Allocation Failure   No GC               
$
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;&lt;em&gt;LGCC&lt;/em&gt; : 지난 GC의 발생 이유&lt;/li&gt;
&lt;li&gt;&lt;em&gt;GCC&lt;/em&gt; : 현재 GC의 발생 이유&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;jstack: Java thread Stack traces&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;jstack&lt;/code&gt; 을 이용하면 현재 Java 프로세스의 stack dump 를 얻을 수 있다. &lt;code&gt;jstack&lt;/code&gt; 을 이용하면 현재 실행 중인 여러 thread 들의 stack 을 확인할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ jstack 17285
2016-12-26 10:32:20
Full thread dump OpenJDK 64-Bit Server VM &lt;span class="o"&gt;(&lt;/span&gt;25.111-b15 mixed mode&lt;span class="o"&gt;)&lt;/span&gt;:
&lt;span class="s2"&gt;&amp;quot;Attach Listener&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#17 daemon prio=9 os_prio=0 tid=0x00007f48d0001000 nid=0x458b waiting on condition [0x0000000000000000]&lt;/span&gt;
   java.lang.Thread.State: RUNNABLE
&lt;span class="s2"&gt;&amp;quot;ajp-bio-8009-AsyncTimeout&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#15 daemon prio=5 os_prio=0 tid=0x00007f491049c800 nid=0x43a9 waiting on condition [0x00007f48f8ba4000]&lt;/span&gt;
   java.lang.Thread.State: TIMED_WAITING &lt;span class="o"&gt;(&lt;/span&gt;sleeping&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.Thread.sleep&lt;span class="o"&gt;(&lt;/span&gt;Native Method&lt;span class="o"&gt;)&lt;/span&gt;
 at org.apache.tomcat.util.net.JIoEndpoint&lt;span class="nv"&gt;$AsyncTimeout&lt;/span&gt;.run&lt;span class="o"&gt;(&lt;/span&gt;JIoEndpoint.java:152&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.Thread.run&lt;span class="o"&gt;(&lt;/span&gt;Thread.java:745&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;ajp-bio-8009-Acceptor-0&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#14 daemon prio=5 os_prio=0 tid=0x00007f491049a000 nid=0x43a8 runnable [0x00007f48f8ca5000]&lt;/span&gt;
   java.lang.Thread.State: RUNNABLE
 at java.net.PlainSocketImpl.socketAccept&lt;span class="o"&gt;(&lt;/span&gt;Native Method&lt;span class="o"&gt;)&lt;/span&gt;
 at java.net.AbstractPlainSocketImpl.accept&lt;span class="o"&gt;(&lt;/span&gt;AbstractPlainSocketImpl.java:409&lt;span class="o"&gt;)&lt;/span&gt;
 at java.net.ServerSocket.implAccept&lt;span class="o"&gt;(&lt;/span&gt;ServerSocket.java:545&lt;span class="o"&gt;)&lt;/span&gt;
 at java.net.ServerSocket.accept&lt;span class="o"&gt;(&lt;/span&gt;ServerSocket.java:513&lt;span class="o"&gt;)&lt;/span&gt;
 at org.apache.tomcat.util.net.DefaultServerSocketFactory.acceptSocket&lt;span class="o"&gt;(&lt;/span&gt;DefaultServerSocketFactory.java:60&lt;span class="o"&gt;)&lt;/span&gt;
 at org.apache.tomcat.util.net.JIoEndpoint&lt;span class="nv"&gt;$Acceptor&lt;/span&gt;.run&lt;span class="o"&gt;(&lt;/span&gt;JIoEndpoint.java:222&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.Thread.run&lt;span class="o"&gt;(&lt;/span&gt;Thread.java:745&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;ContainerBackgroundProcessor[StandardEngine[Catalina]]&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#13 daemon prio=5 os_prio=0 tid=0x00007f4910497000 nid=0x43a7 waiting on condition [0x00007f48f8da6000]&lt;/span&gt;
   java.lang.Thread.State: TIMED_WAITING &lt;span class="o"&gt;(&lt;/span&gt;sleeping&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.Thread.sleep&lt;span class="o"&gt;(&lt;/span&gt;Native Method&lt;span class="o"&gt;)&lt;/span&gt;
 at org.apache.catalina.core.ContainerBase&lt;span class="nv"&gt;$ContainerBackgroundProcessor&lt;/span&gt;.run&lt;span class="o"&gt;(&lt;/span&gt;ContainerBase.java:1510&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.Thread.run&lt;span class="o"&gt;(&lt;/span&gt;Thread.java:745&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;GC Daemon&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#11 daemon prio=2 os_prio=0 tid=0x00007f491040c800 nid=0x43a5 in Object.wait() [0x00007f48fa637000]&lt;/span&gt;
   java.lang.Thread.State: TIMED_WAITING &lt;span class="o"&gt;(&lt;/span&gt;on object monitor&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.Object.wait&lt;span class="o"&gt;(&lt;/span&gt;Native Method&lt;span class="o"&gt;)&lt;/span&gt;
 - waiting on &amp;lt;0x00000000ecfdd7d0&amp;gt; &lt;span class="o"&gt;(&lt;/span&gt;a sun.misc.GC&lt;span class="nv"&gt;$LatencyLock&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
 at sun.misc.GC&lt;span class="nv"&gt;$Daemon&lt;/span&gt;.run&lt;span class="o"&gt;(&lt;/span&gt;GC.java:117&lt;span class="o"&gt;)&lt;/span&gt;
 - locked &amp;lt;0x00000000ecfdd7d0&amp;gt; &lt;span class="o"&gt;(&lt;/span&gt;a sun.misc.GC&lt;span class="nv"&gt;$LatencyLock&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;Service Thread&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#8 daemon prio=9 os_prio=0 tid=0x00007f49100e1000 nid=0x43a3 runnable [0x0000000000000000]&lt;/span&gt;
   java.lang.Thread.State: RUNNABLE
&lt;span class="s2"&gt;&amp;quot;C1 CompilerThread2&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#7 daemon prio=9 os_prio=0 tid=0x00007f49100ce000 nid=0x43a2 waiting on condition [0x0000000000000000]&lt;/span&gt;
   java.lang.Thread.State: RUNNABLE
&lt;span class="s2"&gt;&amp;quot;C2 CompilerThread1&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#6 daemon prio=9 os_prio=0 tid=0x00007f49100cc800 nid=0x43a1 waiting on condition [0x0000000000000000]&lt;/span&gt;
   java.lang.Thread.State: RUNNABLE
&lt;span class="s2"&gt;&amp;quot;C2 CompilerThread0&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#5 daemon prio=9 os_prio=0 tid=0x00007f49100bf000 nid=0x43a0 waiting on condition [0x0000000000000000]&lt;/span&gt;
   java.lang.Thread.State: RUNNABLE
&lt;span class="s2"&gt;&amp;quot;Signal Dispatcher&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#4 daemon prio=9 os_prio=0 tid=0x00007f49100bc800 nid=0x439f runnable [0x0000000000000000]&lt;/span&gt;
   java.lang.Thread.State: RUNNABLE
&lt;span class="s2"&gt;&amp;quot;Finalizer&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#3 daemon prio=8 os_prio=0 tid=0x00007f4910093000 nid=0x439e in Object.wait() [0x00007f48fb5f4000]&lt;/span&gt;
   java.lang.Thread.State: WAITING &lt;span class="o"&gt;(&lt;/span&gt;on object monitor&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.Object.wait&lt;span class="o"&gt;(&lt;/span&gt;Native Method&lt;span class="o"&gt;)&lt;/span&gt;
 - waiting on &amp;lt;0x00000000edd08988&amp;gt; &lt;span class="o"&gt;(&lt;/span&gt;a java.lang.ref.ReferenceQueue&lt;span class="nv"&gt;$Lock&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.ref.ReferenceQueue.remove&lt;span class="o"&gt;(&lt;/span&gt;ReferenceQueue.java:143&lt;span class="o"&gt;)&lt;/span&gt;
 - locked &amp;lt;0x00000000edd08988&amp;gt; &lt;span class="o"&gt;(&lt;/span&gt;a java.lang.ref.ReferenceQueue&lt;span class="nv"&gt;$Lock&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.ref.ReferenceQueue.remove&lt;span class="o"&gt;(&lt;/span&gt;ReferenceQueue.java:164&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.ref.Finalizer&lt;span class="nv"&gt;$FinalizerThread&lt;/span&gt;.run&lt;span class="o"&gt;(&lt;/span&gt;Finalizer.java:209&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;Reference Handler&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#2 daemon prio=10 os_prio=0 tid=0x00007f491008e800 nid=0x439d in Object.wait() [0x00007f48fb6f5000]&lt;/span&gt;
   java.lang.Thread.State: WAITING &lt;span class="o"&gt;(&lt;/span&gt;on object monitor&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.Object.wait&lt;span class="o"&gt;(&lt;/span&gt;Native Method&lt;span class="o"&gt;)&lt;/span&gt;
 - waiting on &amp;lt;0x00000000edd00970&amp;gt; &lt;span class="o"&gt;(&lt;/span&gt;a java.lang.ref.Reference&lt;span class="nv"&gt;$Lock&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.Object.wait&lt;span class="o"&gt;(&lt;/span&gt;Object.java:502&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.ref.Reference.tryHandlePending&lt;span class="o"&gt;(&lt;/span&gt;Reference.java:191&lt;span class="o"&gt;)&lt;/span&gt;
 - locked &amp;lt;0x00000000edd00970&amp;gt; &lt;span class="o"&gt;(&lt;/span&gt;a java.lang.ref.Reference&lt;span class="nv"&gt;$Lock&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.ref.Reference&lt;span class="nv"&gt;$ReferenceHandler&lt;/span&gt;.run&lt;span class="o"&gt;(&lt;/span&gt;Reference.java:153&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;main&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#1 prio=5 os_prio=0 tid=0x00007f4910009000 nid=0x4397 runnable [0x00007f4919dbd000]&lt;/span&gt;
   java.lang.Thread.State: RUNNABLE
 at java.net.PlainSocketImpl.socketAccept&lt;span class="o"&gt;(&lt;/span&gt;Native Method&lt;span class="o"&gt;)&lt;/span&gt;
 at java.net.AbstractPlainSocketImpl.accept&lt;span class="o"&gt;(&lt;/span&gt;AbstractPlainSocketImpl.java:409&lt;span class="o"&gt;)&lt;/span&gt;
 at java.net.ServerSocket.implAccept&lt;span class="o"&gt;(&lt;/span&gt;ServerSocket.java:545&lt;span class="o"&gt;)&lt;/span&gt;
 at java.net.ServerSocket.accept&lt;span class="o"&gt;(&lt;/span&gt;ServerSocket.java:513&lt;span class="o"&gt;)&lt;/span&gt;
 at org.apache.catalina.core.StandardServer.await&lt;span class="o"&gt;(&lt;/span&gt;StandardServer.java:470&lt;span class="o"&gt;)&lt;/span&gt;
 at org.apache.catalina.startup.Catalina.await&lt;span class="o"&gt;(&lt;/span&gt;Catalina.java:781&lt;span class="o"&gt;)&lt;/span&gt;
 at org.apache.catalina.startup.Catalina.start&lt;span class="o"&gt;(&lt;/span&gt;Catalina.java:727&lt;span class="o"&gt;)&lt;/span&gt;
 at sun.reflect.NativeMethodAccessorImpl.invoke0&lt;span class="o"&gt;(&lt;/span&gt;Native Method&lt;span class="o"&gt;)&lt;/span&gt;
 at sun.reflect.NativeMethodAccessorImpl.invoke&lt;span class="o"&gt;(&lt;/span&gt;NativeMethodAccessorImpl.java:62&lt;span class="o"&gt;)&lt;/span&gt;
 at sun.reflect.DelegatingMethodAccessorImpl.invoke&lt;span class="o"&gt;(&lt;/span&gt;DelegatingMethodAccessorImpl.java:43&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.reflect.Method.invoke&lt;span class="o"&gt;(&lt;/span&gt;Method.java:498&lt;span class="o"&gt;)&lt;/span&gt;
 at org.apache.catalina.startup.Bootstrap.start&lt;span class="o"&gt;(&lt;/span&gt;Bootstrap.java:294&lt;span class="o"&gt;)&lt;/span&gt;
 at org.apache.catalina.startup.Bootstrap.main&lt;span class="o"&gt;(&lt;/span&gt;Bootstrap.java:428&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;VM Thread&amp;quot;&lt;/span&gt; &lt;span class="nv"&gt;os_prio&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="nv"&gt;tid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00007f4910084800 &lt;span class="nv"&gt;nid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x439c runnable
&lt;span class="s2"&gt;&amp;quot;GC task thread#0 (ParallelGC)&amp;quot;&lt;/span&gt; &lt;span class="nv"&gt;os_prio&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="nv"&gt;tid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00007f491001e000 &lt;span class="nv"&gt;nid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x4398 runnable
&lt;span class="s2"&gt;&amp;quot;GC task thread#1 (ParallelGC)&amp;quot;&lt;/span&gt; &lt;span class="nv"&gt;os_prio&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="nv"&gt;tid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00007f491001f800 &lt;span class="nv"&gt;nid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x4399 runnable
&lt;span class="s2"&gt;&amp;quot;GC task thread#2 (ParallelGC)&amp;quot;&lt;/span&gt; &lt;span class="nv"&gt;os_prio&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="nv"&gt;tid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00007f4910021800 &lt;span class="nv"&gt;nid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x439a runnable
&lt;span class="s2"&gt;&amp;quot;GC task thread#3 (ParallelGC)&amp;quot;&lt;/span&gt; &lt;span class="nv"&gt;os_prio&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="nv"&gt;tid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00007f4910023800 &lt;span class="nv"&gt;nid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x439b runnable
&lt;span class="s2"&gt;&amp;quot;VM Periodic Task Thread&amp;quot;&lt;/span&gt; &lt;span class="nv"&gt;os_prio&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="nv"&gt;tid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00007f49100ef800 &lt;span class="nv"&gt;nid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x43a4 waiting on condition
JNI global references: 44
$
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;References&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.wolfe.id.au/2011/10/16/monitoring-the-openjdk-from-the-cli/"&gt;Monitoring the OpenJDK from the CLI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://d2.naver.com/helloworld/6043"&gt;Garbage Collection 모니터링 방법&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="java"></category><category term="jvm"></category><category term="monitoring"></category><category term="jps"></category><category term="stat"></category><category term="stack"></category></entry><entry><title>Linux Partition 관리 : fdisk</title><link href="https://imjang57.github.io/garret/linux-command-fdisk.html" rel="alternate"></link><published>2017-01-18T00:00:00+09:00</published><updated>2017-01-18T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-18:/garret/linux-command-fdisk.html</id><summary type="html">&lt;p&gt;리눅스에서 fdisk 명령을 사용하여 파티션(Partition)을 관리하는 방법&lt;/p&gt;</summary><content type="html">&lt;h1&gt;fdisk&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;fdisk&lt;/code&gt; 명령은 partition table 을 관리하는 명령이다. 즉, linux 의 disk partition 을 생성, 수정, 삭제할 수 있는 도구이다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fdisk&lt;/code&gt; 실행파일의 위치는 &lt;code&gt;/sbin/fdisk&lt;/code&gt; 이다:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# which fdisk
/sbin/fdisk
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;fdisk help:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# fdisk -h
Usage:
fdisk [options] &amp;lt;disk&amp;gt; change partition table
fdisk [options] -l &amp;lt;disk&amp;gt; list partition table(s)
fdisk -s &amp;lt;partition&amp;gt; give partition size(s) in blocks
Options:
-b &amp;lt;size&amp;gt; sector size (512, 1024, 2048 or 4096)
-c switch off DOS-compatible mode
-h print help
-u &amp;lt;size&amp;gt; give sizes in sectors instead of cylinders
-v print version
-C &amp;lt;number&amp;gt; specify the number of cylinders
-H &amp;lt;number&amp;gt; specify the number of heads
-S &amp;lt;number&amp;gt; specify the number of sectors per track
#
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Disk device name&lt;/h2&gt;
&lt;p&gt;리눅스에서 디스크장치명은 IDE Disk 인지 SCSI Disk 인지에 따라서 장치명이 주어진다.&lt;/p&gt;
&lt;p&gt;IDE Disk 인 경우:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/dev/hda&lt;/code&gt; : 첫번째(a) IDE Disk (hd)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/dev/hdb&lt;/code&gt; : 두번째(b) IDE Disk (hd)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/dev/hdc&lt;/code&gt; : 세번째(c) IDE Disk (hd)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SCSI Disk 인 경우:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/dev/sda&lt;/code&gt; : 첫번째(a) SCSI Disk (sd)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/dev/sdb&lt;/code&gt; : 두번째(b) SCSI Disk (sd)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/dev/sdc&lt;/code&gt; : 세번째(c) SCSI Disk (sd)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;그리고 디스크 내에서 파티션이 여러개 나누어진 경우 숫자가 붙어서 장치명이 주어진다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/dev/hda&lt;/code&gt; : 첫번째(a) IDE디스크 전체를 의미&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/dev/hda1&lt;/code&gt; : 첫번째(a) IDE디스크 내의 첫번째 파티션&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/dev/hda2&lt;/code&gt; : 첫번째(a) IDE디스크 내의 두번째 파티션&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;요약하면 다음과 같다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;hd 로 시작하면 IDE Disk, sd 로 시작하면 SCSI Disk&lt;/li&gt;
&lt;li&gt;뒤에 알파벳이 붙으면 Disk 자체를 의미하고 Disk 는 a 부터 순서대로 Naming 이 이루어짐&lt;/li&gt;
&lt;li&gt;뒤에 숫자가 붙으면 Disk 내의 partition 번호를 의미하고 Partition 은 1 부터 순서대로 Naming 이 이루어짐&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;fdisk&lt;/code&gt; 를 사용하여 현재 시스템의 디스크와 파티션을 확인하고 새로운 파티션을 추가해보자.&lt;/p&gt;
&lt;h2&gt;디스크 및 파티션 확인하기&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;fisk -l&lt;/code&gt; 을 실행하면 현재 시스템의 모든 디스크 및 파티션 정보를 확인할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# fdisk -l
Disk /dev/vda: 85.9 GB, 85899345920 bytes
255 heads, 63 sectors/track, 10443 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x0005360e
   Device Boot      Start         End      Blocks   Id  System
/dev/vda1   *           1        1045     8387584   83  Linux
#
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;위의 결과에서 Disk device name 이 &lt;code&gt;/dev/vda&lt;/code&gt; 로 되어 있는데 오픈스택 가상머신에서 테스트하여 virtual disk 로 디스크가 인식되어 있기 때문이다. 현재 하나의 디스크를 사용하고 있고, 디스크에 하나의 파티션이 사용되고 있음을 알 수 있다. 디스크 용량은 총 85.9 GB 인데, 현재 파티션이 생성된 것은 8225280 bytes 즉 약 8 GB 이다.&lt;/p&gt;
&lt;h2&gt;새로운 파티션 추가하기&lt;/h2&gt;
&lt;p&gt;특정 디스크에 대해 &lt;code&gt;fdisk&lt;/code&gt; 명령을 실행하여 파티션 설정을 하려면 &lt;code&gt;fdisk &amp;lt;device name&amp;gt;&lt;/code&gt; 을 실행한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# fdisk /dev/vda
WARNING: DOS-compatible mode is deprecated. It’s strongly recommended to
switch off the mode (command ‘c’) and change display units to
sectors (command ‘u’).
Command (m for help):
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;m&lt;/code&gt; 을 입력하면 어떤 명령을 사용할 수 있는지 도움말을 확인할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Command (m for help): m
Command action
a toggle a bootable flag
b edit bsd disklabel
c toggle the dos compatibility flag
d delete a partition
l list known partition types
m print this menu
n add a new partition
o create a new empty DOS partition table
p print the partition table
q quit without saving changes
s create a new empty Sun disklabel
t change a partition’s system id
u change display/entry units
v verify the partition table
w write table to disk and exit
x extra functionality (experts only)
Command (m for help):
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;p&lt;/code&gt; 를 입력하면 현재 디스크 파티션 상태를 확인할 수 있다. fdisk -l 을 실행한 결과가 같은 내용을 확인할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Command (m for help): p
Disk /dev/vda: 85.9 GB, 85899345920 bytes
255 heads, 63 sectors/track, 10443 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x0005360e
   Device Boot      Start         End      Blocks   Id  System
/dev/vda1   *           1        1045     8387584   83  Linux
Command (m for help):
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;이제 &lt;code&gt;n&lt;/code&gt; 을 입력하여 새로운 파티션을 생성한다. primary partition 으로 생성하기 위해 &lt;code&gt;p&lt;/code&gt; 를 입력하고, 새로 생성되는 partition 은 2번째 partition 이므로 2 를 입력한다. 그리고 partition 의 크기를 지정하기 위해 First cylinder 와 Last cylinder 를 입력하는데 둘 모두 그냥 Enter 를 입력하여 default 로 설정한다. 그리고 마지막으로 파티션 생성 후 &lt;code&gt;p&lt;/code&gt; 를 입력하여 새로운 partition 정보를 확인한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Command (m for help): n
Command action
e extended
p primary partition (1–4)
p
Partition number (1–4): 2
First cylinder (1045–10443, default 1045):
Using default value 1045
Last cylinder, +cylinders or +size{K,M,G} (1045–10443, default 10443):
Using default value 10443
Command (m for help): p
Disk /dev/vda: 85.9 GB, 85899345920 bytes
255 heads, 63 sectors/track, 10443 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x0005360e
   Device Boot      Start         End      Blocks   Id  System
/dev/vda1   *           1        1045     8387584   83  Linux
/dev/vda2            1045       10443    75494789+  83  Linux
Command (m for help):
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;정상적으로 파티션 정보가 생성된 것을 확인한 후 &lt;code&gt;fdisk&lt;/code&gt; 를 나오기 위해 &lt;code&gt;w&lt;/code&gt; 를 입력한다. &lt;code&gt;fdisk&lt;/code&gt; 를 종료할 때 &lt;code&gt;w&lt;/code&gt; 와 &lt;code&gt;q&lt;/code&gt; 2가지 명령을 사용할 수 있는데 &lt;code&gt;w&lt;/code&gt; 는 변경된 내용을 실제 시스템에 적용한 후 종료하는 것이고 &lt;code&gt;q&lt;/code&gt; 는 작업한 내용을 적용하지 않고 종료하는 것이다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Command (m for help): w
The partition table has been altered!
Calling ioctl() to re-read partition table.
Syncing disks.
#
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Partition Type&lt;/h2&gt;
&lt;p&gt;fdisk prompt 에서 &lt;code&gt;l&lt;/code&gt; 을 입력하면 Partition type 들의 목록과 Partition Type 의 ID 를 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;Swap partition 은 82, Linux partition 은 83, FAT 는 b 또는 c, FreeBSD partition 은 a5 를 ID 로 사용한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Command (m for help): l
0  Empty           24  NEC DOS         81  Minix / old Lin bf  Solaris        
1  FAT12           39  Plan 9          82  Linux swap / So c1  DRDOS/sec (FAT-
2  XENIX root      3c  PartitionMagic  83  Linux           c4  DRDOS/sec (FAT-
3  XENIX usr       40  Venix 80286     84  OS/2 hidden C:  c6  DRDOS/sec (FAT-
4  FAT16 &amp;lt;32M      41  PPC PReP Boot   85  Linux extended  c7  Syrinx         
5  Extended        42  SFS             86  NTFS volume set da  Non-FS data    
6  FAT16           4d  QNX4.x          87  NTFS volume set db  CP/M / CTOS / .
7  HPFS/NTFS       4e  QNX4.x 2nd part 88  Linux plaintext de  Dell Utility   
8  AIX             4f  QNX4.x 3rd part 8e  Linux LVM       df  BootIt         
9  AIX bootable    50  OnTrack DM      93  Amoeba          e1  DOS access     
a  OS/2 Boot Manag 51  OnTrack DM6 Aux 94  Amoeba BBT      e3  DOS R/O        
b  W95 FAT32       52  CP/M            9f  BSD/OS          e4  SpeedStor      
c  W95 FAT32 (LBA) 53  OnTrack DM6 Aux a0  IBM Thinkpad hi eb  BeOS fs        
e  W95 FAT16 (LBA) 54  OnTrackDM6      a5  FreeBSD         ee  GPT            
f  W95 Ext&amp;#39;d (LBA) 55  EZ-Drive        a6  OpenBSD         ef  EFI (FAT-12/16/
10  OPUS            56  Golden Bow      a7  NeXTSTEP        f0  Linux/PA-RISC b
11  Hidden FAT12    5c  Priam Edisk     a8  Darwin UFS      f1  SpeedStor      
12  Compaq diagnost 61  SpeedStor       a9  NetBSD          f4  SpeedStor      
14  Hidden FAT16 &amp;lt;3 63  GNU HURD or Sys ab  Darwin boot     f2  DOS secondary  
16  Hidden FAT16    64  Novell Netware  af  HFS / HFS+      fb  VMware VMFS    
17  Hidden HPFS/NTF 65  Novell Netware  b7  BSDI fs         fc  VMware VMKCORE
18  AST SmartSleep  70  DiskSecure Mult b8  BSDI swap       fd  Linux raid auto
1b  Hidden W95 FAT3 75  PC/IX           bb  Boot Wizard hid fe  LANstep        
1c  Hidden W95 FAT3 80  Old Minix       be  Solaris boot    ff  BBT            
1e  Hidden W95 FAT1
Command (m for help):
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;특정 파티션을 Swap 용으로 사용하고 싶다면 해당 파티션의 타입을 82 로 지정해준다. 만약 3번 파티션을 Swap 으로 사용하고 싶다면 아래와 같이 차례대로 입력한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Command (m for help): t
Partition number (1–4): 3
Hex code (type L to list codes): 82
Changed system type of partition 3 to 82 (Linux swap)
Command (m for help):
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Boot partition 지정하기&lt;/h2&gt;
&lt;p&gt;Boot flag 를 설정하여 booting 가능한 파티션을 지정할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Command (m for help): a
Partition number (1–4): 1
Command (m for help):
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;파티션 정보를 확인하면 아래와 같이 1번 파티션에 Boot 항목이 설정되어 있음을 확인할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Command (m for help): p
Disk /dev/vda: 85.9 GB, 85899345920 bytes
255 heads, 63 sectors/track, 10443 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x0005360e
   Device Boot      Start         End      Blocks   Id  System
/dev/vda1   *           1        1045     8387584   83  Linux
/dev/vda2            1045       10443    75494789+  83  Linux
Command (m for help):
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;파티션 삭제하기&lt;/h2&gt;
&lt;p&gt;파티션을 삭제하려면 &lt;code&gt;d&lt;/code&gt; 를 입력한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Command (m for help): d
Partition number (1–4): 2
Command (m for help): w
The partition table has been altered!
Calling ioctl() to re-read partition table.
Syncing disks.
#
&lt;/pre&gt;&lt;/div&gt;</content><category term="linux"></category><category term="disk"></category><category term="partition"></category><category term="fdisk"></category></entry><entry><title>Linux에서 hostname 관리</title><link href="https://imjang57.github.io/garret/linux-hostname-management.html" rel="alternate"></link><published>2017-01-18T00:00:00+09:00</published><updated>2017-01-18T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-18:/garret/linux-hostname-management.html</id><summary type="html">&lt;p&gt;Linux에서 호스트명(hostname)을 확인 및 변경하는 방법&lt;/p&gt;</summary><content type="html">&lt;h1&gt;리눅스(Linux) 호스트명(Hostname) 관리&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Target : CentOS, Ubuntu&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;호스트명 조회&lt;/h2&gt;
&lt;p&gt;명령어를 실행해서 현재 호스트명 확인 :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ hostname
younghotestserver
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Redhat 리눅스에서 호스트명이 저장된 파일 확인 :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ cat /etc/sysconfig/network &lt;span class="p"&gt;|&lt;/span&gt; grep HOSTNAME
younghotestserver
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Ubuntu 리눅스에서 호스트명이 저장된 파일 확인 :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ cat /etc/hostname
younghotestserver
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;호스트명 변경&lt;/h2&gt;
&lt;p&gt;리눅스 호스트명 변경 :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ sudo hostname newhostname
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;또는&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ sudo &lt;span class="nb"&gt;echo&lt;/span&gt; newhostname &amp;gt; /proc/sys/kernel/hostname
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;이 방법은 리눅스가 재부팅될 경우 다시 이전 설정으로 되돌아 간다. 재부팅 후에도 유지되게 하려면 다음과 같이 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Redhat 리눅스 : &lt;code&gt;/etc/sysconfig/network&lt;/code&gt; 파일에서 HOSTNAME=호스트명 추가 또는 변경&lt;/li&gt;
&lt;li&gt;Ubuntu 리눅스 : &lt;code&gt;/etc/hostname&lt;/code&gt; 파일에서 호스트명 변경. 참고로 이 파일은 파일 내용 전체가 호스트명이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;호스트명을 변경하면 &lt;code&gt;/etc/hosts&lt;/code&gt; 파일도 같이 체크해주자. 이 파일은 IP 주소와 호스트명을 매핑하기 위한 정보가 포함되어 있다. 자기 자신을 가리키는 정보도 포함되어 있으므로 같이 수정해주는 것이 좋다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/etc/hosts&lt;/code&gt; 파일의 내용 :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;127.0.0.1    localhost    newhostname
::1          localhost    newhostname
&lt;/pre&gt;&lt;/div&gt;</content><category term="bash"></category><category term="linux"></category><category term="du"></category><category term="disk"></category></entry><entry><title>SSH Brute force 막기</title><link href="https://imjang57.github.io/garret/defence-ssh-brute-force.html" rel="alternate"></link><published>2017-01-12T00:00:00+09:00</published><updated>2017-01-12T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-12:/garret/defence-ssh-brute-force.html</id><summary type="html">&lt;p&gt;SSH Brute force 공격 시도를 막는 설정&lt;/p&gt;</summary><content type="html">&lt;h1&gt;ssh brute force 막기&lt;/h1&gt;
&lt;p&gt;AWS EC2 를 사용하고 있었는데 갑자기 인스턴스가 엄청나게 느려졌다. 확인해보니 SSH 연결 시도가 엄청나게 쌓이고 있었다. 인터넷에서 Source 주소를 입력해서 찾아보니 중국이라고 나오는데 그거는 뭐 알 수 없는 거고.. 어쨌든 Security Group 을 22번 포트에 대해 그냥 다 열어놨더니 이런 일이 발생했나보다. 그래도 진짜 공격 받아보긴 처음이네 ㅎㅎ..&lt;/p&gt;
&lt;p&gt;어쨌뜬 그래서 이 글에 brute force 방식으로 SSH 비밀번호를 해킹하려는 시도를 차단하기 위한 설정을 남긴다. (물론 AWS 인스턴스는 Security Group 을 내 주소로만 SSH 허용하도록 바꿔서 문제없지만 나중에 필요하게 될지 모르니....)&lt;/p&gt;
&lt;p&gt;brute force 공격이 들어오면 매번 로그인 시도때마다 SSH 서버의 Resource 가 소모되기 때문에 보안성이 좋은 비밀번호나 키를 사용하더라도 이를 방지해주는 것이 좋다.&lt;/p&gt;
&lt;p&gt;ssh port 로 20초간 5회 이상 접속을 시도하면 10분간 접속을 차단하는 iptables rule 을 만들어 보자.&lt;/p&gt;
&lt;p&gt;blacklist 와 ssh chain 생성:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# iptables -N blacklist
# iptables -N ssh
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;INPUT chain 에서 state module 로 ssh port 에 접속이 시작되면 ssh chain 으로 보낸다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# iptables -A INPUT -m state --state NEW -p tcp --dport ssh -j ssh
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;blacklist chain 에서는 recent module 로 "blacklist" 라는 목록에 접속 주소를 기록하고 접속을 거부한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# iptables -A blacklist -m recent --set --name blacklist
# iptables -A blacklist -j REJECT
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;ssh chain 은 다음과 같다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# iptables -A ssh -m recent --update --seconds 600 --hitcount 1 --name blacklist -j REJECT
# iptables -A ssh -m recent --set --name ssh
# iptables -A ssh -m recent --update --seconds 20 --hitcount 5 --name ssh -j blacklist
# iptables -A ssh -j ACCEPT
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;이 ssh chain 은 다음과 같이 동작한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;접속 주소가 이미 blacklist 에 들어 있고 지난 10분간 1회 이상 접속이 있었으면 접속을 거부한다.&lt;/li&gt;
&lt;li&gt;접속 주소를 "ssh" 목록이 기록한다.&lt;/li&gt;
&lt;li&gt;접속 주소가 이미 "ssh" 목록에 있으면, 지난 20초간 5회 이상 접속이 있었으면 blacklist chain 으로 보낸다.&lt;/li&gt;
&lt;li&gt;위의 3개가 다 통과하면 ssh 접속을 허락한다.&lt;/li&gt;
&lt;/ol&gt;</content><category term="ssh"></category><category term="iptables"></category><category term="brute force"></category></entry><entry><title>Linux lsof command</title><link href="https://imjang57.github.io/garret/linux-command-lsof.html" rel="alternate"></link><published>2017-01-12T00:00:00+09:00</published><updated>2017-01-12T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-12:/garret/linux-command-lsof.html</id><summary type="html">&lt;p&gt;lsof 명령어에 대한 설명&lt;/p&gt;</summary><content type="html">&lt;h1&gt;lsof&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;lsof&lt;/code&gt; 는 "list open files"의 약자로 시스템에서 열린 파일 목록을 알려주고 사용하는 프로세스, 디바이스 정보, 파일의 종류등 상세한 정보를 출력해주는 명령어(Command)이다.&lt;/p&gt;
&lt;p&gt;리눅스와 유닉스는 추상화된 파일 시스템(VFS - Virtual File System)을 사용하므로 일반 파일, 디렉터리, 네트워크 소켓, 라이브러리, 심볼릭 링크 등도 모두 파일로 처리되며 &lt;code&gt;lsof&lt;/code&gt; 에서 상세한 정보를 확인할 수 있다.&lt;/p&gt;
&lt;h2&gt;모든 열린 파일 출력&lt;/h2&gt;
&lt;p&gt;옵션 없이 &lt;code&gt;lsof&lt;/code&gt; 명령을 실행하면 모든 열린 파일 정보를 출력한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ lsof
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;컬럼별 의미는 다음과 같다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;COMMAND&lt;/code&gt; : 실행한 명령어&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PID&lt;/code&gt; : process id&lt;/li&gt;
&lt;li&gt;&lt;code&gt;USER&lt;/code&gt; : 실행한 사용자&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FD&lt;/code&gt; : File Descriptor, 파일의 종류. &lt;ol&gt;
&lt;li&gt;&lt;code&gt;cwd&lt;/code&gt; : current working directory&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rtd&lt;/code&gt; : root directory&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mem&lt;/code&gt; : memory-mapped file&lt;/li&gt;
&lt;li&gt;&lt;code&gt;txt&lt;/code&gt; : program text (code and data);&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TYPE&lt;/code&gt; : 파일 종류&lt;ol&gt;
&lt;li&gt;&lt;code&gt;DIR&lt;/code&gt; : 디렉터리&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CHR&lt;/code&gt; :  character special file&lt;/li&gt;
&lt;li&gt;&lt;code&gt;REG&lt;/code&gt; : regular file&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unix&lt;/code&gt; : 유닉스 도메인 소켓 (MySQL 등이 사용하는 소켓으로 로컬 프로세스에서만 사용 가능하며 TCP/UDP 보다 속도가 매우 빠름)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DEVICE&lt;/code&gt; : 장치 번호&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SIZE/OFF&lt;/code&gt;: 파일의 크기나 오프셋&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NODE&lt;/code&gt;: 노드 번호&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NAME&lt;/code&gt;:  파일명&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;특정 사용자에 의해 열린 파일 출력&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;-u&lt;/code&gt; 옵션으로 사용자를 지정할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ lsof -u myuser
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;^&lt;/code&gt;를 추가하면 특정 사용자는 제외할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ lsof -u ^myuser
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;동시에 사용할 수도 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ lsof -u myuser -u ^root -u ^daemon
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;특정 프로세스가 오픈한 파일 확인&lt;/h2&gt;
&lt;p&gt;프로세스(Process)의 PID로 확인 :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ lsof -p 1234
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;특정 파일을 사용하는 프로세스 확인 :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ lsof /var/log/httpd/access_log
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;특정 디렉터리 내 열린 파일 확인 :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ lsof +D /tmp
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;특정 포트를 사용하는 프로세스 확인 :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ lsof -i TCP:22
$ lsof -i TCP:22-80
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;특정 명령어가 사용하는 포트 확인 :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ lsof -c httpd
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Service Name 대신 port 번호 확인&lt;/h2&gt;
&lt;p&gt;IANA 에 등록한 well known 포트는 &lt;code&gt;/etc/services&lt;/code&gt; 파일에 지정되어 있으므로 서비스를 파악하기 용이하다. 하지만 자체 개발한 서비스가 &lt;code&gt;/etc/services&lt;/code&gt; 파일에 등록된 포트를 사용할 경우에는 서비스 이름보다 포트 번호로 표시하는 게 낫다. &lt;code&gt;-P&lt;/code&gt; 옵션을 사용하면 서비스 이름대신 포트 번호로 표시해 준다.&lt;/p&gt;
&lt;p&gt;예로 java 로 서비스하고 있는 모든 listen 하는 포트를 표시하려면 아래 명령을 실행한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ lsof -i TCP -P &lt;span class="p"&gt;|&lt;/span&gt; grep java &lt;span class="p"&gt;|&lt;/span&gt; grep LISTEN
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;IPv4 또는 IPv6 포트만 확인 :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ lsof -i 4
$ lsof -i 6
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;열려 있는 모든 네트워크 포트 확인 :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ lsof -i
$ lsof -i TCP
$ lsof -i UDP
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;특정 사용자가 오픈한 모든 프로세스 중지&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;-t&lt;/code&gt; 옵션은 자세한 정보를 출력하지 않고 pid 정보만 출력한다. 다음 명령은 imjang57 사용자로 구동한 프로세스의 id 를 리턴한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;lsof -t -u imjang57
13324
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;이를 응용하여 &lt;code&gt;kill&lt;/code&gt; 명령어에 pid 만 전달할 수 있으므로 아래와 같이 사용하면 imjang57 사용자의 모든 프로세스를 중지하게 된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;kill -KILL $(lsof -t -u imjang57
&lt;/pre&gt;&lt;/div&gt;</content><category term="linux"></category><category term="lsof"></category></entry><entry><title>SSH Host-key identification</title><link href="https://imjang57.github.io/garret/ssh-host-key-identification.html" rel="alternate"></link><published>2017-01-10T00:00:00+09:00</published><updated>2017-01-11T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-10:/garret/ssh-host-key-identification.html</id><summary type="html">&lt;p&gt;This is about SSH Host-key identification.&lt;/p&gt;</summary><content type="html">&lt;h1&gt;SSH host key&lt;/h1&gt;
&lt;p&gt;가끔 SSH Client 로 Remote 에 있는 SSH Server 에 접속할 때 아래와 같은 에러를 볼 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;imjang57@myserver:~$ ssh administrator@192.168.0.5
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!              @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now &lt;span class="o"&gt;(&lt;/span&gt;man-in-the-middle
attack&lt;span class="o"&gt;)&lt;/span&gt;!
It is also possible that a host key has just been changed.
The fingerprint &lt;span class="k"&gt;for&lt;/span&gt; the ECDSA key sent by the remote host is
bf:e3:d3:21:c4:3c:60:cd:d9:2b:bb:a4:d1:6e:1f:df.
Please contact your system administrator.
Add correct host key in /home/imjang57/.ssh/known_hosts to get rid of
this message.
Offending ECDSA key in /home/imjang57/.ssh/known_hosts:8
  remove with: ssh-keygen -f &lt;span class="s2"&gt;&amp;quot;/home/imjang57/.ssh/known_hosts&amp;quot;&lt;/span&gt; -R
192.168.0.5
ECDSA host key &lt;span class="k"&gt;for&lt;/span&gt; 192.168.0.5 has changed and you have
requested strict checking.
Host key verification failed.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;em&gt;Host Key&lt;/em&gt; 가 달라서 발생하는 문제다. 자세히 말하면, 클라이언트 측에 등록된 SSH 서버의 호스트 키가 현재 접속 시도하면서 새롭게 받은 호스크 키와 달라서 발생한 문제이다.&lt;/p&gt;
&lt;p&gt;SSH 서버에서 호스트 키를 새롭게 생성했거나, 클라이언트 측에서 SSH 서버의 호스트 키를 수동으로 입력했는데 잘못입력했거나, 서버를 재설치했거나, 기타 등등의 이유로 기존에 저장된 호스트 키와 연결시도하면서 새롭게 받은 호스트 키가 다를 수 있다.&lt;/p&gt;
&lt;p&gt;이는 SSH 연결을 시도하는 서버가 정말 내가 연결하려는 서버가 맞는지를 체크할 수 있는 기능이다. HTTPS 를 사용할 때 신뢰할 수 있는 사이트인지 확인하는 것과 비슷한 이유로 제공되는 기능이다.&lt;/p&gt;
&lt;h2&gt;해결 방법&lt;/h2&gt;
&lt;p&gt;해결하는 방법은 여러개가 있다.&lt;/p&gt;
&lt;h3&gt;known_host 삭제하여 해결&lt;/h3&gt;
&lt;p&gt;보통 사용자의 홈 디렉터리에 .ssh 라는 디렉터리가 있고, 여기에 사용자를 위한 SSH 설정이나 사용자 인증을 위한 키 파일이 저장된다. 그리고 &lt;user_home&gt;/.ssh 디렉터리 밑에 known_hosts 라는 파일이 있는데 여기에 SSH 서버의 호스트 키들이 저장되어 있다. 여기서 에러가 나는 SSH 서버의 호스트 키를 삭제하면 다시 연결할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ssh-keygen -f &lt;span class="s2"&gt;&amp;quot;/home/imjang57/.ssh/known_hosts&amp;quot;&lt;/span&gt; -R 192.168.0.5
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;위 명령으로 저장된 서버의 호스트 키를 삭제한 후 SSH 서버에 다시 접속하면 아래와 같이 호스트 키를 등록하냐고 물어보는 메시지가 나타난다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;imjang57@myserver:~$ ssh administrator@192.168.0.5
The authenticity of host &lt;span class="s1"&gt;&amp;#39;192.168.0.5&amp;#39;&lt;/span&gt; can&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;t be established.
ECDSA key fingerprint is
bf:e3:d3:21:c4:3c:60:cd:d9:2b:bb:a4:d1:6e:1f:df.
Are you sure you want to &lt;span class="k"&gt;continue&lt;/span&gt; connecting &lt;span class="o"&gt;(&lt;/span&gt;yes/no&lt;span class="o"&gt;)&lt;/span&gt;?
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;yes 를 입력하면 호스트 키를 &lt;user_home&gt;/.ssh/known_hosts 파일에 저장하고 SSH 접속하게 된다.&lt;/p&gt;
&lt;p&gt;만약 명령어 치는게 귀찮으면 그냥 known_hosts 파일 삭제하면 된다.&lt;/p&gt;
&lt;h3&gt;StrictHostKeyChecking 설정을 off 하여 해결&lt;/h3&gt;
&lt;p&gt;리눅스에서 ssh 설정은 보통 &lt;code&gt;/etc/ssh&lt;/code&gt; 디렉터리에 있다. &lt;code&gt;ssh_config&lt;/code&gt; 파일은 클라이언트 설정 파일, &lt;code&gt;sshd_config&lt;/code&gt; 는 서버(데몬) 설정 파일이다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ssh_config&lt;/code&gt; 파일에서 아래 내용을 찾아서 호스트 키 검사를 하지 않도록 설정하면 된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;StrictHostKeyChecking no
&lt;span class="nv"&gt;UserKnownHostsFile&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/dev/null
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;호스트 키 새로 생성하는 방법&lt;/h2&gt;
&lt;p&gt;서버를 운영하는 입장에서 서버를 추가할 때 기존 서버의 이미지를 사용해서 새로운 서버를 구성할 수 있다. 이 때 호스트 키를 새롭게 생성해야 한다.&lt;/p&gt;
&lt;p&gt;호스트 키는 보통 &lt;code&gt;/etc/ssh&lt;/code&gt; 에 저장되어 있다. &lt;em&gt;RSA&lt;/em&gt;, &lt;em&gt;DSA&lt;/em&gt;, &lt;em&gt;ECDSA&lt;/em&gt; 세 가지 종류의 키 파일들이 보통 생성되어 있다.&lt;/p&gt;
&lt;p&gt;새로 호스트 키를 생성하기 위해 아래 명령을 실행해서 세 가지 종류의 호스트 키 파일들을 생성하면 된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo ssh-keygen -f /etc/ssh/ssh_host_rsa_key -N &lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt; -t rsa
sudo ssh-keygen -f /etc/ssh/ssh_host_dsa_key -N &lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt; -t dsa
sudo ssh-keygen -f /etc/ssh/ssh_host_ecdsa_key -N &lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt; -t ecdsa -b 521
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;기존에 파일들이 있으면 overwrite 할 거냐고 묻는데 당연히 &lt;code&gt;y&lt;/code&gt; 를 입력하자.&lt;/p&gt;</content><category term="ssh"></category></entry><entry><title>Git Basics</title><link href="https://imjang57.github.io/garret/git-basics.html" rel="alternate"></link><published>2017-01-05T00:00:00+09:00</published><updated>2017-01-05T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-05:/garret/git-basics.html</id><summary type="html">&lt;p&gt;Git 기본 사용법&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Git Basic&lt;/h1&gt;
&lt;p&gt;이 글은 Git 에 대해 기본적인 내용은 알고 있다고 생각하고 정리 목적으로 작성된 글이니 Git 을 아예 모르면 &lt;a href="http://git-scm.com/book/"&gt;Git Book&lt;/a&gt; 을 먼저 숙지하자.&lt;/p&gt;
&lt;p&gt;아래 내용들에 알면 Git 을 잘 사용하기 위한 개념들은 다 알고 있다고 봐도 된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;VCS (Version Control System), DVCS (Distributed Version Control System)&lt;/li&gt;
&lt;li&gt;Working tree, Staging Area (Index), Local Repository, Remote Repository, Bare Repository&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;git help&lt;/code&gt; 명령을 실행하면 사용 가능한 subcommand 들을 확인할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ git &lt;span class="nb"&gt;help&lt;/span&gt;
usage: git &lt;span class="o"&gt;[&lt;/span&gt;--version&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;--help&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;-C &amp;lt;path&amp;gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;-c &lt;span class="nv"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;value&lt;span class="o"&gt;]&lt;/span&gt;
           &lt;span class="o"&gt;[&lt;/span&gt;--exec-path&lt;span class="o"&gt;[=&lt;/span&gt;&amp;lt;path&amp;gt;&lt;span class="o"&gt;]]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;--html-path&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;--man-path&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;--info-path&lt;span class="o"&gt;]&lt;/span&gt;
           &lt;span class="o"&gt;[&lt;/span&gt;-p &lt;span class="p"&gt;|&lt;/span&gt; --paginate &lt;span class="p"&gt;|&lt;/span&gt; --no-pager&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;--no-replace-objects&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;--bare&lt;span class="o"&gt;]&lt;/span&gt;
           &lt;span class="o"&gt;[&lt;/span&gt;--git-dir&lt;span class="o"&gt;=&lt;/span&gt;&amp;lt;path&amp;gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;--work-tree&lt;span class="o"&gt;=&lt;/span&gt;&amp;lt;path&amp;gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;--namespace&lt;span class="o"&gt;=&lt;/span&gt;&amp;lt;name&amp;gt;&lt;span class="o"&gt;]&lt;/span&gt;
           &amp;lt;command&amp;gt; &lt;span class="o"&gt;[&lt;/span&gt;&amp;lt;args&amp;gt;&lt;span class="o"&gt;]&lt;/span&gt;

These are common Git commands used in various situations:

start a working area &lt;span class="o"&gt;(&lt;/span&gt;see also: git &lt;span class="nb"&gt;help&lt;/span&gt; tutorial&lt;span class="o"&gt;)&lt;/span&gt;
   clone      Clone a repository into a new directory
   init       Create an empty Git repository or reinitialize an existing one

work on the current change &lt;span class="o"&gt;(&lt;/span&gt;see also: git &lt;span class="nb"&gt;help&lt;/span&gt; everyday&lt;span class="o"&gt;)&lt;/span&gt;
   add        Add file contents to the index
   mv         Move or rename a file, a directory, or a symlink
   reset      Reset current HEAD to the specified state
   rm         Remove files from the working tree and from the index

examine the &lt;span class="nb"&gt;history&lt;/span&gt; and state &lt;span class="o"&gt;(&lt;/span&gt;see also: git &lt;span class="nb"&gt;help&lt;/span&gt; revisions&lt;span class="o"&gt;)&lt;/span&gt;
   bisect     Use binary search to find the commit that introduced a bug
   grep       Print lines matching a pattern
   log        Show commit logs
   show       Show various types of objects
   status     Show the working tree status

grow, mark and tweak your common &lt;span class="nb"&gt;history&lt;/span&gt;
   branch     List, create, or delete branches
   checkout   Switch branches or restore working tree files
   commit     Record changes to the repository
   diff       Show changes between commits, commit and working tree, etc
   merge      Join two or more development histories together
   rebase     Reapply commits on top of another base tip
   tag        Create, list, delete or verify a tag object signed with GPG

collaborate &lt;span class="o"&gt;(&lt;/span&gt;see also: git &lt;span class="nb"&gt;help&lt;/span&gt; workflows&lt;span class="o"&gt;)&lt;/span&gt;
   fetch      Download objects and refs from another repository
   pull       Fetch from and integrate with another repository or a &lt;span class="nb"&gt;local&lt;/span&gt; branch
   push       Update remote refs along with associated objects

&lt;span class="s1"&gt;&amp;#39;git help -a&amp;#39;&lt;/span&gt; and &lt;span class="s1"&gt;&amp;#39;git help -g&amp;#39;&lt;/span&gt; list available subcommands and some
concept guides. See &lt;span class="s1"&gt;&amp;#39;git help &amp;lt;command&amp;gt;&amp;#39;&lt;/span&gt; or &lt;span class="s1"&gt;&amp;#39;git help &amp;lt;concept&amp;gt;&amp;#39;&lt;/span&gt;
to &lt;span class="nb"&gt;read&lt;/span&gt; about a specific subcommand or concept.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;git help commit&lt;/code&gt; 이나 &lt;code&gt;git commit --help&lt;/code&gt; 와 같이 subcommand 자체에 대한 help 도 확인할 수 있으니 필요할 때마다 help 를 활용하자.&lt;/p&gt;
&lt;h1&gt;Git configuration&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;Git&lt;/em&gt; 설정을 적용하는 방법은 2가지가 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git config&lt;/code&gt; command 를 사용하는 방법&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.gitconfig&lt;/code&gt; 파일에 추가하는 방법&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;git config&lt;/code&gt; 명령을 사용하면 git 프로그램이 자동으로 &lt;code&gt;.gitconfig&lt;/code&gt; 파일에 해당 설정을 추가하는 것이기 때문에 결과는 같다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git config&lt;/code&gt; command:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git config --global user.name &lt;span class="s2"&gt;&amp;quot;imjang57&amp;quot;&lt;/span&gt;
git config --global user.email &lt;span class="s2"&gt;&amp;quot;imjang57@gmail.com&amp;quot;&lt;/span&gt;
git config --global color.ui auto
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;git config file (&lt;code&gt;~/.gitconfig&lt;/code&gt;):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;[user]&lt;/span&gt;
    &lt;span class="na"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;imjang57&lt;/span&gt;
&lt;span class="s"&gt;    email = imjang57@gmail.com&lt;/span&gt;
&lt;span class="k"&gt;[color]&lt;/span&gt;
    &lt;span class="na"&gt;ui&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;auto&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;위에서 &lt;code&gt;git config --global&lt;/code&gt; 과 같이 global option 을 전달했기 때문에 &lt;code&gt;~/.gitconfig&lt;/code&gt; 파일에 설정이 저장되었다. 만약 특정 Git repository 에만 설정을 적용하고 싶으면 해당 Local git repository 의 working directory 로 가서 &lt;code&gt;git config --local&lt;/code&gt; 과 같이 local option 을 사용하면 된다. 그러면 &lt;code&gt;&amp;lt;PROJECT_HOME&amp;gt;/.git/config&lt;/code&gt; 에 설정이 저장된다.&lt;/p&gt;
&lt;p&gt;현재의 git 설정들을 확인하고 싶다면 &lt;code&gt;git config --list&lt;/code&gt; 와 같이 실행한다. 만약 범위를 좁히고 싶다면 &lt;code&gt;git config --list --system&lt;/code&gt;, &lt;code&gt;git config --list --global&lt;/code&gt;, &lt;code&gt;git config --list --local&lt;/code&gt; 와 같이 실행할 수도 있다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;아래 설정은 git 이 실행할 텍스트 에디터 명령을 지정한다. commit message 작성 등을 위해 사용된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git config --global core.editor &amp;quot;\&amp;quot;C:\Windows\notepad.exe\&amp;quot;&amp;quot;
git config --global core.editor &amp;quot;nano&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr&gt;
&lt;p&gt;아래 설정은 proxy 를 설정한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git config --global http.proxy http://&amp;lt;username&amp;gt;:&amp;lt;password&amp;gt;@&amp;lt;host&amp;gt;:&amp;lt;port&amp;gt;
git config --global https.proxy http://&amp;lt;username&amp;gt;:&amp;lt;password&amp;gt;@&amp;lt;host&amp;gt;:&amp;lt;port&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;만약 프록시 서버가 별도의 인증서가 필요하면 다음과 같은 설정으로 인증서 파일을 추가한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git config --global http.sslCAInfo /path/to/mycertification.crt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;아니면 다음과 같이 ssl 인증서에 대한 validation 을 하지 않도록 설정할 수도 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git config http.sslVerify &lt;span class="nb"&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr&gt;
&lt;p&gt;아래 설정은 git 에서 사용하는 scheme 을 강제로 변환하기 위해 사용된다. 아래와 같이 설정하면 git scheme 을 https 로 바꿔서 사용하게 된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git config --global url.&lt;span class="s2"&gt;&amp;quot;https://&amp;quot;&lt;/span&gt;.insteadOf git://
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Git basic usage&lt;/h1&gt;
&lt;h2&gt;Git Local Repository 생성&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;새로운 git repository 생성 : &lt;code&gt;git init&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;명령어를 실행한 경로에 &lt;code&gt;.git&lt;/code&gt; 이라는 디렉터리가 생성되어 repository 관리 정보가 저장된다. &lt;code&gt;git init&lt;/code&gt; 명령을 실행한 디렉터리의 내용을 &lt;em&gt;Working Tree&lt;/em&gt; 라고 한다. working tree 의 변경 내용이 있을 때 &lt;code&gt;git add&lt;/code&gt;, &lt;code&gt;git rm&lt;/code&gt; 등을 실행하면 &lt;em&gt;Index&lt;/em&gt; 가 생성된다. &lt;code&gt;git commit&lt;/code&gt; 을 실행하면 local branch 에 변경 내용이 적용된다. &lt;code&gt;git push&lt;/code&gt; 를 실행하면 remote repository 에 변경된 내용을 추가한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Remote Repository 추가 : &lt;code&gt;git remote add &amp;lt;remote repository name&amp;gt; &amp;lt;Remote Repository URL&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;git init&lt;/code&gt; 후에 &lt;code&gt;git remote add&lt;/code&gt; 를 통해 remote repoistory 를 추가할 수 있다. 이후 &lt;code&gt;git fetch&lt;/code&gt; 을 실행하면 remote repository 의 정보를 읽어서 local repository 에 동기화한다. 그런데 &lt;code&gt;git fetch&lt;/code&gt;는 working tree 에 이 정보들을 적용하지는 않는다. 단지 local repository (&lt;code&gt;.git&lt;/code&gt; directory) 에만 정보를 저장한다. &lt;code&gt;git remote add origin ssh://user@host:22/repos/project&lt;/code&gt; 로 remote repository 를 등록했으면 &lt;code&gt;git merge origin/master&lt;/code&gt; 를 실행해서 merge 해야만 working tree 에 최신 정보가 적용된다. 만약 이 과정이 귀찮으면 그냥 &lt;code&gt;git pull&lt;/code&gt; 을 실행하면 된다. &lt;code&gt;git pull&lt;/code&gt; 은 &lt;code&gt;git fetch&lt;/code&gt; 와 &lt;code&gt;git merge&lt;/code&gt; 를 한꺼번에 실행해준다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Git Local Repository 를 만드는 다른 방법은 Remote Repository 를 복사하는 것이다. &lt;code&gt;git clone &amp;lt;url&amp;gt; [target directory]&lt;/code&gt; 을 실행하면 remote repository 를 복사한다. target directory 를 지정해주지 않으면 remote repository 의 이름으로 target directory 가 생성된다.&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;remote repository 목록 확인 : &lt;code&gt;git remote&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;URL 포함하여 remote repository 목록 확인 : &lt;code&gt;git remote -v&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;remote repository 상세 정보 확인 : &lt;code&gt;git remote show [remote repository name]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;remote repository 를 삭제 : &lt;code&gt;git remote rm &amp;lt;remote repository name&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;remote repository 의 이름 변경 : &lt;code&gt;git remote rename &amp;lt;from_name&amp;gt; &amp;lt;to_name&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2&gt;Bare repository&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;git init&lt;/code&gt; 을 실행할 때 &lt;code&gt;--bare&lt;/code&gt; 옵션을 추가하면 &lt;em&gt;Bare repository&lt;/em&gt; 를 생성한다. &lt;em&gt;Bare repository&lt;/em&gt; 는 저장소 역할만 한다. 즉, &lt;em&gt;Working directory&lt;/em&gt; 가 생성되지 않으며, 읽기 작업만 가능하다. &lt;code&gt;git init --bare &amp;lt;repository name&amp;gt;&lt;/code&gt; 으로 생성된 repository 에는 보통 &lt;code&gt;.git&lt;/code&gt; 디렉터리에 생성되는 파일들이 그대로 생성된다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Bare repository&lt;/em&gt; 는 코드 공유 및 협업을 위한 서버에 생성되는 저장소로 사용되며 각 개발자들은 이 &lt;em&gt;Bare repository&lt;/em&gt; 를 clone 하여 각자의 작업을 진행한다.&lt;/p&gt;
&lt;h2&gt;Managing Modifications in local repository&lt;/h2&gt;
&lt;p&gt;Git 으로 변경사항들을 관리하기 위한 기본적인 명령들을에는 status, add, rm, mv, commit, stash, diff 등이 있다.&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;repository 상태 (현재 branch, 변경 내역 등) 확인 : &lt;code&gt;git status&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;staging area (index) 에 파일 추가 : &lt;code&gt;git add &amp;lt;file&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;새롭게 생성된 Untracked files 나 modificated files 는 &lt;code&gt;git commit&lt;/code&gt; 전에 &lt;code&gt;git add&lt;/code&gt; 로 staging area 에 등록해야 한다. staging area 는 commit 전에 존재하는 임시 영역이다.&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;git repository 에 변경 내용을 기록 : &lt;code&gt;git commit [-m "messages"]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Staging area 에 기록된 파일들을 실제 repository 에 반영하는 작업이다. -m 옵션이 없다면 git 환경설정에서 지정된 editor 가 실행되고 자세한 로그를 작성할 수 있다. 관례적으로 첫 번째 줄에는 로그에 대한 한 줄 요약을 작성하고 두 번째 줄은 공백, 세 번째 줄부터 상세 내용을 작성한다. 아무것도 입력하지 않고 editor 를 종료하면 commit 이 취소된다.&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;working tree 와 staging area 의 차이를 확인 : &lt;code&gt;git diff&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;staging area 와 laest commit 의 차이를 확인 : &lt;code&gt;git diff --staged&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;working tree 와 최신 commit 의 차이를 확인 : &lt;code&gt;git diff HEAD&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;특정 branch 와 master branch 간의 diff 확인 : &lt;code&gt;git diff master..&amp;lt;branch name&amp;gt; [path]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;staging area 의 파일 삭제 : &lt;code&gt;git rm &amp;lt;path/to&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;특정 파일을 staging area 에서 삭제하지만 working tree 에는 보존 : &lt;code&gt;git rm --cached &amp;lt;path/to&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;파일 이동 : &lt;code&gt;git mv &amp;lt;from_file&amp;gt; &amp;lt;to_file&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;현재의 모든 변경 내용을 임시 저장하기 : &lt;code&gt;git stash&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;가장 최근의 임시 저장된 내용을 다시 적용하기 : &lt;code&gt;git stash pop&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;현재 임시 저장된 목록을 출력 : &lt;code&gt;git stash list&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;가장 최근의 임시 저장된 내용을 삭제 : &lt;code&gt;git stash drop&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Igrnoring files&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;.gitigrnore&lt;/code&gt; 파일에 무시할 파일들의 리스트를 추가하면 이후 추가된 파일들은 git add 등으로 변경 내용을 index 에 적용할 때 무시된다. 디렉터리마다 &lt;code&gt;.gitignore&lt;/code&gt; 파일을 생성할 수 있으며 해당 디렉터리부터 하위 디렉터리 들에 대해 파일의 내용이 적용된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;*.[oa]       # ignore files ending in &amp;quot;.o&amp;quot; or &amp;quot;.a&amp;quot;
!lib.a       # do track lib.a, even though you&amp;#39;re ignoring .a files above
*~           # ignore files ending in tilde(&amp;quot;~&amp;quot;)
/TODO        # only ignore the root TODO file, not subdir/TODO
build/       # ignore all files in the build/ directory
doc/*.txt    # ignore doc/notes.txt, but not doc/server/arch.txt
doc/**/*.txt # ignore all &amp;quot;*.txt&amp;quot; files in the doc/ directory
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;.gitignore&lt;/code&gt; 파일의 다른 용도는 empty directory 를 repository 에 저장하기 위해 사용된다. git 은 빈 디렉터리는 저장소에 저장하지 않는다. 이때 빈 디렉터리 안에 임의의 빈 &lt;code&gt;.gitignore&lt;/code&gt; 파일을 생성하여 commit 하면 해당 디렉터리도 저장소에 추가할 수 있다.&lt;/p&gt;
&lt;h2&gt;Viewing the Commit History&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;commit history 확인 : &lt;code&gt;git log [/path/to]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;commit 에서 변경된 내용도 같이 확인 : - &lt;code&gt;git log -p [/path/to]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;마지막 2개의 내용만 확인 : &lt;code&gt;git log -2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;한줄 요약으로 보기 : &lt;code&gt;git log --pretty=oneline&lt;/code&gt;, &lt;code&gt;git log --oneline&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Commit graph 를 같이 확인 : &lt;code&gt;git log --graph&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Commit 에 대한 Reference 정보 추가 : &lt;code&gt;git log --decorate&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;전체 또는 특정 branch 에 대한 Commit 정보 확인 : &lt;code&gt;git log --branch[=&amp;lt;pattern&amp;gt;]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;master branch 에 없고 feature-A branch 에 존재하는 commit 들을 확인 : &lt;code&gt;git log master..feature-A&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;전체 branch 의 commit 들을 commit graph 와 Reference 정보를 추가하여 한줄만 확인하려면 &lt;code&gt;git log --branches --graph --decoraete --oneline&lt;/code&gt; 을 실행하면 된다.&lt;/p&gt;
&lt;p&gt;특정 파일의 version history list 를 확인하려면 &lt;code&gt;git log --follow [file]&lt;/code&gt; 를 실행한다. git 나름대로 rename 한 작업까지 계산해준다.&lt;/p&gt;
&lt;h2&gt;Working with Remote Repository&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;git pull&lt;/code&gt;, &lt;code&gt;git fetch&lt;/code&gt;, &lt;code&gt;git merge&lt;/code&gt;, &lt;code&gt;git push&lt;/code&gt; 를 통해 remote repository 와 동기화할 수 있다.&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;Remote Repository 의 변경 내용들을 Local Repository 로 갱신 : &lt;code&gt;git pull&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;원격 저장소의 변경 내용이 로컬 작업 디렉토리에 받아지고(fetch), 병합(merge)된다. &lt;code&gt;git pull&lt;/code&gt; 은 내부적으로 아래의 두 명령이 연속적으로 실행된 것과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git fetch &amp;lt;remote repository name&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git merge &amp;lt;remote repository name&amp;gt;/master&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;Local Repository 의 commit 들을 Remote Repository 에 전달 : &lt;code&gt;git push [remote repository] [remote branch]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Remote Repository 이름이 origin 이고, origin 의 master branch 로 Local Repository 의 변경 내용을 올리려고 하면 &lt;code&gt;git push origin master&lt;/code&gt; 를 실행한다.&lt;/p&gt;
&lt;h2&gt;Branch and Merge&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;branch 목록 출력 및 현재 작업 중인 branch 확인 : &lt;code&gt;git branch&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Remote Repository 의 branch 들을 모두 포함하여 출력 : &lt;code&gt;git branch -a&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;branch 생성 : &lt;code&gt;git branch &amp;lt;branch name&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;branch 변경 : &lt;code&gt;git checkout &amp;lt;branch name&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;branch 생성 및 변경 : &lt;code&gt;git checkout -b &amp;lt;branch name&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;만약 feature-A 라는 이름의 branch를 생성하고 해당 branch 로 변경하고 싶으면 &lt;code&gt;git checkout -b feature-A&lt;/code&gt; 을 실행한다. 이는 다음 명령어 들을 연속으로 실행한 것과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git branch feature-A&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git checkout feature-A&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이후 master branch 로 돌아오려면 &lt;code&gt;git checkout master&lt;/code&gt; 를 실행한다. 만약 현재 branch 를 사용하기 전의 branch 로 되돌아가려면 &lt;code&gt;git checkout -&lt;/code&gt; 를 실행하면 된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;branch 삭제 : &lt;code&gt;git branch -d &amp;lt;branch name&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;branch 를 merge 하기 : &lt;code&gt;git merge [options] &amp;lt;branch name&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;만약 구현이 완료된 feature-A branch 를 merge 하려면 base branch(보통 master 또는 development)에서 &lt;code&gt;git merge feature-A&lt;/code&gt; 를 실행한다.&lt;/p&gt;
&lt;h2&gt;Resolve conflicts&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;git pull&lt;/code&gt;, &lt;code&gt;git merge&lt;/code&gt; 등을 하다보면 내가 변경하고 commit 한 내용과 다른 사람이 변경하고 commit 한 내용이 서로 충돌하는 경우가 발생한다. 대부분의 경우 git 이 자동으로 바뀐 부분을 알아서 적용해준다. 하지만 만약 서로 다른 사람들이 파일의 같은 부분을 동시에 고쳤을 경우, git 이 해결하지 못하고 충돌이 발생했음을 알려준다.&lt;/p&gt;
&lt;p&gt;이렇게 충돌이 발생하면, git이 알려주는 파일의 충돌 부분을 직접 수정해서 병합이 가능하도록 수정해야 한다. 충돌을 해결했다면, &lt;code&gt;git add [file path]&lt;/code&gt; 를 실행하여 수정된 부분을 다시 index 에 저장하고 commit 한다.&lt;/p&gt;
&lt;p&gt;변경 내용을 병합하기 전에, &lt;code&gt;git diff&lt;/code&gt; 를 사용하여 어떻게 바뀌었는지 비교해보는 것이 좋다.&lt;/p&gt;
&lt;h2&gt;Rebase&lt;/h2&gt;
&lt;p&gt;보통 &lt;code&gt;git merge&lt;/code&gt; 를 실행하면 작업 내용이 특정 parent commit 에서 분기되지 않았으면 &lt;em&gt;fast forward&lt;/em&gt; 방식이라고 해서 그대로 commit 내용을 가져 온 후 HEAD Reference 를 가장 최신의 commit 으로 변경한다.&lt;/p&gt;
&lt;p&gt;하지만 특정 parent commit 에서 작업 내용이 분기된 경우 &lt;code&gt;git merge&lt;/code&gt; 는 Base commit 으로부터 분기된 두 작업 내용을 합쳐서 새로운 commit 을 생성한다. 즉, parent commit 이 2개인 새로운 commit 이 생성되는 것이다. 이 경우 merge 한 내용을 commit history 나 graph 로 확인할 때 복잡해질 수 있다. 때문에 merge 전에 rebase 를 하도록 권장하기도 한다. 단, 이는 각 팀에 따라 다를 수 있다. 어떤 팀은 그냥 merge 를 할 수 있고 어떤 팀은 rebase 를 장려할 수도 있다. 필수는 아니다.&lt;/p&gt;
&lt;p&gt;만약 feature-A branch 에서 기능 개발 완료 후 master 로 merge 전에 rebase 를 하여 commit history 를 정리하고 싶다면 feature-A branch 에서 &lt;code&gt;git rebase master&lt;/code&gt; 를 실행한다. 그 후 master branch 로 전환한 후 &lt;code&gt;git merge feature-A&lt;/code&gt; 를 실행하면 &lt;em&gt;fast forward&lt;/em&gt; 방식으로 merge 된 것과 같이 commit history 가 정리된다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git merge&lt;/code&gt; 와 마찬가지로 &lt;code&gt;git rebase&lt;/code&gt; 도 conflict 가 발생할 수 있다. rebase 중에 conflic file 이 발견되면 rebase 작업은 잠시 멈추게 된다. 그리고 merge 와 마찬가지로 conflict file 을 수정한 후 &lt;code&gt;git add &amp;lt;conflict file&amp;gt;&lt;/code&gt; 을 실행한 뒤 &lt;code&gt;git rebase --continue&lt;/code&gt; 를 실행하면 작업이 이어서 진행된다. 만약 rebase 작업을 취소하고 싶다면 &lt;code&gt;git rebase --abort&lt;/code&gt; 를 실행한다.&lt;/p&gt;
&lt;p&gt;rebase 와 commit cherry-picking 으로 commit 을 관리하면 &lt;em&gt;fast forward&lt;/em&gt; 방식으로 정리된  commit history 를 관리할 수 있다.&lt;/p&gt;
&lt;p&gt;자세한 내용은 &lt;code&gt;git help rebase&lt;/code&gt; 나 공식 문서를 확인하자.&lt;/p&gt;
&lt;h2&gt;Tag&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Tag 목록 확인 : &lt;code&gt;git tag&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Tag 생성 : &lt;code&gt;git tag &amp;lt;tag name&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Tag 삭제 : &lt;code&gt;git tag -d &amp;lt;tag name&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;pattern 으로 tag 목록 확인 : &lt;code&gt;git tag -l 'v1.8.5*'&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;특정 tag의 정보 보기 : &lt;code&gt;git show &amp;lt;tag name&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;이미 지나간 commit 에 대한 tag 를 생성 : git tag -a &lt;tag name&gt; &lt;commit ID&gt;&lt;/li&gt;
&lt;li&gt;remote server 에 tag 정보 push : &lt;code&gt;git push origin [tagname]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;remote server 에 모든 tag 정보를 한꺼번에 전송 : &lt;code&gt;git push origin --tags&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;git tag 에는 2가지 type 이 있다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;lightweight : pointer to a specific commit. 즉, lightweight tag 정보는 오직 commit checksum 만 저장된다.&lt;/li&gt;
&lt;li&gt;annotated tag: stored as full objects in the Git database. They are checksummed; contain the tagger name, e-mail, and date; have a tagging message; and can be signed and verified with GNU Privacy Guard (GPG).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;git tag &amp;lt;tag name&amp;gt;&lt;/code&gt; 으로 Tag 를 생성할 경우 기본적으로 libweight tag 이다. annotated tag 는 &lt;code&gt;-a&lt;/code&gt; 옵션을 사용(&lt;code&gt;git tag -a &amp;lt;tag name&amp;gt; -m '&amp;lt;message&amp;gt;'&lt;/code&gt;)해야 한다. &lt;code&gt;-m&lt;/code&gt; 옵션이 없으면 git 에 editor 를 실행하여 message를 입력할 수 있도록 한다.&lt;/p&gt;
&lt;p&gt;annotated tag 는 추가적인 tag 정보들(tag name, tagger, date, message 등)과 commit 내용을 보여 준다. lightweight tag 는 tag 관련된 추가적인 정보들이 없이 commit 내용만 보여준다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tag 로 checkout : &lt;code&gt;git checkout -b version2 v2.0.0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;git 에는 사실 tag 로 checkout 하는 기능은 없다. 단지 특정 tag 로 branch 를 만드는 것이다. 때문에 이렇게 만들어진 branch 에서 작업하고 commit 하면 master 에 반영이 안되니 주의해야 한다.&lt;/p&gt;
&lt;h1&gt;Advanced&lt;/h1&gt;
&lt;h2&gt;Undo modifications&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Local 의 변경 내용을 HEAD 로 되돌리기: &lt;code&gt;git checkout -- &amp;lt;file path&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;위의 명령은 이미 인덱스에 추가된 변경 내용과 새로 생성한 파일은 그대로 남는다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Staging Area (index) 의 파일을 Unstaged 로 바꾸기: &lt;code&gt;git reset HEAD &amp;lt;file path&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;만약 어떤 파일을 수정한 후 git add 를 실행하여 Staged 상태일 때, 변경 내용들을 취소하고 싶을 경우 아래 명령들을 차례로 실행한다.&lt;/p&gt;
&lt;p&gt;HEAD 는 Git 에서 사용되는 special pointer 이다. HEAD 는 현재 작업 중인 local branch 를 가리킨다. &lt;code&gt;git checkout&lt;/code&gt; 으로 branch 를 변경하면 HEAD 가 변경된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Repository 의 history 중 하나로 복원하기: &lt;code&gt;git reset [options] &amp;lt;commit hash ID&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;history 와 모든 변경 내용들을 삭제하면서 특정 commit 으로 되돌아가기 : &lt;code&gt;git reset --hard [commit]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;git reset --hard&lt;/code&gt; 의 경우 history 를 포함한 모든 변경 내용들을 삭제하여 깔끔하게 이전 내용으로 되돌아갈 수 있다. 하지만 Local Git Repository 가 다른 Remote Repository 와 공유될 경우 문제가 발생할 수도 있다. 이때 사용가능 한 것이 &lt;code&gt;git revert &amp;lt;commit hash ID&amp;gt;&lt;/code&gt; 이다. &lt;code&gt;git revert&lt;/code&gt; 는 history 와 commit 들을 삭제하지 않는다. 내용을 특정 commit 으로 되돌리지만 삭제하지 않고 또하나의 새로운 commit 으로 처리한다.&lt;/p&gt;
&lt;h2&gt;Modify commits&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;commit 수정하기: &lt;code&gt;git commit --amend&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;아래와 같은 경우 commit 내용을 수정해야 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;어떤 파일을 빼먹었을 때&lt;/li&gt;
&lt;li&gt;commit message 를 잘못 적었을 때&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;커밋을 했는데 Stage하는 것을 깜빡하고 빠트린 파일이 있으면 아래와 같이 고칠 수 있다:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git commit -m &amp;#39;initial commit&amp;#39;
git add &amp;lt;forgotten_file_path&amp;gt;
git commit --amend
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;여기서 실행한 명령어 3개는 모두 하나의 commit 으로 기록된다. 두 번째 commit 은 첫 번째 commit 을 덮어쓴다.&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;.git&lt;/code&gt; directory&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;.git&lt;/code&gt; 디렉터리는 local git repository 정보가 저장되는 곳이다. 안에 여러 파일들이 있는데 간단하게 중요한 몇몇 파일만 설명하면 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.git/objects&lt;/code&gt; : 각 Commit Object 들이 Hash 값에 따라 저장됨&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.git/refs&lt;/code&gt; : Commit Hash 를 참조하는 Reference 정보&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.git/refs/heads&lt;/code&gt; : local git repository 의 각 branch 들의 HEAD 가 저장(master branch 의 head 는 &lt;code&gt;.git/refs/heads/master&lt;/code&gt; 에 저장)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.git/HEAD&lt;/code&gt; : 현재 작업 중인 branch 의 HEAD 정보를 나타냄(예 : ref: refs/heads/master)&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Github&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;branch 들 (example: ruby on rails repository 의 4-0-stable branch 와 3-2-stable branch) 사이의 변경 내역 확인하는 방법 : &lt;code&gt;https://github.com/rails/rails/compare/4-0-stable...3-2-stable&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;master branch 의 2015년 1월 1일부터의 변경 내역을 확인하는 방법(변경 내역이 너무 많거나, 기간이 너무 긴 경우에는 최근 변경 내용만 나온다) : &lt;code&gt;https://www.github.com/rails/rails/compare/master@{2015-01-01}...master&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;References&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://git-scm.com/book/en/v2"&gt;Git Book English&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://git-scm.com/book/ko/v2"&gt;Git Book Korean&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://rogerdudler.github.io/git-guide/index.ko.html"&gt;git - 간편 안내서&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="git"></category></entry><entry><title>Granularity (Coarse-grained V.S. Fine-grained)</title><link href="https://imjang57.github.io/garret/granularity-coarse-grained-and-fine-grained.html" rel="alternate"></link><published>2017-01-04T00:00:00+09:00</published><updated>2017-01-04T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-04:/garret/granularity-coarse-grained-and-fine-grained.html</id><summary type="html">&lt;p&gt;Granularity (Coarse-grained V.S. Fine-grained) 의 의미&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Coarse-grained V.S. Fine-grained in Spark&lt;/h1&gt;
&lt;p&gt;Coarse-grained 와 Fine-grained 는 한국말로 번역하기가 참 애매한 단어이다. 그래서 의미도 잘 와닿지 않는다.&lt;/p&gt;
&lt;p&gt;Quora 에 누군가가 &lt;a href="https://www.quora.com/What-does-coarse-grained-mean-in-Spark-RDD"&gt;Spark RDD 에서 사용되는 Coarse-grained 의 개념에 대해 질문&lt;/a&gt;하였는데, 누군가가 coarse-grained 에 대해 아래와 같이 설명한다.:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Basically, it means that you can write you transformations to be applied to the while dataset, but not individual elements on the dataset. Operations like map, filter, group reduce, but not get(index) or set(index).&lt;/p&gt;
&lt;p&gt;By restricting RDD operations to coarse-grained immutable transformations, Spark is able to provide powerful distributed data processing, while keeping the system fairly simple to understand and operate.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Coarse-grained 와 Fine-grained 는 원래 곡식을 낟알로 만들 때 대충 작업하여 낟알을 거칠하는 것과 세심하게 하여 낟알을 부드럽게 하는 것을 의미한다. 소프트웨어 공학에서 Coarse-grained 와 Fine-grained 는 어떤 작업(Process, Wordload)의 분할 단위가 큰가 작은가를 구분하는 상대적인 의미로 사용된다.&lt;/p&gt;
&lt;p&gt;얼마나 세분화 되었는가? 모듈화 되었는가? 한국말로 표현하기가 좀 애매한데, 여튼 어느 정도 grain 되었는지를 나타내는 것을 granularity 라고 한다. 이 &lt;a href="https://en.wikipedia.org/wiki/Granularity"&gt;Granularity&lt;/a&gt;에 대한 위키피디아 페이지에 다음과 같은 언급이 있다.:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Coarse-grained materials or systems have fewer, larger discrete components than fine-grained materials or systems.&lt;/p&gt;
&lt;p&gt;The concepts granularity, coarseness, and fineness are relative, used when comparing systems or descriptions of systems.&lt;/p&gt;
&lt;/blockquote&gt;</content><category term="granularity"></category><category term="coarse-grained"></category><category term="fine-grained"></category><category term="programming"></category></entry><entry><title>Function, Method, Procedure</title><link href="https://imjang57.github.io/garret/function-and-method.html" rel="alternate"></link><published>2017-01-03T00:00:00+09:00</published><updated>2017-01-03T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-03:/garret/function-and-method.html</id><summary type="html">&lt;p&gt;Function, Method, Procedure 의 차이점&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Function, Method, Procedure&lt;/h1&gt;
&lt;p&gt;보통 function 과 method 를 구분 없이 사용한다. 하지만 이들은 엄연히 다른 개념이다. 서브루틴, 함수, 메서드, 프로시저 모두 비슷하지만 각자 의미가 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Sub-routine : A sub-routne is A repeatable piece of procedural code you can call by name.&lt;/li&gt;
&lt;li&gt;Function : A function is a sub-routine that returns one or more values. A function should calculate its return value based on its input.&lt;/li&gt;
&lt;li&gt;Procedure : A procedure is a sub-routine that doesn not return a value, but does have side-effects. (such as writing to a file, printing to the screen, or modifying the value of its input)&lt;/li&gt;
&lt;li&gt;Method : A method is a function or procedure that is executed in the context of an object. A Method calculates a new value or trigger side-effect based on the values of its inputs and/or the scope of the object instance&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;보통 개발자들은 이들 단어에 대해 별 다른 구분없이 비슷한 의미로 사용한다. 하지만 Programming Language Theory 에서는 확실히 다르다.&lt;/p&gt;
&lt;p&gt;이런 단어들의 의미를 무시해도 상관없을까? 사실 대부분의 경우 무시해도 큰 상관은 없다고 생각된다. 하지만 어떤 로직을 모듈화하여 서브루틴으로 만들 때 이것들을 고려하면 더 좋다고 생각한다. 이 서브루틴은 어떤 타입의 서브루틴으로 구현해야 하는지 고민하면 그 서브루틴의 역할이나 목적을 더 명확해질 것이다. 서브루틴의 역할이나 목적이 명확해지면, 하나의 서브루틴이 과도하게 많은 역할을 하게 되는 현상을 방지할 수 있을 것이다. 프로그래밍에서 중요한 중복 제거, 모듈화에 대한 자연스러운 의식의 흐름이 생기게 되고 결과적으로 코드가 단순하지고 관리하기 좋아질 것이다. 어쨌든 좋은 함수를 만들기 위한 고민은 항상 필요하다고 생각한다.&lt;/p&gt;
&lt;p&gt;물론, 실제 개발할 때 시간에 쫓겨 항상 이런 고민을 하지 못한다..ㅠㅠ.. 그래도 항상 고민하려고 노력하자. 개발은 사람이 하는 일이라 의식의 흐름에 영향을 받으니, 의식의 흐름을 항상 올바로 하려고 노력하자.&lt;/p&gt;</content><category term="function"></category><category term="method"></category><category term="procedure"></category><category term="sub-routine"></category><category term="programming"></category></entry><entry><title>Parameter and Argument</title><link href="https://imjang57.github.io/garret/parameter-and-argument.html" rel="alternate"></link><published>2017-01-03T00:00:00+09:00</published><updated>2017-01-03T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-03:/garret/parameter-and-argument.html</id><summary type="html">&lt;p&gt;Parameter 와 Argument 의 정확한 의미&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Parameter and Argument&lt;/h1&gt;
&lt;p&gt;많은 개발자들이 Parameter 와 Argument 를 딱히 구분하지 않고 사용한다. 그런데 이 둘은 엄연히 다르며, 그러다 보니 논쟁하다보면 맥락이 어긋나는 경우가 발생한다.&lt;/p&gt;
&lt;p&gt;K&amp;amp;R 의 C Programming Language Second Edition 에 다음과 같이 언급한다.&lt;/p&gt;
&lt;p&gt;We well generally use parameter for a variable named in the parenthesized list in a function definition, and argument for the value used in a call of the function.&lt;/p&gt;
&lt;p&gt;즉, Parameter(파라미터, 매개변수)는 함수 선언에서 사용되는 변수의 이름을 뜻하며, Argument(인자, 전달인자)는 함수를 호출할 때 전달되는 값을 의미한다.&lt;/p&gt;</content><category term="parameter"></category><category term="argument"></category><category term="programming"></category></entry><entry><title>SSH Timeout Configuration</title><link href="https://imjang57.github.io/garret/ssh-timeout-configuration.html" rel="alternate"></link><published>2017-01-02T00:00:00+09:00</published><updated>2017-01-02T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-02:/garret/ssh-timeout-configuration.html</id><summary type="html">&lt;p&gt;SSH 접속 시 Timeout 설정하는 방법&lt;/p&gt;</summary><content type="html">&lt;h1&gt;SSH Timeout 관련 설정&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;/etc/ssh/sshd_config&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;TCPKeepAlive yes
ClientAliveInterval 30
ClientAliveCountMax 99999
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;restart sshd:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ systemctl restart sshd
&lt;/pre&gt;&lt;/div&gt;</content><category term="ssh"></category><category term="timeout"></category></entry><entry><title>SSH Tunneling</title><link href="https://imjang57.github.io/garret/ssh-tunneling.html" rel="alternate"></link><published>2017-01-02T00:00:00+09:00</published><updated>2017-01-02T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-02:/garret/ssh-tunneling.html</id><summary type="html">&lt;p&gt;SSH Tunneling 사용 방법&lt;/p&gt;</summary><content type="html">&lt;h1&gt;SSH Tunneling&lt;/h1&gt;
&lt;p&gt;SSH(Secure SHell)는 이름에서 알 수 있듯이 보안성이 좋은 프로토콜이다. SSH는 비대칭키를 이용한 인증(Authentication), 대칭키를 이용한 데이터 암호화(Encryption), 네트웍을 통해 전송된 데이터가 변경되지 않았음을 보장하는 무결성(Integrity) 등을 제공한다.&lt;/p&gt;
&lt;p&gt;이외에 SSH는 정말 유용한 기능을 제공하는데 바로 포트 포워딩(Port Forwarding)을 이용한 터널링(Tunneling)이다.&lt;/p&gt;
&lt;p&gt;SSH 클라이언트가 SSH 서버에 연결되면 둘 사이에 연결이 생성되는데 이를 보통 &lt;strong&gt;터널(Tunnel)&lt;/strong&gt; 이라고 한다. 그리고 이 터널은 클라이언트와 서버 사이에서 암호화로 보호되는 통로이다. 보통은 이 터널을 통해서 클라이언트와 서버가 통신하는데, 포트 포워딩이라는 기술을 사용하면 이 터널을 다른 애플리케이션들이 이용하도록 할 수가 있다. 이를 터널링이라고 한다. 터널링을 사용하면 애플리케이션은 별도로 개발할 필요 없이 SSH의 보안 통로를 사용할 수 있게 되는 것이다. 터널링은 TCP만 가능하고 UDP는 불가능하다.&lt;/p&gt;
&lt;p&gt;터널링은 크게 &lt;strong&gt;로컬 포트 포워딩(Local Port Forwarding)&lt;/strong&gt; 과 &lt;strong&gt;리모트 포트 포워딩(Remote Port Forwarding)&lt;/strong&gt; 으로 나누어져 있다. 어디가 요청을 받고 어느 방향으로 전달해주냐에 따라 나누어 진다. 그리고 포트 포워딩을 통한 SSH 터널링은 SSH 연결이 유지되는 동안에만 사용할 수 있다.&lt;/p&gt;
&lt;h1&gt;Local Port Forwarding&lt;/h1&gt;
&lt;p&gt;로컬 포트 포워딩은 SSH 클라이언트가 요청을 받아 SSH 서버를 통해 다른 서버로 요청을 포워딩해주는 것이다. 로컬 포트 포워딩은 다음과 같이 실행하면 사용할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ ssh -L&amp;lt;&lt;span class="nb"&gt;local&lt;/span&gt; port number&amp;gt;:&amp;lt;host&amp;gt;:&amp;lt;remote port number&amp;gt; &amp;lt;user&amp;gt;@&amp;lt;SSH server host&amp;gt;&lt;span class="o"&gt;[&lt;/span&gt;:&amp;lt;SSH server port&amp;gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;&amp;lt;local port number&amp;gt;&lt;/code&gt;는 SSH 클라이언트가 애플리케이션을 위해 포트를 열고 대기(LISTEN)하고 있는 포트 번호이다. &lt;code&gt;&amp;lt;host&amp;gt;&lt;/code&gt;는 애플리케이션이 최종적으로 요청을 전달하려고 하는 서버 주소이다. &lt;code&gt;&amp;lt;remote port number&amp;gt;&lt;/code&gt;는 애플리케이션이 최종적으로 요청을 전달하려고 하는 서버의 포트 번호이다. 그리고 SSH 연결을 위해 &lt;code&gt;&amp;lt;user&amp;gt;@&amp;lt;SSH server host&amp;gt;&lt;/code&gt;를 전달한다.&lt;/p&gt;
&lt;p&gt;예를 들어, SSH를 통해서만 연결이 가능한 분리된 네트웍이 있다고 하자. 하나는 &lt;code&gt;192.168.0.0/24&lt;/code&gt;이고 다른 하나는 &lt;code&gt;192.169.0.0/24&lt;/code&gt;이다. SSH 클라이언트는 &lt;code&gt;192.168.0.5&lt;/code&gt;, 애플리케이션은 &lt;code&gt;192.168.0.10&lt;/code&gt;, SSH 서버는 &lt;code&gt;192.169.0.5:22&lt;/code&gt;, API 서버는 &lt;code&gt;192.169.0.10:10050&lt;/code&gt;일 때 로컬 호스트에서 로컬 포트 포워딩으로 API 서버에 요청을 하려면 다음과 같이 실행하면 된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ ssh -L10010:192.169.0.10:10050 myuser@192.169.0.5
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;그리고 애플리케이션은 &lt;code&gt;192.168.0.5:10010&lt;/code&gt;으로 요청하면 SSH 터널을 통해 API 서버로 요청을 전달할 수 있다. 즉, 애플리케이션 -&amp;gt; SSH 클라이언트 -&amp;gt; SSH 서버 -&amp;gt; API 서버로 전달이 되는 것이다.&lt;/p&gt;
&lt;h1&gt;Remote Port Forwaring&lt;/h1&gt;
&lt;p&gt;리모트 포트 포워딩은 로컬 포트 포워딩과 반대이다. SSH 서버가 요청을 받아 SSH 클라이언트를 통해 다른 서버로 요청을 포워딩해주는 것이다. 리모트 포트 포워딩은 다음과 같이 실행하면 사용할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ ssh -R&amp;lt;remote port number&amp;gt;:&amp;lt;host&amp;gt;:&amp;lt;&lt;span class="nb"&gt;local&lt;/span&gt; port number&amp;gt; &amp;lt;user&amp;gt;@&amp;lt;SSH server host&amp;gt;&lt;span class="o"&gt;[&lt;/span&gt;:&amp;lt;SSH server port&amp;gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;&amp;lt;remote port number&amp;gt;&lt;/code&gt;는 SSH 서버가 애플리케이션을 위해 포트를 열고 대기(LISTEN)하고 있는 포트 번호이다. &lt;code&gt;&amp;lt;host&amp;gt;&lt;/code&gt;는 애플리케이션이 최종적으로 요청을 전달하려고 하는 서버 주소이다. &lt;code&gt;&amp;lt;local port number&amp;gt;&lt;/code&gt;는 애플리케이션이 최종적으로 요청을 전달하려고 하는 서버의 포트 번호이다. 그리고 SSH 연결을 위해 &lt;code&gt;&amp;lt;user&amp;gt;@&amp;lt;SSH server host&amp;gt;&lt;/code&gt;를 전달한다.&lt;/p&gt;
&lt;p&gt;가만히 보면 로컬 포트 포워딩과 순서가 반대인 것을 알 수 있다. 예를 들어, 예를 들어, SSH를 통해서만 연결이 가능한 분리된 네트웍이 있다고 하자. 하나는 &lt;code&gt;192.168.0.0/24&lt;/code&gt;이고 다른 하나는 &lt;code&gt;192.169.0.0/24&lt;/code&gt;이다. SSH 클라이언트는 &lt;code&gt;192.168.0.5&lt;/code&gt;, API 서버는 &lt;code&gt;192.168.0.10&lt;/code&gt;, SSH 서버는 &lt;code&gt;192.169.0.5:22&lt;/code&gt;, 애플리케이션은 &lt;code&gt;192.169.0.10:10050&lt;/code&gt;일 때 로컬 호스트에서 로컬 포트 포워딩으로 API 서버에 요청을 하려면 다음과 같이 실행하면 된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ ssh -R10050:192.168.0.10:10010 myuser@192.169.0.5
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;그리고 애플리케이션은 &lt;code&gt;192.169.0.5:10050&lt;/code&gt;으로 요청하면 SSH 터널을 통해 API 서버로 요청을 전달할 수 있다. 즉, 애플리케이션 -&amp;gt; SSH 서버 -&amp;gt; SSH 클라이언트 -&amp;gt; API 서버로 전달이 되는 것이다.&lt;/p&gt;
&lt;h1&gt;참고사항&lt;/h1&gt;
&lt;p&gt;SSH 터널링을 이용하면 방화벽을 우회할 수 있고, SSH가 제공하는 암호화된 통신을 쉽게 다른 목적으로도 사용할 수 있다. 그러니 SSH 접근 권한과 관련된 정보(로그인 정보, SSH Key 등)를 잘 관리하자.&lt;/p&gt;</content><category term="ssh"></category><category term="tunneling"></category></entry><entry><title>SSH with key</title><link href="https://imjang57.github.io/garret/ssh-with-key.html" rel="alternate"></link><published>2017-01-02T00:00:00+09:00</published><updated>2017-01-02T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-02:/garret/ssh-with-key.html</id><summary type="html">&lt;p&gt;Key 로 SSH 로그인 하기 위한 과정&lt;/p&gt;</summary><content type="html">&lt;h1&gt;SSH with key file&lt;/h1&gt;
&lt;p&gt;SSH를 사용할 때 비밀번호를 일일이 입력하기 귀찮을 때가 있다. 특히 개발용 서버에 수시로 접속할 때... 이 때 키(Key) 파일을 이용한 로그인을 하면 비밀번호를 입력하는 번거로움을 피할 수 있다. 또한, 비밀키(Private Key) 를 잘 관리하여 SSH 접속에 대한 보안을 강화할 수도 있다. 물론 모든 보안이 그렇듯이 얼마나 비밀키를 잘 관리하느냐가 중요하다.&lt;/p&gt;
&lt;p&gt;SSH에서 키를 이용한 로그인을 위해 키파일(Key file)을 생성하고 SSH 서버에 키의 정보를 등록해주어야 한다. 키를 생성할 때 여러 암호화 알고리즘을 사용할 수 있지만 보통 RSA 비대칭키 암호화(RSA asymmetric encryption) 방식을 많이 사용한다. RSA 키파일을 생성하고 이 키를 이용하여 SSH 로그인하기 위해 다음과 같은 과정이 필요하다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;공개키(Public Key) 와 비밀키(Private Key) 를 생성&lt;/li&gt;
&lt;li&gt;로컬 호스트(Local Host), 즉 SSH 클라이언트(SSH Client)에 비밀키를 저장&lt;/li&gt;
&lt;li&gt;원격 호스트(Remote Host), 즉 SSH 서버(SSH Server)에 공개키를 등록&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;SSH 접속이 진행되는 과정을 살펴보면 다음과 같다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;SSH 클라이언트가 SSH 서버 측에 접속 요청&lt;/li&gt;
&lt;li&gt;SSH 서버는 자신의 공개키(위에서 생성한 키가 아니라 원래 SSH 서버가 가지고 있는 키)를 SSH 클라이언트에게 전달&lt;/li&gt;
&lt;li&gt;SSH 클라이언트는 SSH 서버가 전달한 공개키로 자신의 비밀키를 암호화하여 SSH 서버에게 전달&lt;/li&gt;
&lt;li&gt;SSH 서버는 자신이 가진 공개키 목록을 보고 SSH 클라이언트가 전달한 비밀키와 매칭되는 공개키가 있으면 로그인을 승인&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;위에서 언급한 대로 로그인 과정에서는 비대칭키를 사용한다. 하지만 로그인이 성공한 이후에는 대칭키를 만들고, 비대칭키로 생성된 대칭키를 공유하고, 이후 데이터 전송에는 이 대칭키(Symmetric key)를 사용한다. 비대칭키는 연산이 더 오래걸리기 때문이다.&lt;/p&gt;
&lt;h2&gt;Key 생성&lt;/h2&gt;
&lt;p&gt;먼저 Public Key 와 Private Key 를 생성한다. 리눅스에서는 아래와 같은 명령을 실행하면 된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ ssh-keygen -t rsa
Generating public/private rsa key pair.
Enter file in which to save the key &lt;span class="o"&gt;(&lt;/span&gt;/home/axl/.ssh/id_rsa&lt;span class="o"&gt;)&lt;/span&gt;: &amp;lt;&lt;span class="k"&gt;return&lt;/span&gt;&amp;gt;
Enter passphrase &lt;span class="o"&gt;(&lt;/span&gt;empty &lt;span class="k"&gt;for&lt;/span&gt; no passphrase&lt;span class="o"&gt;)&lt;/span&gt;: &amp;lt;Type the passphrase&amp;gt;
Enter same passphrase again: &amp;lt;Type the passphrase&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;ssh-keygen&lt;/code&gt; 을 실행하면 key file 이 저장될 위치와 passphrase 를 차례대로 묻는다. 저장될 위치는 기본값으로 &lt;code&gt;$HOME/.ssh/&lt;/code&gt; 이다. 특별히 변경할 일이 없다면 그대로 엔터를 입력하여 기본값으로 사용하자. &lt;code&gt;passphrase&lt;/code&gt; 는 비밀키를 생성하는데 사용될 문자열로 이 문자열을 암호화하여 키를 생성한다. 자동 로그인을 원한다면 생략해야 한다.&lt;/p&gt;
&lt;p&gt;키가 정상적으로 생성되면 키가 생성된 곳에 아래와 같은 파일들을 볼 수 있다. 참고로 아래 파일들은 SSH 를 사용할 때 보안에 매우 중요한 파일들이다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;drwx------  &lt;span class="m"&gt;2&lt;/span&gt; ubuntu ubuntu &lt;span class="m"&gt;4096&lt;/span&gt; Feb &lt;span class="m"&gt;18&lt;/span&gt; 18:54 .
drwxr-xr-x &lt;span class="m"&gt;16&lt;/span&gt; ubuntu ubuntu &lt;span class="m"&gt;4096&lt;/span&gt; Mar  &lt;span class="m"&gt;1&lt;/span&gt; 06:02 ..
-rw-rw-r--  &lt;span class="m"&gt;1&lt;/span&gt; ubuntu ubuntu  &lt;span class="m"&gt;790&lt;/span&gt; Feb &lt;span class="m"&gt;19&lt;/span&gt; 06:04 authorized_keys
-rw-------  &lt;span class="m"&gt;1&lt;/span&gt; ubuntu ubuntu &lt;span class="m"&gt;1675&lt;/span&gt; Feb &lt;span class="m"&gt;18&lt;/span&gt; 18:51 id_rsa
-rw-r--r--  &lt;span class="m"&gt;1&lt;/span&gt; ubuntu ubuntu  &lt;span class="m"&gt;395&lt;/span&gt; Feb &lt;span class="m"&gt;18&lt;/span&gt; 18:51 id_rsa.pub
-rw-r--r--  &lt;span class="m"&gt;1&lt;/span&gt; ubuntu ubuntu &lt;span class="m"&gt;2216&lt;/span&gt; Feb &lt;span class="m"&gt;19&lt;/span&gt; 18:34 known_hosts
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;authorized_keys&lt;/code&gt; 파일은 없을수도 있다. 보통 SSH 서버 측에서 접속을 허용할 공개키 정보를 저장하는 파일이다. &lt;code&gt;id_rsa&lt;/code&gt; 파일은 비밀키를 저장한 파일이다. 매우 중요하므로 절대로 타인에게 노출되면 안된다. 또한, 함부로 수정되어서는 안되므로 파일 권한을 꼭 600으로 지정해주자. &lt;code&gt;id_rsa.pub&lt;/code&gt; 파일은 공개키를 저장한 파일이다. 접속하려는 원격 호스트의 &lt;code&gt;authorized_keys&lt;/code&gt;에 &lt;code&gt;id_rsa.pub&lt;/code&gt;파일에 저장된 공개키를 추가해야 키를 이용한 로그인을 할 수 있다.&lt;/p&gt;
&lt;h2&gt;Remote Host 에 Public Key 등록&lt;/h2&gt;
&lt;p&gt;이제 &lt;code&gt;id_rsa.pub&lt;/code&gt; 파일을 리모트 서버의 &lt;code&gt;$HOME/.ssh/authorized_keys&lt;/code&gt; 파일에 추가해줘야 한다. SSH Server의 &lt;code&gt;authorized_keys&lt;/code&gt; 의 내용이 SSH Client의 &lt;code&gt;id_rsa.pub&lt;/code&gt; 파일과 같아야 한다.&lt;/p&gt;
&lt;p&gt;아래와 같이 SCP (Secure Copy) 를 이용하여 Public Key 를 Remote Host 에 복사한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;scp &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;HOME&lt;/span&gt;&lt;span class="x"&gt;/.ssh/id_rsa.pub root@server.net:id_rsa.pub&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;그리고 Public Key 를 Remote Host 의 authorized_keys 에 추가한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;cat &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;HOME&lt;/span&gt;&lt;span class="x"&gt;/id_rsa.pub &amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;HOME&lt;/span&gt;&lt;span class="x"&gt;/.ssh/authorized_keys&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;SSH 접속&lt;/h2&gt;
&lt;p&gt;이후에는 비밀번호 없이 바로 SSH 접속이 가능하다.&lt;/p&gt;
&lt;p&gt;만약 Private Key 를 다른 곳에 저장했다면 아래와 같이 &lt;code&gt;-i&lt;/code&gt; 옵션을 사용하여 키를 지정할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ ssh root@server.net -i keyfile
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Remote Host 의 SSHD 설정&lt;/h2&gt;
&lt;p&gt;Key 를 이용한 SSH 로그인을 사용하기 위해서는 Remote Host 의 SSHD 설정에서 RSA 키 인증을 사용하도록 설정해야 한다. 아래와 같은 내용이 있는지 SSHD 설정 파일 (&lt;code&gt;/etc/ssh/sshd_config&lt;/code&gt;) 을 확인한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;RSAAuthentication yes
#DSAAuthentication yes
PubkeyAuthentication yes
AuthorizedKeysFile .ssh/authorized_keys
&lt;/pre&gt;&lt;/div&gt;</content><category term="ssh"></category><category term="key-gen"></category></entry><entry><title>Linux 에서 파일 관리를 위한 명령어들</title><link href="https://imjang57.github.io/garret/linux-command-for-file-management.html" rel="alternate"></link><published>2017-01-01T00:00:00+09:00</published><updated>2017-05-08T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-01:/garret/linux-command-for-file-management.html</id><summary type="html">&lt;p&gt;Linux 에서 파일 관리일 위한 명령어들(ls, lsof, chown, chmod, mv, cp, rm, rmdir, mkdir, fuser, ln, file, diff, patch, cat, tail, head, etc)&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Linux 에서 사용자 관리를 위한 명령어들&lt;/h1&gt;
&lt;p&gt;Linux 에서 파일 목록 확인, 파일 내용 확인, 사용 중인 파일 확인, 파일 정보 변경, 파일 비교, 패치 등을 위한 명령어들을 정리한 글이다.&lt;/p&gt;
&lt;p&gt;리눅스에서는 모든 것이 파일로 관리된다. 일반적으로 알고 있는 파일 외에 console, socket, device 등도 모두 파일이다. 그래서 리눅스에서 모든 인터페이스는 File Descriptor 를 기반으로 하고 모든 입력과 출력은 File Descriptor 를 통해 이루어진다.&lt;/p&gt;
&lt;h1&gt;파일 목록 조회&lt;/h1&gt;
&lt;p&gt;일반적으로 파일 목록을 조회하는 명령어는 &lt;code&gt;ls&lt;/code&gt; 이다. &lt;code&gt;ls -alh [path]&lt;/code&gt; 와 같이 여러 옵션을 전달할 수 있다. &lt;code&gt;-a&lt;/code&gt; 는 숨김파일(리눅스에서는 &lt;code&gt;.&lt;/code&gt; 으로 시작하면 숨김파일로 처리한다)을 포함한 모든 파일을 보여준다. &lt;code&gt;-l&lt;/code&gt; 옵션을 file name 외에 mode bits, owner, group, modification time 등의 추가적인 정보도 보여준다. &lt;code&gt;-h&lt;/code&gt; 옵션을 파일의 크기를 사람이 쉽게 인식할 수 있도록 크기에 따라 KB, MB, GB 단위로 바꿔서 보여준다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lsof&lt;/code&gt; 명령어는 사용 중인 파일, 즉 열려 있는 파일들을 확인할 수 있는 명령어이다. user name, process id, network protocol, network port, command name 등 여러 기준으로 사용 중인 파일들을 확인할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;lsof -u &amp;lt;usrename&amp;gt;&lt;/code&gt; : 특정 사용자가 열어서 사용중인 파일들을 검색&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lsof &amp;lt;file path&amp;gt;&lt;/code&gt; : 특정 파일을 사용하는 프로세스와 사용자 확인 가능&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lsof +D &amp;lt;directory path&amp;gt;&lt;/code&gt; : 특정 directory 밑에 있는 열려있는 파일들을 검색&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lsof -p &amp;lt;process id&amp;gt;&lt;/code&gt; : process id 가 사용 중인 파일들을 검색&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lsof -i&lt;/code&gt; : 모든 네트웍 포트 중 열려있는 포트를 검색&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lsof -i TCP&lt;/code&gt; : 모든 TCP 포트 중 열려있는 포트를 검색&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lsof -i TCP:22&lt;/code&gt; : 22번 TCP 포트를 사용중인 프로세스와 사용자 확인 가능&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lsof -i TCP:22-80&lt;/code&gt; : 22번에서 80번까지의 TCP 포트 중 열려있는 포트를 검색&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lsof -c httpd&lt;/code&gt; : httpd command 가 사용 중인 파일들을 검색&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;또한 &lt;code&gt;fuser&lt;/code&gt; 명령어를 사용하면 파일을 사용 중인 process id 를 확인할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fuser -n tcp 22&lt;/code&gt; : tcp 22 port 를 사용중인 process id 를 확인&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fuser -n file &amp;lt;file path&amp;gt;&lt;/code&gt; : 특정 파일을 사용중인 process id 를 확인&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;file&lt;/code&gt; 이라는 명령어를 사용하면 특정 파일의 type 을 확인할 수 있다. 일반적인 파일이 어떤 파일인지 확인할 때 사용되는데 Text file 인지, 실행 파일, Python code 인지, Shell script 인지를 알 수 있으며 Encoding(ASCII, UTF-8 등) 이 무엇인지도 확인가능하다.&lt;/p&gt;
&lt;h1&gt;파일 메타 정보 변경&lt;/h1&gt;
&lt;p&gt;Linux 에서 파일은 Owner 와 Group owner 가 있고, mode bits 가 있어서 여러 사용자들이 파일에 대해 어떤 권한까지 접근할 수 있는지를 지정할 수 있다. 이 정보들은 &lt;code&gt;ls -l&lt;/code&gt; 을 실행하면 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;chown&lt;/code&gt; 은 파일의 owner 정보를 변경한다. &lt;code&gt;chown [-R] &amp;lt;username&amp;gt;:&amp;lt;groupname&amp;gt; &amp;lt;path&amp;gt;&lt;/code&gt; 와 같이실행할 수 있고 &lt;code&gt;-R&lt;/code&gt; 옵션이 있으면 하위 디렉터리들과 파일들도 모두 같이 변경한다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;chmod&lt;/code&gt; 는 파일의 mode bits 를 변경한다. &lt;code&gt;chown [-R] 755 &amp;lt;path&amp;gt;&lt;/code&gt; 와 같이 실행할 수 있고 &lt;code&gt;-R&lt;/code&gt; 옵션이 있으면 하위 디렉터리들과 파일들도 모두 같이 변경한다. 또한 sticky bit 를 설정하려면 &lt;code&gt;chown [-R] 1777 &amp;lt;path&amp;gt;&lt;/code&gt; 와 같이 mode bits 를 1777 하면 된다.&lt;/p&gt;
&lt;h1&gt;파일 처리&lt;/h1&gt;
&lt;p&gt;파일은 복사, 이동, 삭제 등이 가능하다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mv&lt;/code&gt; : move (rename) files&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cp&lt;/code&gt; : copy files and directories&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cp -r &amp;lt;src&amp;gt; &amp;lt;dst&amp;gt;&lt;/code&gt; : &lt;code&gt;-r&lt;/code&gt; 옵션을 전달하면 recursive 하게 복사를 수행하여 하위 파일들과 디렉터리들도 모두 복사된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rm&lt;/code&gt; : remove files or directories&lt;ul&gt;
&lt;li&gt;&lt;code&gt;rm -r&lt;/code&gt; : recursive 하게 삭제&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rm -f&lt;/code&gt; : 삭제 여부를 묻는 prompting 없이 삭제한다. 그리고 삭제하는 파일이 없어도 에러로 처리하지 않고 그냥 넘어간다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;또한 directory 만을 위한 명령어도 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;rmdir&lt;/code&gt; : remove empty directories&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mkdir&lt;/code&gt; : make directories&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mkdir -p &amp;lt;path&amp;gt;&lt;/code&gt; : &lt;code&gt;-p&lt;/code&gt; 옵션을 directory 를 생성할 때 parent directory 가 없을 경우 parent directory 들도 같이 생성한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Link 생성&lt;/h1&gt;
&lt;p&gt;Linux 에서는 Symbolic link 와 Hard link 가 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ln&lt;/code&gt; : make links between files&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ln -s &amp;lt;target&amp;gt; &amp;lt;link name&amp;gt;&lt;/code&gt; : Symbolic link 를 생성한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;파일 내용 출력&lt;/h1&gt;
&lt;p&gt;텍스트 파일의 경우 내용을 확인할 수 있는 여러 명령어들이 있다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cat&lt;/code&gt; 은 concatenate and print files 라고 man pages 에 나와있듯이 파일을 출력하고 내용을 추가하기 위해 사용된다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cat &amp;lt;filepath&amp;gt;&lt;/code&gt; 를 실행하면 특정 파일의 냉용을 출력한다. 파일의 내용이 많을 경우 &lt;code&gt;cat &amp;lt;filepath&amp;gt; | less&lt;/code&gt; 또는 &lt;code&gt;cat &amp;lt;filepath&amp;gt; | more&lt;/code&gt; 와 같이 pipe 를 사용하여 파일의 내용을 pager utility 로 확인하면 된다. 그냥 &lt;code&gt;cat&lt;/code&gt; 을 실행하면 Stdin (Standard in) 으로 한줄을 입력받고 바로 Stddout (Standard out) 으로 바로 출력한다. 만약 파일에 내용을 저장하려면 &lt;code&gt;cat &amp;gt; &amp;lt;filepath&amp;gt;&lt;/code&gt; 를 실행하면 된다. 입력을 종료하려면 &lt;code&gt;C-D&lt;/code&gt; (&lt;code&gt;ctrl + D&lt;/code&gt;) 를 입력하여 End-of-file signal 을 전송하여 &lt;code&gt;cat&lt;/code&gt; 을 종료한다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tail&lt;/code&gt; 은 파일의 마지막 부분을 출력하는 명령어이다. &lt;code&gt;tail [-n &amp;lt;number&amp;gt;] &amp;lt;file path&amp;gt;&lt;/code&gt; 와 같이 실행할 수 있다. default 로 마지막 10줄을 출력하며 &lt;code&gt;-n&lt;/code&gt; 옵션을 사용하여 출력할 line 수를 지정할 수 있다. &lt;code&gt;tail -f &amp;lt;file path&amp;gt;&lt;/code&gt; 를 실행하면 파일의 내용이 추가되는 것을 바로 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;head&lt;/code&gt; 는 &lt;code&gt;tail&lt;/code&gt; 과 반대로 파일의 처음 부분을 출력하는 명령이다. &lt;code&gt;head [-n &amp;lt;number&amp;gt;] &amp;lt;file path&amp;gt;&lt;/code&gt; 와 같이 실행할 수 있다. default 로 처음 10줄을 출력하며 &lt;code&gt;-n&lt;/code&gt; 옵션을 사용하여 출력할 line 수를 지정할 수 있다.&lt;/p&gt;
&lt;h1&gt;파일 비교&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;diff&lt;/code&gt; 를 사용하여 두 파일의 내용을 비교할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;diff &amp;lt;file1&amp;gt; &amp;lt;file2&amp;gt;&lt;/code&gt; 와 같이 실행되는데 대부분 &lt;code&gt;diff -uNr &amp;lt;file1&amp;gt; &amp;lt;file1&amp;gt;&lt;/code&gt; 와 같이 옵션을 전달하여 사용된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-u&lt;/code&gt; : diff output format 을 unified format 으로 지정한다. context format 등 다른 format 들도 있지만 보통 &lt;code&gt;-u&lt;/code&gt; 옵션을 사용한다. format에 대한 자세한 내용은 따로 googling 해보자.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-r&lt;/code&gt; : recursive 를 의미한다. 즉, sub-directory 까지 모두 포함하여 실행한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-N&lt;/code&gt; : 새 파일도 포함하여 실행한다. 존재하지 않는 original file 을 empty file 로 취급한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Make and apply patches using diff and patch command&lt;/h1&gt;
&lt;p&gt;패치(patch) 파일은 두 파일들간의 차이들을 출력해 주는 프로그램인 &lt;code&gt;diff&lt;/code&gt; 에 의해 생성된 파일을 의미한다. 주로 쓰이는 때는 어떤 프로그램에서 기능향상이나 문제점을 해결하기 위해 소스파일들을 고치고 나서 고친 부분에 대한 정보만을 기록해 놓고 싶을때 쓰인다. 고친 소스파일 전체보다도 고친 부분에 대한 정보만을 갖고 있으면 저장해야 되는 양이 적고, 어떤 부분을 고쳤는지 파악하기도 쉽다는 장점이 있다. (특히 비공식적인 패치 적용시 프로그램이 버젼업이 되어 소스가 변경되었을때 유용하다.) 패치파일의 확장자는 사용자 임의이긴 하지만 알아보기 쉽도록 주로 &lt;code&gt;.diff&lt;/code&gt; 또는 &lt;code&gt;.patch&lt;/code&gt; 를 사용한다.&lt;/p&gt;
&lt;h2&gt;diff example&lt;/h2&gt;
&lt;p&gt;아래와 같이 &lt;code&gt;hello.c&lt;/code&gt; 라는 file 이 있다.:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt;

&lt;span class="cpf"&gt;int main(void) {&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;hello&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;위에서 'hello' 라는 문구 대신 '안녕하세요'로 바꾸고 싶다고 하자. 먼저 다음과 같이 위의 &lt;code&gt;hello.c&lt;/code&gt; 파일을 &lt;code&gt;hello.c.orig&lt;/code&gt; 라는 파일로 백업해 둔다:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ cp hello.c hello.c.orig
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;그리고 &lt;code&gt;hello.c&lt;/code&gt; 파일을 다음과 같이 고친다:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt;

&lt;span class="cpf"&gt;int main(void) {&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;안녕하세요&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;이 두 파일의 차이점을 패치 파일로 기록해 두기 위해 다음과 같이 &lt;code&gt;diff&lt;/code&gt; 명령을 이용한다.:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ diff -uNr hello.c.orig hello.c &amp;gt; hello-hangul.patch
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;생성된 &lt;code&gt;hello-hangul.patch&lt;/code&gt; 라는 파일은 단순한 텍스트 파일이다. 그 내용을 보기 위해 다음과 같은 명령을 실행해 보자:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ cat hello-hangul.patch
--- hello.c.orig      Sun Jan &lt;span class="m"&gt;16&lt;/span&gt; 16:54:32 2000
+++ hello.c   Sun Jan &lt;span class="m"&gt;16&lt;/span&gt; 16:53:04 2000
@@ -2,6 +2,6 @@

int main&lt;span class="o"&gt;(&lt;/span&gt;void&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
- printf&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;hello\n&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
+ printf&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;안녕하세요\n&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; 0&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;고친 파일의 이름, 고친 부분의 아래 위 세줄의 내용과 고친 부분이 -, + 로 표시되어 있는 것을 알 수 있다. 만약, 수정한 파일이 많다면 &lt;code&gt;diff&lt;/code&gt; 를 file 단위가 아니라 directory 단위로 실행시킬 수 있다:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ diff -uNr &lt;span class="o"&gt;[&lt;/span&gt;from-directory&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;to-directory&lt;span class="o"&gt;]&lt;/span&gt; &amp;gt; directory_patch.diff
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;paatch file 을 만들기 전에 &lt;code&gt;make clean&lt;/code&gt; 등을 이용하여 컴파일 과정의 결과로 생성되는 object file 들이나 기타 불필요한 파일들을 정리하고 실행하자.&lt;/p&gt;
&lt;h2&gt;Apply patch file: Using patch command&lt;/h2&gt;
&lt;p&gt;다음은 패치 파일과 변형되지 않은 원래 프로그램 소스 파일을 가지고 있을 때 패치를 적용하는 방법이다. 일단 패치를 적용하기 위해서는 &lt;code&gt;patch&lt;/code&gt; 라는 명령어를 이용하는데, 그 일반적인 형식은 다음과 같다:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ patch &lt;span class="o"&gt;[&lt;/span&gt;options&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;originalfile &lt;span class="o"&gt;[&lt;/span&gt;patchfile&lt;span class="o"&gt;]]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;일단 패치 파일을 살펴본다. 패치의 맨 윗줄을 보면 다음과 같이 파일에 관한 정보가 있는 부분이 있다:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gd"&gt;--- xchat-1.2.0/src/serverlist.h.orig   Wed Aug 25 14:48:57 1999&lt;/span&gt;
&lt;span class="gi"&gt;+++ xchat-1.2.0/src/serverlist.h        Sun Oct 31 18:06:13 1999&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;변경되지 않은 프로그램의 소스 디렉토리로 이동한다음 다음과 같이 &lt;code&gt;patch&lt;/code&gt; 라는 명령을 이용하여 패치를 한다:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;cd&lt;/span&gt; xchat-1.2.0/
$ patch -p1 &amp;lt; ../xchat-1.2.0-serverlist.patch
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;patch&lt;/code&gt; command 는 입력을 stdin 으로 받을 수 있기 때문에 redirect 를 이용해서 patch file 내용을 전달한다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-p&lt;/code&gt; 옵션은 patch file 의 정보에 있는 path 에서 몇 단계를 제외할 지를 나타낸다. 예를 들어 위에서 처럼 &lt;code&gt;-p1&lt;/code&gt; 옵션을 주면 patch 적용 path 는 xchat-1.2.0 이 제외된 &lt;code&gt;src/serverlist.h&lt;/code&gt; 가 되고, 현재 위치(directory, path) 를 기준으로 &lt;code&gt;src/serverlist.h&lt;/code&gt; 파일에 패치를 적용한다. 만약 그 상위디렉토리에서 패치를 적용하기 원한다면 그냥 다음과 같이 하면 될 것이다:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ patch -p0 &amp;lt; xchat-1.2.0-serverlist.patch
&lt;/pre&gt;&lt;/div&gt;</content><category term="linux"></category><category term="file"></category></entry><entry><title>Linux 에서 사용자 권한 관리</title><link href="https://imjang57.github.io/garret/linux-command-for-permission.html" rel="alternate"></link><published>2017-01-01T00:00:00+09:00</published><updated>2017-05-08T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-01:/garret/linux-command-for-permission.html</id><summary type="html">&lt;p&gt;Linux 에서 사용자 권한 관리에 대한 글&lt;/p&gt;</summary><content type="html">&lt;h1&gt;permissions&lt;/h1&gt;
&lt;p&gt;보통 Linux syste 에는 root 라는 사용자가 있는데, 이는 Linux system 에서 가장 높은 권한을 가진 사용자이며 대부분의 리눅스 배포판(Linux distribution)에서 기본적으로 제공되는 username 이다. 물론 요즘은 Mac 이나 Ubuntu 처럼 root 를 제공하지 않고 관리자 권한을 가진 계정을 제공하기도 한다. 어쨌든 관리자 권한을 갖고 시스템 전체에 접근하고 변경할 수 있도록 설정된 사용자가 존재한다.&lt;/p&gt;
&lt;p&gt;이 외의 일반 사용자들은 제한된 권한으로 시스템을 사용하게 되는데 설정에 따라 어떤 사용자들은 잠시 최상위 권한을 얻을 수 있다. 최상위 권한을 얻을 수 있도록 설정된 사용자는 &lt;code&gt;sudo&lt;/code&gt; 라는 명령어를 통해 이 권한을 얻을 수 있으며, 이 설정은 &lt;code&gt;/etc/sudoers&lt;/code&gt; 라는 파일을 통해서 관리된다.&lt;/p&gt;
&lt;h1&gt;sudo&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;sudo&lt;/code&gt; 는 일반사용자가 루트 권한을 임시적으로 획득하여 특정 명령을 할 수 있도록 하는 명령어이다. substitute user do 를 줄인 단어로, 다른 사용자의 권한으로 명령을 이행하라는 뜻이다&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sudo&lt;/code&gt; 의 man pages 에는 다음과 같이 설명한다:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;sudo — execute a command as another user
sudo allows a permitted user to execute a command as the superuser or another user, as specified by the security policy.
The default security policy is sudoers, which is configured via the file /etc/sudoers&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;일반사용자가 &lt;code&gt;sudo&lt;/code&gt; 명령어를 사용하기 위해서는 &lt;code&gt;/etc/sudoers&lt;/code&gt; 파일이나 &lt;code&gt;/etc/sudoers.d/&amp;lt;filename&amp;gt;&lt;/code&gt; 에 등록되어 있어야 한다.&lt;/p&gt;
&lt;h1&gt;사용자에게 sudo 권한 추가&lt;/h1&gt;
&lt;p&gt;우분투는 기본적으로 root 계정을 사용하지 못하게 하고, root 계정이 필요한 경우 sudo 명령을 통해서 root 가 아닌 계정에서 명령을 실행할 수 있도록 되어있다.&lt;/p&gt;
&lt;p&gt;그런데 아무 계정에서나 &lt;code&gt;sudo&lt;/code&gt; 명령을 실행할 수 있는 것은 아니다. 기본적으로는 admin 이라는 group 에 계정이 속해있어야 가능하다(group 이름이 admin 이 아닐 수도 있지만 어쨌든 관리자들을 위한 group 이 대부분 존재한다).&lt;/p&gt;
&lt;p&gt;이 글에서는 admin 이 아닌 다른 그룹에 계정을 생성했을 때, &lt;code&gt;sudo&lt;/code&gt; 명령어를 사용할 수 있도록 설정하는 법을 적었다.&lt;/p&gt;
&lt;p&gt;관리자 권한은 &lt;code&gt;/etc/sudoers&lt;/code&gt; 파일에서 관리되는데 이 파일은 쓰기 권한이 없다. 이 파일을 수정하기 위해서는 2가지 방법이 있다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;visudo&lt;/code&gt; 명령어를 실행하여 수정하는 방법&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/etc/sudoers&lt;/code&gt; 파일에 임시로 쓰기 권한((&lt;code&gt;chmod +w /etc/sudoers&lt;/code&gt;)을 추가한 다음 수정 후 다시 원래 권한(&lt;code&gt;chmod 440 /etc/sudoers&lt;/code&gt;)으로 되돌리는 방법&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;임의로 권한을 변경하는 것은 위험한 작업이므로 &lt;code&gt;visudo&lt;/code&gt; 를 이용하는 것이 좋다.&lt;/p&gt;
&lt;p&gt;먼저 &lt;code&gt;sudo&lt;/code&gt; 설정 파일(&lt;code&gt;/etc/sudoers&lt;/code&gt;)을 수정하기 위해 아래와 같이 입력한다:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ sudo visudo
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;또는 &lt;code&gt;/etc/sudoers&lt;/code&gt; 파일의 권한을 쓰기를 추가한 다음(chmod +w /etc/sudoers) 작업을 끝낸 후 다시 440 모드(chmod 440 /etc/sudoers)로 바꿔줘도 괜찮다.&lt;/p&gt;
&lt;p&gt;/etc/sudoers 파일에 아래와 같은 내용을 추가한다:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;# 특정 사용자에게 sudo 권한을 허락하는 경우&lt;/span&gt;
&lt;span class="n"&gt;userid&lt;/span&gt; &lt;span class="n"&gt;ALL&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nl"&gt;ALL&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;ALL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;ALL&lt;/span&gt;
&lt;span class="cp"&gt;# 특정 그룹에 sudo 권한을 허락하는 경우&lt;/span&gt;
&lt;span class="nf"&gt;%groupid&lt;/span&gt; &lt;span class="n"&gt;ALL&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ALL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;ALL&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;아래와 같이 입력하면 &lt;code&gt;sudo&lt;/code&gt; 실행 시 패스워드를 생략할 수 있다:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;%groupname&lt;/span&gt; &lt;span class="n"&gt;ALL&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ALL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nl"&gt;NOPASSWD&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;ALL&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;sudo 명령 시 특정 환경변수를 유지하도록 설정하는 법&lt;/h1&gt;
&lt;p&gt;예를 들어, HTTP Proxy 를 사용하는 환경에서 &lt;code&gt;sudo&lt;/code&gt; 를 이용하여 HTTP 요청을 하면 정상적으로 동작하지 않는 경우가 있다:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ sudo curl http://www.host.com
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;이는 &lt;code&gt;http_proxy&lt;/code&gt; 라는 환경변수가 sudo shell environment 에 없기 때문이다. 아래와 같이 명령을 입력하면 &lt;code&gt;sudo&lt;/code&gt; 로 실행되는 환경에서는 &lt;code&gt;http_proxy&lt;/code&gt; 가 없음을 알 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ sudo env
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;이를 해결하기 위해서는 &lt;code&gt;/etc/sudoers&lt;/code&gt; 에 특정 환경변수를 유지하도록 설정해주어야 한다.&lt;/p&gt;
&lt;p&gt;아래 명령으로 &lt;code&gt;/etc/sudoers&lt;/code&gt; 파일을 열자:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ sudo visudo
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;그리고 아래와 같은 라인을 추가하자:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Defaults env_keep += &amp;quot;http_proxy https_proxy&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;/etc/sudoers 파일이 잘못되어서 sudo 명령이 되지 않을 때&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;sudo&lt;/code&gt; 권한을 관리하기 위해 &lt;code&gt;/etc/sudoers&lt;/code&gt; 파일을 수정하다보면 실수로 파일이 깨지거나 문법에 맞지 않게 설정할 때도 있다. 이러면 아무리 &lt;code&gt;sudo&lt;/code&gt; 명령을 때려도 &lt;code&gt;/etc/sudoers&lt;/code&gt; 파일 parse error 라면서 아래와 같은 메시지를 던지게 된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;quot;/private/etc/sudoers: syntax error near line 28
sudo: parse error in /private/etc/sudoers near line 28
sudo: no valid shudders sources found, quitting
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;이 경우 root 로 로그인 하여 해당 파일을 수정하면 해결할 수 있다. 하지만, Ubuntu 의 경우 기본적으로 root 의 password 가 설정되어 있지 않기 때문에 별도로 root 를 활성화한 경우가 아니라면 낭패를 보기 쉽다.&lt;/p&gt;
&lt;p&gt;이 때, &lt;code&gt;pkexec&lt;/code&gt; 를 이용하여 &lt;code&gt;/etc/sudoers&lt;/code&gt; 파일을 수정할 수 있다.&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;pkexec&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;pkexec&lt;/code&gt; 의 man pages 에 다음과 같이 설명되어 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;pkexec allows an authorized user to execute PROGRAM as another user. If username is not specified, then the program will be executed as the administrative super user, root.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;즉, &lt;code&gt;pkexec&lt;/code&gt; 를 이용하면 &lt;code&gt;root&lt;/code&gt; 사용자로 실행할 수 있다:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pkexec vi /etc/sudoers
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;위 명령으로 &lt;code&gt;/etc/sudoers&lt;/code&gt; 파일을 수정하면 root 가 비활성화된 Ubuntu에서도 해결가능하다.&lt;/p&gt;</content><category term="linux"></category><category term="permission"></category></entry><entry><title>Linux 에서 사용자 관리를 위한 명령어들</title><link href="https://imjang57.github.io/garret/linux-command-for-user-management.html" rel="alternate"></link><published>2017-01-01T00:00:00+09:00</published><updated>2017-05-08T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-01:/garret/linux-command-for-user-management.html</id><summary type="html">&lt;p&gt;Linux 에서 사용자 관리를 위한 명령어들(useradd, userdel, usermod, groupadd, groupdel, passwd, who, w, whoami, last, lastlog)&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Linux 에서 사용자 관리를 위한 명령어들&lt;/h1&gt;
&lt;p&gt;Linux 에서 사용자 추가, 사용자 정보 변경, 사용자 삭제, 그룹 추가, 그룹 삭제, 로그인한 사용자 정보 확인, 로그인 내역 확인 등을 위한 명령어들을 정리한 글이다.&lt;/p&gt;
&lt;h1&gt;Login message&lt;/h1&gt;
&lt;p&gt;각 명령어들에 대해 알아보기 전에 리눅스에 로그인 하면 여러 메시지들이 출력되는 시스템들이 있다. 시스템마다 내용이 다르게 출력되는데 이는 아래의 2가지 파일을 이용해서 만든 것이다. 참고용으로 알고 가자.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/etc/motd&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/etc/issue&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;참고로, motd 는 message of the day 를 의미한다.&lt;/p&gt;
&lt;h1&gt;Add new user&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;useradd&lt;/code&gt; 와 &lt;code&gt;adduser&lt;/code&gt; 2개의 명령어가 존재하는데 같은 거다. &lt;code&gt;adduser&lt;/code&gt; 는 사실 &lt;code&gt;useradd&lt;/code&gt; 의 symbolic link 이기 때문에 같은 명령어이다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;useradd&lt;/code&gt; 는 새로운 사용자를 추가하는 명령이다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;useradd&lt;/code&gt; 는 실행될 때 &lt;code&gt;/etc/default/useradd&lt;/code&gt; 파일과 &lt;code&gt;/etc/login.defs&lt;/code&gt; 파일을 참고하여 실행되기 때문에 두 파일의 내용에 따라 결과가 다르게 나타날 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/etc/default/useradd&lt;/code&gt; 파일:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# useradd defaults file
GROUP=100
HOME=/home
INACTIVE=-1
EXPIRE=
SHELL=/bin/bash
SKEL=/etc/skel
CREATE_MAIL_SPOOL=yes
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;예를 들면 &lt;code&gt;/etc/default/useradd&lt;/code&gt; 파일에 &lt;code&gt;SKEL&lt;/code&gt; 의 값으로 새로운 사용자의 Home directory 에 생성될 기본 파일들을 지정할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/etc/login.defs&lt;/code&gt; 파일:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;#
# Please note that the parameters in this configuration file control the
# behavior of the tools from the shadow-utils component. None of these
# tools uses the PAM mechanism, and the utilities that use PAM (such as the
# passwd command) should therefore be configured elsewhere. Refer to
# /etc/pam.d/system-auth for more information.
#

# *REQUIRED*
#   Directory where mailboxes reside, _or_ name of file, relative to the
#   home directory.  If you _do_ define both, MAIL_DIR takes precedence.
#   QMAIL_DIR is for Qmail
#
#QMAIL_DIR  Maildir
MAIL_DIR    /var/spool/mail
#MAIL_FILE  .mail

# Password aging controls:
#
#   PASS_MAX_DAYS   Maximum number of days a password may be used.
#   PASS_MIN_DAYS   Minimum number of days allowed between password changes.
#   PASS_MIN_LEN    Minimum acceptable password length.
#   PASS_WARN_AGE   Number of days warning given before a password expires.
#
PASS_MAX_DAYS   99999
PASS_MIN_DAYS   0
PASS_MIN_LEN    5
PASS_WARN_AGE   7

#
# Min/max values for automatic uid selection in useradd
#
UID_MIN                  1000
UID_MAX                 60000
# System accounts
SYS_UID_MIN               201
SYS_UID_MAX               999

#
# Min/max values for automatic gid selection in groupadd
#
GID_MIN                  1000
GID_MAX                 60000
# System accounts
SYS_GID_MIN               201
SYS_GID_MAX               999

#
# If defined, this command is run when removing a user.
# It should remove any at/cron/print jobs etc. owned by
# the user to be removed (passed as the first argument).
#
#USERDEL_CMD    /usr/sbin/userdel_local

#
# If useradd should create home directories for users by default
# On RH systems, we do. This option is overridden with the -m flag on
# useradd command line.
#
CREATE_HOME yes

# The permission mask is initialized to this value. If not specified, 
# the permission mask will be initialized to 022.
UMASK           077

# This enables userdel to remove user groups if no members exist.
#
USERGROUPS_ENAB yes

# Use SHA512 to encrypt password.
ENCRYPT_METHOD SHA512
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;/etc/login.defs&lt;/code&gt; 파일에도 여러 가지 값들이 있는데 &lt;code&gt;CREATE_HOME&lt;/code&gt; 값에 따라 &lt;code&gt;useradd&lt;/code&gt; 가 사용자 Home directory 를 생성할지 여부를 결정하게 된다. 만약 이 값이 &lt;code&gt;yes&lt;/code&gt; 면 자동으로 생성하고 &lt;code&gt;no&lt;/code&gt; 면 자동으로 생성하지 않도록 되어 &lt;code&gt;useradd -d &amp;lt;home path&amp;gt; &amp;lt;username&amp;gt; &amp;amp;&amp;amp; mkdir &amp;lt;home path&amp;gt;&lt;/code&gt; 와 같이 &lt;code&gt;-d&lt;/code&gt; 옵션을 주어 home directory 를 설정하고 home directory 를 직접 생성해주어야 한다.&lt;/p&gt;
&lt;h1&gt;Delete user&lt;/h1&gt;
&lt;p&gt;사용자를 삭제하려면 &lt;code&gt;userdel&lt;/code&gt; 명령을 사용하면 된다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;userdel &amp;lt;username&amp;gt;&lt;/code&gt; 을 실행하면 사용자를 삭제한다. 하지만 사용자의 home directory 는 삭제하지 않는다. home directory 도 같이 삭제하려면 &lt;code&gt;userdel -r &amp;lt;username&amp;gt;&lt;/code&gt; 과 같이 &lt;code&gt;-r&lt;/code&gt; 옵션을 전달하여 실행한다.&lt;/p&gt;
&lt;h1&gt;Change user account&lt;/h1&gt;
&lt;p&gt;사용자 정보를 변경하는 명령어는 &lt;code&gt;usermod&lt;/code&gt; 이다.&lt;/p&gt;
&lt;p&gt;사용자의 home directory 를 변경하려면 &lt;code&gt;usermod -d &amp;lt;path&amp;gt; &amp;lt;user&amp;gt;&lt;/code&gt; 를 실행한다.&lt;/p&gt;
&lt;p&gt;사용자의 group 을 변경하려면 &lt;code&gt;usermod -G &amp;lt;groupname&amp;gt;&lt;/code&gt; 을 실행한다. groupname 은 &lt;code&gt;,&lt;/code&gt; 로 구분되는 여러 group 들이 올 수 있다.&lt;/p&gt;
&lt;p&gt;만약 사용자의 group 을 기존 group 에 추가하려 하면 &lt;code&gt;usermod -aG &amp;lt;groupname&amp;gt;&lt;/code&gt; 을 실행한다.&lt;/p&gt;
&lt;p&gt;사용자의 prior group (initial login group) 을 변경하려면 &lt;code&gt;usermod -g &amp;lt;groupname&amp;gt;&lt;/code&gt; 을 실행한다. &lt;code&gt;-g&lt;/code&gt; 옵션을 사용하면 home directory 이하의 모든 파일들의 group 도 같이 변경된다. home directory 외부에 있는 파일들을 직접 변경해주어야 한다.&lt;/p&gt;
&lt;h1&gt;Change user password&lt;/h1&gt;
&lt;p&gt;사용자의 login password 를 변경하려면 &lt;code&gt;passwd&lt;/code&gt; 명령을 사용한다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;passwd &amp;lt;username&amp;gt;&lt;/code&gt; 을 실행하면 된다.&lt;/p&gt;
&lt;h1&gt;Group&lt;/h1&gt;
&lt;p&gt;새로운 group 을 추가하려면 &lt;code&gt;groupadd&lt;/code&gt; 명령어를 사용한다. &lt;code&gt;groupadd &amp;lt;groupname&amp;gt;&lt;/code&gt; 을 하면 새로운 group 이 생성된다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;groups&lt;/code&gt; 명령어를 사용하면 사용자의 group 목록을 알 수 있다. 그냥 &lt;code&gt;groups&lt;/code&gt; 를 실행하면 현재 로그인된 사용자의 group 목록을 확인할 수 있으며, 특정 사용자의 group 목록을 확인하려면 &lt;code&gt;groups &amp;lt;username&amp;gt;&lt;/code&gt; 을 실행한다.&lt;/p&gt;
&lt;p&gt;group 을 삭제하려면 &lt;code&gt;groupdel&lt;/code&gt; 명령을 사용한다.&lt;/p&gt;
&lt;h1&gt;Show user informations&lt;/h1&gt;
&lt;p&gt;사용자 정보와 관련된 여러 내용을 확인하는 명령어들이 있다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;whoami&lt;/code&gt;, &lt;code&gt;who am i&lt;/code&gt; 2가지 명령들은 다 같은 명령들인데 현재 로그인 중인 사용자를 보여준다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lastlog&lt;/code&gt; 는 각 사용자들 또는 특정 사용자가 최근에 언제 어디에서 로그인했는지 정보를 알려준다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;last&lt;/code&gt; 는 특정 사용자가 로그인 한 history 를 보여준다. &lt;code&gt;/var/log/wtmp&lt;/code&gt; 파일의 내용을 보여주는 명령이다. &lt;code&gt;/var/log/wtmp&lt;/code&gt; 파일은 Text 가 아니라 binary 이기 때문에 last 명령으로만 확인할 수 있다. &lt;code&gt;last [username]&lt;/code&gt; 과 같이 실행할 수 있는데, 만약 &lt;code&gt;last reboot&lt;/code&gt; 를 실행하면 시스템이 리부트된 내역을 보여준다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;who&lt;/code&gt;, 는 현재 누가 로그인한 상태인지를 보여준다. &lt;code&gt;who -H&lt;/code&gt; 와 같이 &lt;code&gt;-H&lt;/code&gt; 옵션을 주면 결과에 헤더도 붙일 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;w&lt;/code&gt; 는 현재 누가 로그인한 상태이고 어떤 작업을 하고 있는지를 보여준다. Terminal Type, FROM (remote host 의 IP address 또는 domain name), LOGIN@ (접속 시간), IDLE (최종 명령 후 대기 시간), WHAT (현재 사용 중인 Shell 이나 작업 등) 등을 출력한다.&lt;/p&gt;
&lt;h1&gt;Related files&lt;/h1&gt;
&lt;p&gt;Linux 에서 사용자 정보와 관련된 여러가지 파일들이 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/etc/passwd&lt;/code&gt; : User account information&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/etc/shadow&lt;/code&gt; : Secure user account information&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/etc/group&lt;/code&gt; : Group account information&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/etc/gshadow&lt;/code&gt; : Secure group account information&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/etc/login.defs&lt;/code&gt; : Shadow password suite configuration&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/etc/skel&lt;/code&gt; : Directory containing default files.&lt;/li&gt;
&lt;/ul&gt;</content><category term="linux"></category><category term="user"></category></entry><entry><title>iptables</title><link href="https://imjang57.github.io/garret/linux-command-iptables.html" rel="alternate"></link><published>2017-01-01T00:00:00+09:00</published><updated>2017-01-01T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-01:/garret/linux-command-iptables.html</id><summary type="html">&lt;p&gt;iptables 사용법&lt;/p&gt;</summary><content type="html">&lt;h1&gt;iptables&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;iptables&lt;/em&gt; 는 리눅스에서 네트웍 방화벽으로 사용되는 도구이다. Source, Destination, Protocol, State 등으로 다양한 조건을 설정할 수 있다. 리눅스 호스트에서 제공되는 가장 기초적인 방화벽 도구이며, C언어로 작성된 packet filtering framework 인 &lt;a href="https://www.netfilter.org"&gt;netfilter&lt;/a&gt; 를 기반으로 동작한다. 사실은 iptables 가 netfilter 의 하위 프로젝트라고 볼 수도 있다. 보통 &lt;em&gt;netfilter/iptables&lt;/em&gt; 와 같이 함께 언급되기도 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.netfilter.org"&gt;netfilter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.netfilter.org/projects/iptables/index.html"&gt;iptables&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://git.netfilter.org/"&gt;netfilter git repository&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://git.netfilter.org/iptables/"&gt;iptables git repository&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;대부분의 리눅스 배포판에서 &lt;em&gt;iptables&lt;/em&gt; 는 기본적으로 제공된다. &lt;code&gt;iptables&lt;/code&gt; 명령으로 방화벽 정책 관련 작업을 수행할 수 있고 &lt;em&gt;iptables-service&lt;/em&gt; 패키지를 설치하면 Daemon 형태로 관리가 가능하다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;iptables&lt;/em&gt; 에서 사용되는 정책(Rule)을 저장하기 위한 파일의 위치는 &lt;code&gt;/etc/sysconfig/iptables&lt;/code&gt; 이다.&lt;/p&gt;
&lt;p&gt;참고로, CentOS 7 부터는 &lt;em&gt;iptables&lt;/em&gt; 대신 &lt;a href="http://www.firewalld.org"&gt;firewalld&lt;/a&gt; 가 사용된다. 클라우드 환경에서의 조금 더 유연한 방화벽 관리를 위해 python 으로 만든 도구인데, 내부적으로는 &lt;em&gt;netfilter/iptables&lt;/em&gt; 를 사용한 front-end for the iptables 이다. 사용자 입장에서는 그저 명령어를 &lt;code&gt;iptables&lt;/code&gt; 대신에 &lt;code&gt;firewall-cmd&lt;/code&gt; 나 &lt;code&gt;firewall-config&lt;/code&gt; 를 사용하게 된 것이다. CentOS 7 에는 &lt;em&gt;iptables&lt;/em&gt; 자체는 있지만 &lt;em&gt;iptables-service&lt;/em&gt; 가 없어서 &lt;em&gt;firewalld&lt;/em&gt; 로 방화벽을 관리하도록 하는데, 사실 &lt;em&gt;filrewalld&lt;/em&gt; 를 끄고, &lt;em&gt;iptables-service&lt;/em&gt; 를 설치한 후 사용할 수도 있다(인터넷에 찾으면 많이 나온다). 하지만 이왕 바뀐거 나중에 다시 롤백되지 않을 가능성이 크니 익숙해지는게 좋을 테고 익숙해지면 &lt;em&gt;Redhat&lt;/em&gt; 이 &lt;em&gt;firewalld&lt;/em&gt; 를 선택한 이유도 알게 될 지도.. 어쨌든 이 글에선 &lt;em&gt;firewalld&lt;/em&gt; 에 대해선 다루지 않는다.&lt;/p&gt;
&lt;p&gt;만약 iptables 가 설치되어 있지 않다면 아래와 같이 설치하자.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ yum install iptables iptables-service
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;tables&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;iptables&lt;/em&gt; 는 4개의 &lt;em&gt;table&lt;/em&gt; 을 관리한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;filter&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;nat&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;mangle&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;raw&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;보통 사용하는 &lt;em&gt;table&lt;/em&gt; 은 &lt;em&gt;filter&lt;/em&gt; 이다.&lt;/p&gt;
&lt;h2&gt;chain&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;filter table&lt;/em&gt; 에는 &lt;em&gt;INPUT&lt;/em&gt;, &lt;em&gt;OUTPUT&lt;/em&gt;, &lt;em&gt;FORWARD&lt;/em&gt; 3개의 &lt;em&gt;chain&lt;/em&gt; 이 있다. 각 &lt;em&gt;chain&lt;/em&gt; 들은 Network Traffic (IP Packet) 에 대하여 정해진 규칙들을 수행한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;INPUT&lt;/em&gt; : Host 를 향해 들어오는 Packet&lt;/li&gt;
&lt;li&gt;&lt;em&gt;OUTPUT&lt;/em&gt; : Host 에서 나가는 Packet&lt;/li&gt;
&lt;li&gt;&lt;em&gt;FORWARD&lt;/em&gt; : Host 가 Destination 이 아닌 Packet&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;INPUT chain&lt;/em&gt; 에 해당하는 Packet 을 허용(&lt;em&gt;ACCEPT&lt;/em&gt;), 거부(&lt;em&gt;REJECT&lt;/em&gt;), 또는 드랍(&lt;em&gt;DROP&lt;/em&gt;) 할 지 결정할 수 있다.&lt;/p&gt;
&lt;h2&gt;match&lt;/h2&gt;
&lt;p&gt;어떤 Packet 에 규칙을 적용할지 판단하기 위한 조건이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--source&lt;/code&gt; (&lt;code&gt;-s&lt;/code&gt;) : Source IP address 또는 Network&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--destination&lt;/code&gt; (&lt;code&gt;-d&lt;/code&gt;) : Destination address 또는 Network&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--protocol&lt;/code&gt; (&lt;code&gt;-p&lt;/code&gt;) : Protocol&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--in-interface&lt;/code&gt; (&lt;code&gt;-i&lt;/code&gt;) : 입력 interface&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--out-interface&lt;/code&gt; (&lt;code&gt;-o&lt;/code&gt;) : 출력 interface&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--state&lt;/code&gt; : 연결 상태&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--string&lt;/code&gt; : Application Layer Data 의 Byte 순서&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--comment&lt;/code&gt; : Kernel memory 내의 규칙과 연계되는 최대 256 bytes 주석&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--syn&lt;/code&gt; (&lt;code&gt;-y&lt;/code&gt;) : SYN Packet 을 허용하지 않음&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--fragment&lt;/code&gt; (&lt;code&gt;-f&lt;/code&gt;) : 두 번째 이후의 조각에 대해서 규칙을 명시&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--table&lt;/code&gt; (&lt;code&gt;-t&lt;/code&gt;) : 처리될 table&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--jump&lt;/code&gt; (&lt;code&gt;-j&lt;/code&gt;) : 규칙에 맞는 Packet 을 어떻게 처리할 것인가를 명시&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--match&lt;/code&gt; (&lt;code&gt;-m&lt;/code&gt;) : 특정 module 과의 매치&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;target&lt;/h2&gt;
&lt;p&gt;Packet 에 적용하려는 동작이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;ACCEPT&lt;/em&gt; : Packet 을 받아들인다.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;DROP&lt;/em&gt; : Packet 을 버린다. Packet 을 송신한 쪽은 아무런 응답도 받지 못한다.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;REJECT&lt;/em&gt; : Packet 을 버리고 이와 동시에 적절한 응답 패킷(connection refused)을 전송한다.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;LOG&lt;/em&gt; : Packet 을 syslog에 기록한다.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;RETURN&lt;/em&gt; : 호출 체인 내에서 Packet 처리를 계속한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;연결 추적(Connection Tracking)&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;iptables&lt;/em&gt; 는 연결 추적(connection tracking)이라는 방법을 사용하여 내부 Network 상 서비스 연결 상태에 따라서 그 연결을 감시하고 제한할 수 있게 해준다. 연결 추적 방식은 연결 상태를 표에 저장하기 때문에, 다음과 같은 연결 상태에 따라서 시스템 관리자가 연결을 허용하거나 거부할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;NEW&lt;/em&gt; : 새로운 Connection 을 요청하는 Packet, (예: &lt;em&gt;HTTP&lt;/em&gt; 요청)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;ESTABLISHED&lt;/em&gt; : 기존 Connection 의 일부인 Packet&lt;/li&gt;
&lt;li&gt;&lt;em&gt;RELATED&lt;/em&gt; : 기존 Connection 에 속하지만 새로운 Connection 을 요청하는 Packet, 예를 들면 접속 port 가 20인 수동 FTP의 경우 전송 포트는 사용되지 않은 1024 이상의 어느 port 라도 사용 가능하다.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;INVALID&lt;/em&gt; : 연결 추적표에서 어디 Connection 에도 속하지 않은 Packet&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;상태에 기반(stateful)한 &lt;em&gt;iptables&lt;/em&gt; 연결 추적 기능은 어느 Network Protocol 에서나 사용 가능하다. &lt;em&gt;UDP&lt;/em&gt; 와 같이 상태를 저장하지 않는 (stateless) Protocol 에서도 사용할 수 있다.&lt;/p&gt;
&lt;h2&gt;명령어(commond)&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;iptables&lt;/em&gt; 에서 사용 가능한 명령들의 목록:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-A&lt;/code&gt; (&lt;code&gt;--append&lt;/code&gt;) : 새로운 규칙을 추가한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-D&lt;/code&gt; (&lt;code&gt;--delete&lt;/code&gt;) : 규칙을 삭제한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-C&lt;/code&gt; (&lt;code&gt;--check&lt;/code&gt;) : 패킷을 테스트한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-R&lt;/code&gt; (&lt;code&gt;--replace&lt;/code&gt;) : 새로운 규칙으로 교체한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-I&lt;/code&gt; (&lt;code&gt;--insert&lt;/code&gt;) : 새로운 규칙을 삽입한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-L&lt;/code&gt; (&lt;code&gt;--list&lt;/code&gt;) : 규칙을 출력한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-F&lt;/code&gt; (&lt;code&gt;--flush&lt;/code&gt;) : &lt;em&gt;chain&lt;/em&gt; 으로부터 규칙을 모두 삭제한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-Z&lt;/code&gt; (&lt;code&gt;--zero&lt;/code&gt;) : 모든 &lt;em&gt;chain&lt;/em&gt; 의 패킷과 바이트 카운터 값을 0으로 만든다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-N&lt;/code&gt; (&lt;code&gt;--new&lt;/code&gt;) : 새로운 &lt;em&gt;chain&lt;/em&gt; 을 만든다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-X&lt;/code&gt; (&lt;code&gt;--delete-chain&lt;/code&gt;) : &lt;em&gt;chain&lt;/em&gt; 을 삭제한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-P&lt;/code&gt; (&lt;code&gt;--policy&lt;/code&gt;) : 기본정책을 변경한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;추가로 &lt;code&gt;-L&lt;/code&gt; 옵션 이용시 &lt;code&gt;-n&lt;/code&gt; (&lt;code&gt;--numeric&lt;/code&gt;) 옵션을 추가하면 address 와 port 를 더 편하게 볼 수 있다. (&lt;code&gt;iptables -nL&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;내용을 확인할 때 &lt;code&gt;--line-numbers&lt;/code&gt; 를 추가하면 각 Ruleset 들의 순서도 같이 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-v&lt;/code&gt; (&lt;code&gt;--verbose&lt;/code&gt;) 옵션을 사용하면 더 다양한 정보를 볼 수 있다.&lt;/p&gt;
&lt;p&gt;추가 사용법은 &lt;code&gt;-h&lt;/code&gt; (&lt;code&gt;--help&lt;/code&gt;) 를 확인하자.&lt;/p&gt;
&lt;h2&gt;기본 동작&lt;/h2&gt;
&lt;p&gt;다음은 &lt;em&gt;iptables&lt;/em&gt; 의 기본 동작 과정이다.&lt;/p&gt;
&lt;p&gt;패킷에 대한 동작은 위에서 부터 차례로 각 규칙에 대해 검사하고, 그 규칙과 일치하는 패킷에 대하여 타겟에 지정한 &lt;em&gt;ACCEPT&lt;/em&gt;, &lt;em&gt;DROP&lt;/em&gt; 등을 수행한다.&lt;/p&gt;
&lt;p&gt;규칙이 일치하고 작업이 수행되면, 그 패킷은 해당 규칙의 결과에 따리 처리하고 체인에서 추가 규칙을 무시한다.&lt;/p&gt;
&lt;p&gt;패킷이 체인의 모든 규칙과 매치하지 않아 규칙의 바닥에 도달하면 정해진 기본정책(policy)이 수행된다.&lt;/p&gt;
&lt;p&gt;기본 정책은 policy &lt;em&gt;ACCEPT&lt;/em&gt;, policy &lt;em&gt;DROP&lt;/em&gt; 으로 설정할 수 있다.&lt;/p&gt;
&lt;p&gt;일반적으로 기본정책은 모든 패킷에 대해 &lt;em&gt;DROP&lt;/em&gt; 을 설정하고 특별히 지정된 포트와 IP주소등에 대해 &lt;em&gt;ACCEPT&lt;/em&gt; 를 수행하게 만든다.&lt;/p&gt;
&lt;h1&gt;iptables 사용하기&lt;/h1&gt;
&lt;p&gt;iptables 적용 예:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;iptables -P INPUT ACCEPT&lt;/code&gt; : &lt;em&gt;INPUT Chain&lt;/em&gt; 의 기본 정책을 &lt;em&gt;ACCEPT&lt;/em&gt; 로 설정&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iptables -P INPUT DROP&lt;/code&gt; : &lt;em&gt;INPUT Chain&lt;/em&gt; 의 기본정책을 &lt;em&gt;DROP&lt;/em&gt; 으로 설정&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iptables -F&lt;/code&gt; : &lt;em&gt;Chain&lt;/em&gt; 에 정의된 모든 규칙을 삭제&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iptables -nL&lt;/code&gt; : 현재 ruleset 설정 확인(address 와 port 는 숫자로 출력)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iptables -A INPUT -i lo -j ACCEPT&lt;/code&gt; : &lt;em&gt;INPUT Chain&lt;/em&gt; 에 localhost interface 인 Packet 은 모두 &lt;em&gt;ACCEPT&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iptables -A INPUT -m state — state ESTABLISHED,RELATED -j ACCEPT&lt;/code&gt; : &lt;em&gt;INPUT Chain&lt;/em&gt; 에 state module 의 state 가 &lt;em&gt;ESTABLISHED&lt;/em&gt;, &lt;em&gt;RELATED&lt;/em&gt; 인 Packet 에 대해 &lt;em&gt;ACCEPT&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iptables -A INPUT -p tcp -m tcp — dport 22 -j ACCEPT&lt;/code&gt; : &lt;em&gt;INPUT Chain&lt;/em&gt; 에 Protocol 의 &lt;em&gt;TCP&lt;/em&gt; 이며 destination port 가 22번인 Packet 에 대해 &lt;em&gt;ACCEPT&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;service iptables save&lt;/code&gt; 명령을 실행하면 &lt;code&gt;/etc/sysconfig/iptables&lt;/code&gt; 에 &lt;em&gt;iptables&lt;/em&gt; 현재 설정이 저장된다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;iptables&lt;/em&gt; 규칙을 만들 때는 순서가 매우 중요하다. 예를 들어 만일 &lt;em&gt;chain&lt;/em&gt; 에서 local network 인 192.168.100.0/24 subnetwork 에서 들어오는 모든 packet 을 &lt;em&gt;DROP&lt;/em&gt; 하도록 지정한 후 (&lt;em&gt;DROP&lt;/em&gt; 하도록 지정된 subnetwork 에 포함되는) 192.168.100.13 에서 들어오는 packet 을 모두 허용하는 &lt;em&gt;chain&lt;/em&gt; (&lt;code&gt;-A&lt;/code&gt;)을 그 후에 추가하면 뒤에 추가된 추가 규칙이 무시된다. 먼저 192.168.100.13 을 허용하는 규칙을 설정한 후 subnet 을 &lt;em&gt;DROP&lt;/em&gt; 하는 규칙을 설정해야한다.&lt;/p&gt;
&lt;p&gt;HTTP Web Server 를 용할 경우:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;iptables -A INPUT -p tcp -m tcp --dport 80 -j ACCEPT
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;HTTPS:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;iptables -A INPUT -p tcp -m tcp --dport 443 -j ACCEPT
-A INPUT -m state --state NEW -m tcp -p tcp -m multiport --dports 80,443 -j ACCEPT
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;MySQL (port 3306):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;iptables -A INPUT -p tcp --dport 3306 -j ACCEPT
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;FTP(passive mode):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;iptables -A INPUT -p tcp --dport 21 -j ACCEPT
iptables -A OUTPUT -p tcp --sport 21 -j ACCEPT
iptables -A INPUT -p tcp --dport 1024:65535 -j ACCEPT
iptables -A OUTPUT -p tcp --sport 1024:65535 -j ACCEPT
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;NTP 시간동기화:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;iptables -A INPUT -p udp --dport 123 -j ACCEPT
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;서버의 취약점을 차단하기 위한 iptables 설정 예&lt;/h1&gt;
&lt;p&gt;NULL 패킷 차단: &lt;code&gt;iptables -A INPUT -p tcp --tcp-flags ALL NONE -j DROP&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;NULL 패킷은 정찰 패킷으로 서버설정의 약한 곳을 찾기위한 방법으로 사용된다.&lt;/p&gt;
&lt;h1&gt;기타 사용법&lt;/h1&gt;
&lt;p&gt;기타 &lt;em&gt;iptables&lt;/em&gt; 사용법에 대해 알아보자.&lt;/p&gt;
&lt;h2&gt;iptables 수정&lt;/h2&gt;
&lt;p&gt;등록된 &lt;em&gt;iptables&lt;/em&gt; 를 수정하는 방법은 &lt;code&gt;/etc/sysconfig/iptables&lt;/code&gt; 에서 직접 vi로 수정하거나 &lt;code&gt;iptables&lt;/code&gt; 명령어를 사용한다.&lt;/p&gt;
&lt;p&gt;실행 순번을 확인하기: &lt;code&gt;iptables -nL --line-number&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;순번 3의 행을 수정(replace, &lt;code&gt;-R&lt;/code&gt;): &lt;code&gt;iptables -R INPUT 3 -p tcp --dport 2222 -j ACCEPT&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;인터페이스 지정&lt;/h2&gt;
&lt;p&gt;Network interface 를 지정하여 &lt;em&gt;iptables&lt;/em&gt; 를 적용할 수도 있다.&lt;/p&gt;
&lt;p&gt;루프백 인터페이스에 대해 모든 패킷을 허용: &lt;code&gt;iptables -A INPUT -i lo -j ACCEPT&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;랜카드 지정에 대해 모든 패킷을 허용: &lt;code&gt;iptables -A INPUT -i eth0 -j ACCEPT&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;IP 주소 지정&lt;/h2&gt;
&lt;p&gt;IP address 를 지정하여 iptables 를 적용할 수도 있다.&lt;/p&gt;
&lt;p&gt;신뢰할 만한 ip에 대해 모든 패킷을 허용: &lt;code&gt;iptables -A INPUT -s 192.168.0.3 -j ACCEPT&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;신뢰할 만한 ip 대역에 대해 모든 패킷을 허용: &lt;code&gt;iptables -A INPUT -s 192.168.0.0/24 -j ACCEPT&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;신뢰할 만한 ip 대역에 대해 모든 패킷을 허용: &lt;code&gt;iptables -A INPUT -s 192.168.0.0/255.255.255.0 -j ACCEPT&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;신뢰할 만한 ip와 MAC주소에 대해 모든 패킷을 허용: &lt;code&gt;iptables -A INPUT -s 192.168.0.3 -m mac — mac-source 00:50:80:FD:E6:32 -j ACCEPT&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;포트 범위지정: &lt;code&gt;iptables -A INPUT -p tcp --dport 6881:6890 -j ACCEPT&lt;/code&gt;&lt;/p&gt;
&lt;h1&gt;자동화 스크립트&lt;/h1&gt;
&lt;p&gt;자주 방화벽 설정을 초기화하고 재설정해야 한다면 자동화 스크립트를 짜놓는게 좋다. 아래는 그에 대한 예이다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/bin/bash&lt;/span&gt;
&lt;span class="c1"&gt;# iptables 설정 자동화 스크립트&lt;/span&gt;
&lt;span class="c1"&gt;# 입맛에 따라 수정해서 사용합시다.&lt;/span&gt;
iptables -F
&lt;span class="c1"&gt;# TCP 포트 22번을 SSH 접속을 위해 허용&lt;/span&gt;
&lt;span class="c1"&gt;# 원격 접속을 위해 먼저 설정합니다&lt;/span&gt;
iptables -A INPUT -p tcp -m tcp --dport &lt;span class="m"&gt;22&lt;/span&gt; -j ACCEPT
&lt;span class="c1"&gt;# 기본 정책을 설정합니다&lt;/span&gt;
iptables -P INPUT DROP
iptables -P FORWARD DROP
 iptables -P OUTPUT ACCEPT
&lt;span class="c1"&gt;# localhost 접속 허용&lt;/span&gt;
iptables -A INPUT -i lo -j ACCEPT
&lt;span class="c1"&gt;# established and related 접속을 허용&lt;/span&gt;
iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
&lt;span class="c1"&gt;# Apache 포트 80 허용&lt;/span&gt;
iptables -A INPUT -p tcp --dport &lt;span class="m"&gt;80&lt;/span&gt; -j ACCEPT
&lt;span class="c1"&gt;# 설정을 저장&lt;/span&gt;
/sbin/service iptables save
&lt;span class="c1"&gt;# 설정한 내용을 출력&lt;/span&gt;
iptables -L -v
위 내용을 입맛에 맞게 수정한 후에 저장&lt;span class="o"&gt;(&lt;/span&gt;myfirewall&lt;span class="o"&gt;)&lt;/span&gt;
권한부여: chmod +x myfirewall
실행: ./myfirewall
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;References&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;http://webdir.tistory.com/170&lt;/li&gt;
&lt;/ul&gt;</content><category term="iptables"></category></entry><entry><title>Linux help, man, info, TLDP</title><link href="https://imjang57.github.io/garret/linux-help-man-info-tldp.html" rel="alternate"></link><published>2017-01-01T00:00:00+09:00</published><updated>2017-05-07T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-01:/garret/linux-help-man-info-tldp.html</id><summary type="html">&lt;p&gt;Linux 를 사용함에 있어서 가장 큰 도움이 되고 필수로 알아야 할 도움말이나 문서들에 대해서 간단한게 정리한 글&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Linux &lt;em&gt;help&lt;/em&gt;, &lt;em&gt;man pages&lt;/em&gt;, GNU &lt;em&gt;info&lt;/em&gt;, TLDP&lt;/h1&gt;
&lt;p&gt;Linux 를 사용함에 있어서 가장 큰 도움이 되고 필수로 알아야 할 도움말이나 문서들에 대해서 간단한게 정리한 글이다.&lt;/p&gt;
&lt;p&gt;Linux 를 사용하다보면 Console 등의 CLI (Command-Line Interface) 에서 여러 명령어들을 사용하게 된다. 그런데 매우 많은 명령어들이 있고 각 명령어마다 다양한 옵션과 Argument 를 사용할 수 있기 때문에 이들의 사용법을 모두 외우는 것은 거의 불가능하고 비효율적이다.&lt;/p&gt;
&lt;p&gt;그래서 어떤 명령어에 대해 익히면 이후에는 &lt;code&gt;--help&lt;/code&gt; 옵션, &lt;em&gt;man pages&lt;/em&gt; utility, GNU &lt;em&gt;info&lt;/em&gt; utility 등을 참고하며 사용하게 된다.&lt;/p&gt;
&lt;p&gt;명령어들을 만든 개발자들은 왠만하면 &lt;code&gt;--help&lt;/code&gt; 정도는 최소한 제공하며, Linux 에서 사용되는 대부분의 명령들은 잘 작성된 &lt;code&gt;--help&lt;/code&gt; 와 &lt;em&gt;man pages&lt;/em&gt;  매뉴얼을 제공한다. 사실 이들을 제공하지 않으면 Linux 를 사용하는게 매우 힘들어 진다.&lt;/p&gt;
&lt;p&gt;또한, 자발적인 기여자들이 모여 TLDP()&lt;/p&gt;
&lt;h1&gt;&lt;code&gt;--help&lt;/code&gt; 옵션&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;--help&lt;/code&gt; 옵션을 거의 필수적인 요소이다. 이게 없다면 프로그램을 사용하는 사람은 한 명도 없을 수도 있다. 최소한 사용방법을 알아야 할 것 아닌가.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;man pages&lt;/em&gt; 나 &lt;em&gt;info&lt;/em&gt; 의 경우는 그 자체로 하나의 프로그램이라 (정말 극소수이지만) 어떤 시스템에는 없을 수도 있다. 따라서 &lt;code&gt;--help&lt;/code&gt; 옵션을 개발자가 사용자에게 제공해줄 수 있는 최소한의 문서이다.&lt;/p&gt;
&lt;p&gt;예를 들어, &lt;code&gt;man&lt;/code&gt; 명령은 다음과 같은 &lt;code&gt;--help&lt;/code&gt; 를 출력한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;man --help
man, version 1.6c

usage: man [-adfhktwW] [section] [-M path] [-P pager] [-S list]
    [-m system] [-p string] name ...

  a : find all matching entries
  c : do not use cat file
  d : print gobs of debugging information
  D : as for -d, but also display the pages
  f : same as whatis(1)
  h : print this help message
  k : same as apropos(1)
  K : search for a string in all pages
  t : use troff to format pages for printing
  w : print location of man page(s) that would be displayed
      (if no name given: print directories that would be searched)
  W : as for -w, but display filenames only

  C file   : use `file&amp;#39; as configuration file
  M path   : set search path for manual pages to `path&amp;#39;
  P pager  : use program `pager&amp;#39; to display pages
  S list   : colon separated section list
  m system : search for alternate system&amp;#39;s man pages
  p string : string tells which preprocessors to run
               e - [n]eqn(1)   p - pic(1)    t - tbl(1)
               g - grap(1)     r - refer(1)  v - vgrind(1)
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;&lt;em&gt;man pages&lt;/em&gt;&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;man pages&lt;/em&gt; 는 Unix 와 Linux 에서 대부분 기본 제공되는 도구이다. &lt;em&gt;man pages&lt;/em&gt; 라는 프로그램 이름은 &lt;em&gt;manual pages&lt;/em&gt; 를 의미한다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;man &amp;lt;page name&amp;gt;&lt;/code&gt; 과 같이 실행 할 수 있다. 예를 들어 &lt;code&gt;man man&lt;/code&gt; 을 실행하면 아래와 같이 &lt;code&gt;man&lt;/code&gt; 명령어에 대한 도움말을 볼 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;man(1)                                                                                                                           man(1)



NAME
       man - format and display the on-line manual pages

SYNOPSIS
       man  [-acdfFhkKtwW]  [--path]  [-m system] [-p string] [-C config_file] [-M pathlist] [-P pager] [-B browser] [-H htmlpager] [-S
       section_list] [section] name ...


DESCRIPTION
       man formats and displays the on-line manual pages.  If you specify section, man only looks in that section of the manual.   name
       is normally the name of the manual page, which is typically the name of a command, function, or file.  However, if name contains
       a slash (/) then man interprets it as a file specification, so that you can do man ./foo.5 or even man /cd/foo/bar.1.gz.

       See below for a description of where man looks for the manual page files.


OPTIONS
       -C  config_file
              Specify the configuration file to use; the default is /private/etc/man.conf.  (See man.conf(5).)

       -M  path
              Specify the list of directories to search for man pages.  Separate the directories with colons.  An  empty  list  is  the
              same as not specifying -M at all.  See SEARCH PATH FOR MANUAL PAGES.

       -P  pager
              Specify  which  pager to use.  This option overrides the MANPAGER environment variable, which in turn overrides the PAGER
              variable.  By default, man uses /usr/bin/less -is.

       -B     Specify which browser to use on HTML files.  This option overrides the BROWSER environment variable. By default, man uses
              /usr/bin/less-is,

       -H     Specify a command that renders HTML files as text.  This option overrides the HTMLPAGER environment variable. By default,
              man uses /bin/cat,

       -S  section_list
              List is a colon separated list of manual sections to search.  This option overrides the MANSECT environment variable.

...........
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;man&lt;/code&gt; 을 실행한 결과는 &lt;code&gt;less&lt;/code&gt; 나 &lt;code&gt;more&lt;/code&gt; 같은 pager utility 를 사용하여 출력된다. &lt;code&gt;q&lt;/code&gt; 를 입력하면 종료되고, &lt;code&gt;/&lt;/code&gt; 를 입력하면 문자열 검색을 수행할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;man pages&lt;/em&gt; 는 주제에 따라 여러가지 secton 으로 나누어서 제공된다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 : User commands&lt;/li&gt;
&lt;li&gt;2 : System calls&lt;/li&gt;
&lt;li&gt;3 : Subroutines (Libraries)&lt;/li&gt;
&lt;li&gt;4 : Devices (files in &lt;code&gt;/dev&lt;/code&gt; directory)&lt;/li&gt;
&lt;li&gt;5 : File formats (example : format of &lt;code&gt;/etc/passwd&lt;/code&gt; file)&lt;/li&gt;
&lt;li&gt;6 : Games&lt;/li&gt;
&lt;li&gt;7 : Miscellaneous (Macro, naming rules, etc)&lt;/li&gt;
&lt;li&gt;8 : System administration&lt;/li&gt;
&lt;li&gt;9 : Local&lt;/li&gt;
&lt;li&gt;10 : New&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;man write&lt;/code&gt; 라고 실행하면 &lt;em&gt;write&lt;/em&gt; 라는 사용자 명령어에 대한 내용을 출력하고 &lt;code&gt;man 2 write&lt;/code&gt; 라고 실행하면 &lt;em&gt;write&lt;/em&gt; 라는 linux kernel system call 에 대한 내용을 출력한다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;man passwd&lt;/code&gt; 라고 실행하면 &lt;em&gt;passwd&lt;/em&gt; 라는 사용자 명령어에 대한 내용을 출력하고 &lt;code&gt;man 5 passwd&lt;/code&gt; 라고 실행하면 관련된 파일(&lt;code&gt;/etc/passwd&lt;/code&gt;)들에 대한 내용을 출력한다&lt;/p&gt;
&lt;p&gt;&lt;code&gt;man -k passwd&lt;/code&gt; 를 실행하면 passwd 라는 키워드와 관련있는 매뉴얼들의 목록을 출력한다. &lt;code&gt;-k&lt;/code&gt; 옵션을 키워드를 의미한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ man -k passwd
chkpasswd&lt;span class="o"&gt;(&lt;/span&gt;8&lt;span class="o"&gt;)&lt;/span&gt;             - verifies user password against various systems
firmwarepasswd&lt;span class="o"&gt;(&lt;/span&gt;8&lt;span class="o"&gt;)&lt;/span&gt;        - tool &lt;span class="k"&gt;for&lt;/span&gt; setting and removing firmware passwords on a system
htpasswd&lt;span class="o"&gt;(&lt;/span&gt;1&lt;span class="o"&gt;)&lt;/span&gt;              - Manage user files &lt;span class="k"&gt;for&lt;/span&gt; basic authentication
kpasswd&lt;span class="o"&gt;(&lt;/span&gt;1&lt;span class="o"&gt;)&lt;/span&gt;               - Kerberos &lt;span class="m"&gt;5&lt;/span&gt; password changing program
kpasswdd&lt;span class="o"&gt;(&lt;/span&gt;8&lt;span class="o"&gt;)&lt;/span&gt;              - Kerberos &lt;span class="m"&gt;5&lt;/span&gt; password changing server
ldappasswd&lt;span class="o"&gt;(&lt;/span&gt;1&lt;span class="o"&gt;)&lt;/span&gt;            - change the password of an LDAP entry
passwd&lt;span class="o"&gt;(&lt;/span&gt;1&lt;span class="o"&gt;)&lt;/span&gt;                - modify a user&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;s password
passwd&lt;span class="o"&gt;(&lt;/span&gt;1ssl&lt;span class="o"&gt;)&lt;/span&gt;             - compute password hashes
passwd&lt;span class="o"&gt;(&lt;/span&gt;5&lt;span class="o"&gt;)&lt;/span&gt;, master.passwd&lt;span class="o"&gt;(&lt;/span&gt;5&lt;span class="o"&gt;)&lt;/span&gt; - format of the password file
slapd-passwd&lt;span class="o"&gt;(&lt;/span&gt;5&lt;span class="o"&gt;)&lt;/span&gt;          - /etc/passwd backend to slapd
slappasswd&lt;span class="o"&gt;(&lt;/span&gt;8&lt;span class="o"&gt;)&lt;/span&gt;            - OpenLDAP password utility
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;em&gt;man pages&lt;/em&gt; 가 화면에 출력하기 위한 문서들은 &lt;code&gt;/usr/share/doc&lt;/code&gt; 에 저장되며 최초에는 압축파일 형태로 있다가 최초에 출력될 때 압축 해제된다.&lt;/p&gt;
&lt;p&gt;참고로, &lt;a href="https://linux.die.net/man/"&gt;Linux man pages&lt;/a&gt;와 같이 온라인에서 man pages 를 확인할 수 있는 여러 사이트들도 있다.&lt;/p&gt;
&lt;h1&gt;GNU &lt;em&gt;info&lt;/em&gt;&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;man pages&lt;/em&gt; 는 Unix 에서 시작되어 오랜 시간 사용되고 있는 도구이다. GNU 에서는 조금 더 문서를 잘 표현할 수 있는 잘 정의된 포맷을 제안했고 이를 Redhat 에서 개발 및 배포했는데 이것이 &lt;em&gt;info&lt;/em&gt; 라는 프로그램이다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;info [menu item]&lt;/code&gt; 의 형태로 실행되며 실행된 상태에서 여러 명령들을 입력하여 다양한 작업을 수행할 수 있다. &lt;code&gt;info&lt;/code&gt; 가 실행된 상태에서 &lt;code&gt;?&lt;/code&gt; 를 입력하면 사용 가능한 명령들을 확인할 수 있으며 각 키보드 입력을 위한 표기법은 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;C-key&lt;/code&gt; : &lt;em&gt;CONTROL&lt;/em&gt; + key (example : &lt;code&gt;C-h&lt;/code&gt; 는 &lt;em&gt;CONTROL&lt;/em&gt; + h key 를 의미)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;M-key&lt;/code&gt; : &lt;em&gt;META&lt;/em&gt;(&lt;em&gt;ALT&lt;/em&gt;) + key (example : &lt;code&gt;M-x&lt;/code&gt; 는 &lt;em&gt;META&lt;/em&gt; + x key 를 의미)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;그런데 사실, GNU 에서 만든 프로그램들은 GNU &lt;em&gt;info&lt;/em&gt; 에 더 자세히 문서화가 되고 최신으로 업데이트 되어 있다고는 하지만 대부분의 경우 &lt;em&gt;man pages&lt;/em&gt; 프로그램만으로도 충분했기에 잘 사용하지 않는다. 인터페이스도 익숙하지 않아서 더 사용하지 않는다.&lt;/p&gt;
&lt;h1&gt;TLDP&lt;/h1&gt;
&lt;p&gt;&lt;a href="http://www.tldp.org/"&gt;TLDP (The Linux Documentation Project)&lt;/a&gt;는 자발적으로 참여하는 봉사자들에 의해 진행되는 프로젝트로, 리눅스에 대한 내용을 문서화하기 위한 프로젝트이다. &lt;a href="https://github.com/tLDP/LDP"&gt;Github repository&lt;/a&gt;도 있다.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://ko.wikipedia.org/wiki/%EB%A6%AC%EB%88%85%EC%8A%A4_%EB%AC%B8%EC%84%9C%ED%99%94_%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8"&gt;wikipedia 의 설명&lt;/a&gt;에 다음과 같이 언급되어 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;리눅스 문서화 프로젝트 (The Linux Documentation Project, TLDP)는 전적으로 자발적인 참여로 진행되는 프로젝트로 리눅스 관련 문서를 만드는 데 목표가 있다.
이 프로젝트는 처음엔 리눅스 해커들끼리 각자가 만들어 놓은 문서를 공유하기 위한 목적으로 시작되었다. 따라서 문서의 수준은 직업 시스템 어드민(admin) 등 숙달된 사용자들의 눈높이에 맞춰져 있었다. 그러나 현재에는 초보자들이 따라할 수 있는 강좌도 많이 포함하고 있다.
현재 LDP는 475개 이상의 문서를 제공하고 있다. 이 중 십여개는 일반 책의 분량이고, 이들 대부분은 오라일리 등의 컴퓨터 전문 출판사에 의해 출판되어 책으로 구입할 수 있다. LDP는 또한 사용자가 단계적으로 따라해서 목적을 이룰 수 있는 다수의 HowTo 문서 또한 제공한다. 문서의 목적은 매우 다양해서 특정 모뎀의 설정 같은 매우 구체적인 것일 수도 있고, 네트워크 관리와 같은 광대하고 추상적인 것일 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;또한, 설명에 따르면 TLDP 는 리눅스 관련된 최초에 웹 사이트이다.&lt;/p&gt;
&lt;p&gt;KLDP 에서도 매우 많은 TLDP 문서의 번역을 제공하고 있다. 예를 들면 &lt;a href="https://wiki.kldp.org/Translations/html/SysAdminGuide-KLDP/book1.html"&gt;The Linux System Administrators' Guide 번역&lt;/a&gt;과 같은 것들이 있다. KLDP 의 더 많은 번역 문서들은 &lt;a href="https://wiki.kldp.org/Translations/html/"&gt;여기&lt;/a&gt;에서 확인할 수 있다.&lt;/p&gt;
&lt;h1&gt;기타&lt;/h1&gt;
&lt;p&gt;IT는 매우 많은 분야가 있고 매우 많은 요소들이 결합되어 유기적으로 동작한다. 한 명이 모든 내용을 알기는 불가능하다. 그래서 웹을 통한 지식 공유가 매우 중요하다. 내 분야에서의 기초 지식과 핵심 원리에 집중하고 나머지는 위임하거나 협력해야 한다.&lt;/p&gt;
&lt;p&gt;TLDP 외에도 &lt;a href="https://www.google.com/"&gt;google&lt;/a&gt; 검색을 습관화하고 &lt;a href="http://stackoverflow.com/"&gt;stack overflow&lt;/a&gt; 등을 적극 활용하면 좋다. 단, 잘못된 지식이나 오래된 지식은 거를 수도 있어야 하니 무조건적으로 맹신하는 것은 좋지 않다.&lt;/p&gt;</content><category term="linux"></category><category term="help"></category><category term="man"></category><category term="info"></category></entry><entry><title>HomeBrew Install And Uninstall</title><link href="https://imjang57.github.io/garret/homebrew-install-and-uninstall.html" rel="alternate"></link><published>2016-12-31T00:00:00+09:00</published><updated>2016-12-31T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2016-12-31:/garret/homebrew-install-and-uninstall.html</id><summary type="html">&lt;p&gt;HomeBrew 를 설치하고 삭제하는 방법&lt;/p&gt;</summary><content type="html">&lt;h1&gt;HomeBrew&lt;/h1&gt;
&lt;p&gt;HomeBrew 는 OS X (이제는 MacOS) 에서 패키지 관리를 자동으로 해주는 도구이다. 이 글을 쓸 때는 최신 버전이 1.1.5 이다.&lt;/p&gt;
&lt;p&gt;HomeBrew 를 설치하려면 "&lt;em&gt;Command Line Tools (CLT) for Xcode&lt;/em&gt;"가 필요하다. 귀찮으니 그냥 Xcode 설치하자. Xcode 에 다 포함되어 있다.&lt;/p&gt;
&lt;h2&gt;Install&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/Homebrew"&gt;Homebrew Github Project&lt;/a&gt;에 가면 &lt;a href="https://github.com/Homebrew/install"&gt;install repository&lt;/a&gt; 가 있다. 여기에 &lt;code&gt;install&lt;/code&gt; 과  &lt;code&gt;uninstall&lt;/code&gt; 이라는 스크립트를 제공해서 HomeBrew 를 설치하고 삭제할 수 있게 해준다.(Bash 는 아니고 Ruby 인 듯)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;install&lt;/code&gt; 스크립트로 설치하려면 아래와 같이 실행하면 된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;/usr/bin/ruby -e &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;위 스크립트로 설치하면 &lt;code&gt;/usr/local&lt;/code&gt; 에 HomeBrew 가 설치된다. 그런데 이 때 HomeBrew 를 위한 local git repository (&lt;code&gt;.git&lt;/code&gt; 디렉터리) 도 &lt;code&gt;/usr/local&lt;/code&gt; 에 생기고 다른 라이선스 관련 파일 등도 여기에 생성된다.. 이건 좀.. 그래서 uninstall 스크립트로 삭제하면 깨끗하게 지워지니까 일단 넘어가자. 이게 정 마음에 안들면 &lt;a href="https://github.com/Homebrew/brew/blob/master/docs/Installation.md#installation"&gt;installation guide&lt;/a&gt; 를 참고해서 직접 &lt;code&gt;git clone&lt;/code&gt; 해서 설치하자.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;install&lt;/code&gt; 스크립트로 실행하면 아래와 같이 설치되는 목록들을 보여준다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ /usr/bin/ruby -e &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="o"&gt;==&lt;/span&gt;&amp;gt; This script will install:
/usr/local/bin/brew
/usr/local/share/doc/homebrew
/usr/local/share/man/man1/brew.1
/usr/local/share/zsh/site-functions/_brew
/usr/local/etc/bash_completion.d/brew
/usr/local/Homebrew
&lt;span class="o"&gt;==&lt;/span&gt;&amp;gt; The following new directories will be created:
/usr/local/Cellar
/usr/local/Homebrew
/usr/local/Frameworks
/usr/local/include
/usr/local/opt
/usr/local/sbin
/usr/local/share/zsh
/usr/local/share/zsh/site-functions
/usr/local/var
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Uninstall&lt;/h2&gt;
&lt;p&gt;설치때와 마찬가지로 &lt;a href="https://github.com/Homebrew/install"&gt;install repository&lt;/a&gt;에서 제공하는 &lt;code&gt;uninstall&lt;/code&gt; 스크립트를 실행하면 된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ /usr/bin/ruby -e &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
Warning: This script will remove:
/Library/Caches/Homebrew/
/Users/youngho/Library/Logs/Homebrew/
/usr/local/.git/
/usr/local/.gitignore
/usr/local/.travis.yml
/usr/local/.yardopts
/usr/local/CODEOFCONDUCT.md
/usr/local/CONTRIBUTING.md
/usr/local/Cellar/
/usr/local/LICENSE.txt
/usr/local/Library/
/usr/local/README.md
/usr/local/SUPPORTERS.md
/usr/local/bin/brew
/usr/local/share/doc/homebrew/
/usr/local/share/man/man1/brew.1
Are you sure you want to uninstall Homebrew? &lt;span class="o"&gt;[&lt;/span&gt;y/N&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Usage&lt;/h2&gt;
&lt;p&gt;사용법은 매우 쉬우니 대충 적고 넘어간다.&lt;/p&gt;
&lt;p&gt;실행 명령어는 &lt;code&gt;brew&lt;/code&gt; 이다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ which brew
/usr/local/bin/brew
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;brew man page 에 더 자세한 내용이 많으니 참고하자.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ man &lt;span class="m"&gt;1&lt;/span&gt; brew
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;주로 사용하는 명령들의 목록:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;brew help&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;brew config&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;brew list [FORMULA...]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;brew info [FORMULA...]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;brew search &amp;lt;TEXT|/REGEX/&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;brew install FORMULA...&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;brew uninstall FORMULA...&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;brew upgrade [FORMULA...]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;HomeBrew 자체를 업그레이드하려면 &lt;code&gt;brew update&lt;/code&gt; 명령을 실행하면 되는데 지금은 잘 되는지 모르겠다. 0.9 버전일 사용할 때 &lt;em&gt;El Capitan&lt;/em&gt; 되면서 &lt;em&gt;System Integrity Protection&lt;/em&gt; 이라는 기능이 생겨서 제대로 안됐었는데, 맥 복구 모드(recovery mode)로 부팅해서 기능을 끄고 해서 해결했었던가 기억이 잘 안난다. 나중에 업데이트 할 일 생기면 다시 시도해보자.&lt;/p&gt;
&lt;h1&gt;Brew Cask&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;brew-cask&lt;/code&gt;는 &lt;code&gt;brew&lt;/code&gt;를 기반으로 확장한 프로그램이다. &lt;code&gt;brew&lt;/code&gt;처럼 패키지를 관리하는 것을 목표로 한다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;brew&lt;/code&gt;는 소스 코드를 직접 빌드하는 방법을 사용하지만 &lt;code&gt;brew-cask&lt;/code&gt;는 바이너리를 직접 받아서 설치하고 필요한 설정들을 자동으로 세팅한다. 이는 &lt;code&gt;brew-cask&lt;/code&gt;의 목적이 일반적으로 맥에서 애플리케이션을 설치할 때 사용하는 방법인 Drag-and-Drop 방법을 대체하기 위한 방법이기 때문이다. 때문에 &lt;code&gt;brew-cask&lt;/code&gt;는 소스 코드가 공개되지 않은 상용 프로그램들의 설치도 가능하다.&lt;/p&gt;
&lt;h2&gt;Install&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;brew-cask&lt;/code&gt; 설치는 아래와 같이 &lt;code&gt;brew&lt;/code&gt;를 실행하면 된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ brew tap caskroom/cask
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Usage&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;brew-cask&lt;/code&gt;로 맥의 터미널 앱인 iTerm2를 설치하려면 아래와 같이 실행하면 된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ brew cask install iterm2
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;brew-cask&lt;/code&gt;로 크롬도 설치되고 왠만한 유명한 프로그램은 다 설치 가능하다.&lt;/p&gt;
&lt;h1&gt;References&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://brew.sh"&gt;HomeBrew Web&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Homebrew/brew"&gt;HomeBrew Github&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="mac"></category><category term="homebrew"></category><category term="brew"></category><category term="brew cask"></category></entry><entry><title>특수 문자들의 영어 이름</title><link href="https://imjang57.github.io/garret/name-of-special-characters.html" rel="alternate"></link><published>2016-12-31T00:00:00+09:00</published><updated>2016-12-31T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2016-12-31:/garret/name-of-special-characters.html</id><summary type="html">&lt;p&gt;특수 문자들의 영어 이름&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Special characters name&lt;/h1&gt;
&lt;p&gt;개발자로 살면 다양한 특수문자들을 사용하게 되는데 구글링하거나 다른 사람과 대화할 때 이들의 이름이 기억안나 당황하는 경우가 많다. 그래서 이들의 영어 이름을 메모한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;#39; : single quotation mark, single quote
&amp;quot; : double quotation mark, double quote
* : asterisk, bullet
$ : dollar
- : dash, hyphen, minus sign
_ : underscore
% : percent sign
# : pound sign, number of, hashtag
&amp;amp; : ampersand
: : colon
; : semi-colon
| : vertical bar, pipe
\ : backslash
/ : slash, divide
&amp;lt; : less than sign
&amp;gt; : greater than sign
? : question mark
! : exclamation mark
() : parentheses, bracket
( : open parenthesss
) : close parenthesss
[] : square bracket
{} : curly bracket
+ : plus sign
= : equal sign
. : dot, period
, : comma
^ : caret, modifier letter, circumflex accent
` : grave accent, back tick, back quote
~ : tilde
@ : at symbol
&lt;/pre&gt;&lt;/div&gt;</content><category term="special characters"></category></entry><entry><title>Shell, Bash, Zsh</title><link href="https://imjang57.github.io/garret/shell-introduction-bash-zsh.html" rel="alternate"></link><published>2016-12-31T00:00:00+09:00</published><updated>2016-12-31T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2016-12-31:/garret/shell-introduction-bash-zsh.html</id><summary type="html">&lt;p&gt;내가 사용하는 Shell 에 대한 소개와 설치 과정&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Shell&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;Shell&lt;/em&gt; 은 &lt;em&gt;OS&lt;/em&gt; (&lt;em&gt;Operating System&lt;/em&gt;) 가 제공하는 여러 서비스들을 사용하기 위한 User interface 를 말한다. &lt;em&gt;CLI&lt;/em&gt; (&lt;em&gt;Command-line interface&lt;/em&gt;) 도 &lt;em&gt;Shell&lt;/em&gt; 이고 &lt;em&gt;GUI&lt;/em&gt; (&lt;em&gt;Graphical User Interface&lt;/em&gt;) 도 &lt;em&gt;Shell&lt;/em&gt; 이다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Linux&lt;/em&gt; 와 &lt;em&gt;OS X&lt;/em&gt; 에서는 보통 &lt;em&gt;Bash&lt;/em&gt; 가 Default shell 로 제공된다. 이 외에 &lt;em&gt;csh&lt;/em&gt;, &lt;em&gt;ksh&lt;/em&gt;, &lt;em&gt;zsh&lt;/em&gt; 등 많은 &lt;em&gt;Shell&lt;/em&gt; 들이 있다.&lt;/p&gt;
&lt;p&gt;요즘 가장 많이 사용되는 Linux 와 OS X  에서 Default shell 이고 수 많은 shell script 들이 &lt;em&gt;Bash&lt;/em&gt; 를 기반으로 작성되기 때문에 &lt;em&gt;Bash&lt;/em&gt; 는 필수이다. 여기에 나는 개인적으로 사용되는 환경에서는 &lt;em&gt;Zsh&lt;/em&gt; 을 추가로 설치해서 사용한다.&lt;/p&gt;
&lt;p&gt;이 &lt;em&gt;Shell&lt;/em&gt; 들은 마음에 드는 프롬프트를 만들고, 자주 사용하는 명령들을 alias 하고, 환경변수를 지정해서 사용하는 등 개인 취향에 따라 customizing 할 수 있다. 그래서 이 글에 내가 사용하는 Bash 설정과 Zsh 을 설치하고 설정하기 위한 과정들을 남긴다.&lt;/p&gt;
&lt;h2&gt;Shell 확인 및 변경&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Shell&lt;/em&gt; 확인은 다음과 같이 가능하다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;현재 내가 사용중인 Shell 확인 : &lt;code&gt;echo $SHELL&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;System 에서 사용가능한 Shell 목록 확인 : &lt;code&gt;cat /etc/shells&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;만약 내가 사용 중인 Shell 을 변경하고 싶다면 &lt;code&gt;chsh -s /path/to/other/shell&lt;/code&gt; 를 실행하면 된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ chsh -s /usr/local/bin/zsh
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Shell 의 실행 형태&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Shell&lt;/em&gt; 의 실행 형태는 &lt;em&gt;Interacctive shell&lt;/em&gt; 과 &lt;em&gt;Non-interactive shell&lt;/em&gt; 2가지가 있다. &lt;em&gt;Interactive shell&lt;/em&gt; 은 사용자가 명령을 입력하고 이를 실행하는 형태의 &lt;em&gt;Shell&lt;/em&gt; 이고 &lt;em&gt;Non-interactive shell&lt;/em&gt; 은 Script 를 실행할 때 사용되는 형태이다. 그리고 &lt;em&gt;Interactive shell&lt;/em&gt; 은 &lt;em&gt;Login shell&lt;/em&gt; 과 &lt;em&gt;Non-login Shell&lt;/em&gt; 이 있다. &lt;em&gt;Shell&lt;/em&gt; 은 실행 형태에 따라 사용자가 로그인할 때, 로그아웃할 때 각각 수행되는 스크립트들이 있다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Bash&lt;/em&gt; 의 경우를 예로 살펴보자. &lt;em&gt;Interactive Login Shell&lt;/em&gt; 일 경우 로그인할 때는 &lt;code&gt;/etc/profile&lt;/code&gt; 이 먼저 실행되고 &lt;code&gt;~/.bash_profile&lt;/code&gt;, &lt;code&gt;~/.bash_login&lt;/code&gt;, &lt;code&gt;~/.profile&lt;/code&gt; 들 중 처음 나오는 1개가 실행되다. 로그아웃할 때는 &lt;code&gt;~/.bash_logout&lt;/code&gt; 을 실행한다. &lt;em&gt;Interactive Non-login Shell&lt;/em&gt; 일 경우 &lt;code&gt;~/.bashrc&lt;/code&gt; 가 실행된다. &lt;em&gt;Non-interactive shell&lt;/em&gt; 은 $BASH_ENV (script 를 sh 로 실행한 경우는 $ENV) Environment variable 을 찾아서 이 변수에서 지정하는 파일 내의 명령들을 실행한다. 대부분의 경우 System-wide environment variables 는 &lt;code&gt;/etc/profile&lt;/code&gt; 에 설정하고, 각 사용자가 필요한 내용은 &lt;code&gt;~/.bash_profile&lt;/code&gt; 에서 설정한다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Zsh&lt;/em&gt; 은 &lt;code&gt;/etc/profile&lt;/code&gt; 대신 &lt;code&gt;/etc/zprofile&lt;/code&gt;, &lt;code&gt;~/.bash_profile&lt;/code&gt; 대신 &lt;code&gt;~/.zprofile&lt;/code&gt;, &lt;code&gt;~/.bashrc&lt;/code&gt; 대신 &lt;code&gt;~/.zshrc&lt;/code&gt; 를 사용한다.&lt;/p&gt;
&lt;h2&gt;Prompt&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Interactive Shell&lt;/em&gt; 이 실행된 경우 사용자의 입력을 기다리고 있음을 나타내기 위해 &lt;code&gt;&amp;lt;username@hostname&amp;gt;&lt;/code&gt; 과 같은 내용을 표시하는데 이를 Prompt 라고 한다. 이 프롬프트는 $PS1 환경 변수에 의해 설정된다. 만약 &lt;code&gt;export PS1="\$? &amp;gt; "&lt;/code&gt; 를 실행하면 프롬프트는 &lt;code&gt;0 &amp;gt;&lt;/code&gt; 와 같이 출력된다. 숫자 0은 이전 명령에 대한 리턴값이다.&lt;/p&gt;
&lt;p&gt;나는 bash prompt 를 다음과 같이 설정해서 사용한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# Colorize bash prompt using ANSI escape codes.&lt;/span&gt;
&lt;span class="c1"&gt;#     below print : username@hostname:cwd $&lt;/span&gt;
&lt;span class="nb"&gt;export&lt;/span&gt; &lt;span class="nv"&gt;PS1&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;\[\033[36m\]\u\[\033[m\]@\[\033[32m\]\h:\[\033[33;1m\]\w\[\033[m\]\$ &amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;alias&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;alias&lt;/code&gt; 명령을 사용하면 긴 명령이나 자주 사용하는 명령을 내가 원하는 명령으로 지정할 수 있다. &lt;code&gt;alias ll='ls -GFhil'&lt;/code&gt; 을 실행하면 이후부터 &lt;code&gt;ll&lt;/code&gt; 을 입력했을 때 &lt;code&gt;ls -GFhil&lt;/code&gt; 가 실행된다.&lt;/p&gt;
&lt;p&gt;내가 주로 사용하는 &lt;code&gt;alias&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;alias ll=&amp;#39;ls -GFhil&amp;#39;
alias lt=&amp;#39;ls -altr&amp;#39;
alias vi=&amp;#39;vim&amp;#39;
ssh=&amp;#39;ssh -o StrictHostKeyChecking=no -t&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Bash&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;Bash&lt;/em&gt; 는 최초의 &lt;em&gt;Shell&lt;/em&gt; 인 Bourne shell 을 다시 만든 &lt;em&gt;Shell&lt;/em&gt; 로 Bourne-again Shell 을 줄여서 &lt;em&gt;Bash&lt;/em&gt; 라고 한다. Linux 와 OS X 에는 Default shell 이며 다른 Unix 에서는 Csh 을 쓰는 듯 하다.&lt;/p&gt;
&lt;p&gt;요즘 대부분 개발자들이 사용하는 환경은 Linux, OS X, Windows 라서 &lt;em&gt;Bash&lt;/em&gt; 는 따로 설치해본 적이 없다. Linux 와 OS X 응 Default shell 이고 Windows 는 Bash 안쓰니까.. 그러니까 &lt;em&gt;Bash&lt;/em&gt; 에 대한 얘기는 넘어가자.&lt;/p&gt;
&lt;h1&gt;Zsh&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;Zsh&lt;/em&gt; 은 &lt;em&gt;Bash&lt;/em&gt; 의 확장판 같은 거라고 한다(그렇다고 함..). 사실 &lt;em&gt;Zsh&lt;/em&gt; 을 사용하는 이유는 &lt;em&gt;oh-my-zsh&lt;/em&gt; 때문이다. &lt;em&gt;Zsh&lt;/em&gt; 자체도 (자기들 주장에는) 좋다고 하는데 사실 나는 &lt;em&gt;Bash&lt;/em&gt; 와 비교해서 딱히 뛰어난 걸 잘 못느꼈다. 게다가 대부분의 Shell script 는 &lt;em&gt;Bash&lt;/em&gt; 를 기준으로 하기 때문에 &lt;em&gt;Zsh&lt;/em&gt; 이 아무리 &lt;em&gt;Bash&lt;/em&gt; 와 호환된다 해도 사용할 이유를 느끼지 못했었다. &lt;em&gt;oh-my-zsh&lt;/em&gt; 이 없었으면 아마 사용 안했을 듯 하다.&lt;/p&gt;
&lt;h2&gt;Zsh + oh-my-zsh 설치 및 설정&lt;/h2&gt;
&lt;p&gt;zsh 설치는 &lt;code&gt;yum install zsh&lt;/code&gt;, &lt;code&gt;apt-get install zsh&lt;/code&gt;, &lt;code&gt;brew install zsh&lt;/code&gt; 중 자기 OS 에 맞는 걸로 사용해서 설치하자. zsh 소스를 받아서 컴파일 하여 설치하는 것은 &lt;a href="http://www.zsh.org"&gt;Zsh Homepage&lt;/a&gt; 가서 알아보자.&lt;/p&gt;
&lt;p&gt;이제 oh-my-zsh 을 설치하자. &lt;a href="https://github.com/robbyrussell/oh-my-zsh"&gt;oh-my-zsh github&lt;/a&gt; 에 설명이 잘 나와있으니 자세한 내용은 가서 읽어보자. 나는 curl 을 이용해서 설치했다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ curl -L https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh &lt;span class="p"&gt;|&lt;/span&gt; sh
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;위 명령을 실행하면 git repository 가 ~/.oh-my-zsh 디렉터리에 clone 되고 설치 작업이 수행된다. 그리고 ~/.zshrc 파일이 자동으로 생성된다.&lt;/p&gt;
&lt;p&gt;설치는 이렇게 쉽게 끝났고, oh-my-zsh 은 다양한 theme plugin 을 지원하므로 내가 원하는 theme 를 적용해보자. 나는 &lt;a href="https://gist.github.com/agnoster/3712874"&gt;agnoster&lt;/a&gt; theme 가 마음에 들어서 아래와 같이 ~/.zshrc 파일을 변경하였다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ZSH_THEME=&amp;quot;agnoster&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;변경 후 &lt;code&gt;~/.zshrc&lt;/code&gt; 파일을 다시 적용하면 theme 가 적용된다. 만약 &lt;code&gt;ZSH_THEME="random"&lt;/code&gt; 으로 하면 여러 테마들이 로그인할 때마다 랜덤으로 적용된다.&lt;/p&gt;
&lt;p&gt;agnoster 테마는 Powerline font 를 필요로 한다. 이 폰트는 &lt;a href="https://github.com/powerline/fonts"&gt;Powerline github&lt;/a&gt; 에서 받을 수 있다. 이 저장소를 clone 한 후 &lt;code&gt;install.sh&lt;/code&gt; 파일을 실행하면 알아서 폰트를 설치해준다.&lt;/p&gt;
&lt;p&gt;OS X 의 경우 터미널 앱의 환경설정으로 가서 테마에서 서체를 새로 설치한 &lt;em&gt;Meslo LG M for Powerline&lt;/em&gt; 으로 바꿔주자.&lt;/p&gt;</content><category term="shell"></category><category term="bash"></category><category term="zsh"></category></entry><entry><title>System Integrity Protection (Rootless)</title><link href="https://imjang57.github.io/garret/system-integrity-protection-rootless.html" rel="alternate"></link><published>2016-12-31T00:00:00+09:00</published><updated>2016-12-31T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2016-12-31:/garret/system-integrity-protection-rootless.html</id><summary type="html">&lt;p&gt;Mac 의 Rootless 기능을 enable 및 disable 하기&lt;/p&gt;</summary><content type="html">&lt;h1&gt;System Integrity Protection (Rootless)&lt;/h1&gt;
&lt;p&gt;예전에 (2015년 인가..??) OS X 가 &lt;em&gt;El Capitan&lt;/em&gt; 으로 업데이트되면서 새롭게 생겨난 시스템 보안 관련 기능이다. &lt;em&gt;Rootless&lt;/em&gt; 라고도 하는 기능이다.&lt;/p&gt;
&lt;p&gt;보통 Linux/Unix 시스템은 root 사용자가 모든 파일을 읽고 쓸 수 있는데, 이 기능은 &lt;em&gt;Kernel&lt;/em&gt; 자체가 System file 들에 대한 쓰기 작업을 아예 막아 버리는 기능이다. 따라서, 이전에는 sudo 등으로 시스템 파일들을 수정할 수 있었지만 이제는 불가능하다.&lt;/p&gt;
&lt;p&gt;Rootless 에 의해 보호되는 파일 목록:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/System&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/bin&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/usr&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/sbin&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;sudo touch /bin/rootlesstest&lt;/code&gt; 를 실행하면 &lt;em&gt;Operation not permitted&lt;/em&gt; 메시지를 볼 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Rootless&lt;/em&gt; 에 의해 보호되는 파일 목록들은 &lt;code&gt;/System/Library/Sandbox/rootless.conf&lt;/code&gt; 에 모두 저장되어 있다.&lt;/p&gt;
&lt;p&gt;예전에 HomeBrew 때문에 Rootless 를 disable 한 적이 있었는데 이번에 또 필요해져서 다시 찾아봤다. 그리고 이왕 찾아본 김에 기록으로 남긴다.&lt;/p&gt;
&lt;h2&gt;Disable Rootless&lt;/h2&gt;
&lt;p&gt;현재 &lt;em&gt;Rootless&lt;/em&gt; 기능의 상태는 아래와 같이 확인할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ csrutil status
System Integrity Protection status: enabled.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;em&gt;Rootless&lt;/em&gt; 기능을 끄려면 &lt;em&gt;Recovery Mode&lt;/em&gt; 로 부팅해야 한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;맥 restart&lt;/li&gt;
&lt;li&gt;부팅시작되자마자 &lt;code&gt;option&lt;/code&gt; 키를 누른 후 &lt;code&gt;Recovery HD&lt;/code&gt; 를 선택하여 부팅한다. 아니면 &lt;code&gt;Command&lt;/code&gt; + &lt;code&gt;R&lt;/code&gt; 을 길게 누르면 파티션 선택 화면을 생략하고 바로 &lt;em&gt;Recovery Mode&lt;/em&gt; 로 부팅한다.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Recovery Mode&lt;/em&gt; 에서 상단 Menu bar 에서 유틸리티(Utilities)메뉴의 터미널(terminal)을 실행한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;csrutil disable [--without debug]&lt;/code&gt; 실행한다.&lt;/li&gt;
&lt;li&gt;restart 해서 일반 모드로 부팅한 후 필요한 작업 수행한다.&lt;/li&gt;
&lt;li&gt;필요한 작업 끝난 후 다시 재부팅하여 복구 모드로 들어온 뒤 &lt;code&gt;csrutil enable&lt;/code&gt; 을 실행한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;References&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.howtogeek.com/230424/how-to-disable-system-integrity-protection-on-a-mac-and-why-you-shouldnt/"&gt;How to Disable System Integrity Protection on a Mac (and Why You Shouldn’t)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="mac"></category><category term="os x"></category><category term="rootless"></category></entry><entry><title>TMUX Introduction</title><link href="https://imjang57.github.io/garret/tmux-introduction.html" rel="alternate"></link><published>2016-12-31T00:00:00+09:00</published><updated>2017-05-05T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2016-12-31:/garret/tmux-introduction.html</id><summary type="html">&lt;p&gt;TMUX 설치 및 사용법에 대한 간단한 소개&lt;/p&gt;</summary><content type="html">&lt;h1&gt;TMUX (Terminal Multiplexer)&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;tmux&lt;/em&gt; 는 terminal session 을 관리하기 위한 tool 이다. 여러 session 을 생성하여 서로 다른 workspace 를 만들 수 있고, session 을 유지시켜서 server 가 완전히 power off 되지않는다면 workspace 를 유지할 수도 있다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;tmux&lt;/em&gt; + &lt;em&gt;vim&lt;/em&gt; + &lt;em&gt;bash&lt;/em&gt; 는 매우 강력한 linux environment 를 제공한다.&lt;/p&gt;
&lt;h2&gt;설치&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;OS X: &lt;code&gt;brew install tmux&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Ubuntu: &lt;code&gt;apt-get install libevent-dev tmux&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;CentOS: &lt;code&gt;yum install libevent-dev tmux&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Linux 에서는 환경에 따라서 libncurses 모듈이 필요할 수 있다&lt;/p&gt;
&lt;h1&gt;tmux basic concepts&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;tmux&lt;/em&gt; 를 이용하기 전에 아래와 같은 개념에 대해 알고 가자.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;session&lt;/em&gt; : &lt;em&gt;tmux&lt;/em&gt; 실행 단위이다. 하나의 workspace 라고 생각할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;window&lt;/em&gt; : &lt;em&gt;session&lt;/em&gt; 내에 생성되는 하나의 terminal&lt;/li&gt;
&lt;li&gt;&lt;em&gt;pane&lt;/em&gt; : terminal 화면을 분할한 단위&lt;/li&gt;
&lt;li&gt;&lt;em&gt;status bar&lt;/em&gt; : 화면 아래부분에 표시되는 &lt;em&gt;session&lt;/em&gt; 의 status bar&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;99% 정도되는 대부분의 command 는 &lt;code&gt;ctrl + b&lt;/code&gt; 를 누른다음 이어서 command key 를 입력하여 실행된다. 예를 들어 command mode 로 직접 명령어를 입력하고 싶을 때는 &lt;code&gt;ctrl + b, :&lt;/code&gt; 와 같이 키를 입력한다. 정확하게는 &lt;code&gt;ctrl + b&lt;/code&gt; 를 누른 후 5초 내에 &lt;code&gt;:&lt;/code&gt; 를 입력한다. 5초 내에 command key 를 입력하면 된다.&lt;/p&gt;
&lt;h2&gt;Session&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;tmux&lt;/em&gt; 를 실행하면 &lt;em&gt;session&lt;/em&gt; 이라는 것이 생성된다. &lt;em&gt;session&lt;/em&gt; 은 실제 작업이 이루어지는 workspace 이며, &lt;em&gt;tmux&lt;/em&gt; 는 이 &lt;em&gt;session&lt;/em&gt; 을 관리하는 tool 이다.&lt;/p&gt;
&lt;h3&gt;create, rename, exit session&lt;/h3&gt;
&lt;p&gt;새로운 session 을 생성:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ tmux
$ tmux new-session -s &amp;lt;session name&amp;gt;
$ tmux new -s &amp;lt;session name&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;session name 을 직접 정하지 않았을 경우 숫자가 기본 session name 이 된다. 변경하고 싶으면 아래와 같은 command 를 입력한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ tmux rename-session -t &amp;lt;target session&amp;gt; &amp;lt;new session name&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;위의 명령에서 &lt;code&gt;tmux&lt;/code&gt; 를 제외한 부분(&lt;code&gt;rename-session&lt;/code&gt; 부터)을 &lt;em&gt;session&lt;/em&gt; 내에서 command mode(&lt;code&gt;ctrl + b, :&lt;/code&gt;) 에서 사용해도 된다.
또는 session 내에서 &lt;code&gt;ctrl + b, $&lt;/code&gt; 를 입력한다. 그러면 status bar 가 아래처럼 나타난다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(rename-session) 0
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;기존의 session name 인 0 을 삭제하고 새로운 session name 을 입력한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(rename-session) testsession
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;생성된 session 을 종료하고 싶으면 session 내에서 &lt;code&gt;exit&lt;/code&gt; 를 실행한다. 또는 &lt;code&gt;ctrl + d&lt;/code&gt; 를 입력한다.&lt;/p&gt;
&lt;p&gt;생성되어 있는 session 을 없애려면 다음을 실행한다:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ tmux kill-session -t &amp;lt;session name&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;attach and detach session&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;session&lt;/em&gt; 을 실행한 후 이를 유지하고 &lt;em&gt;session&lt;/em&gt; 밖으로 나갈 수도 있다. 서버만 내려가지 않는다면 이 &lt;em&gt;session&lt;/em&gt; 을 계속 유지시킬 수 있다. 이렇게 동작하는 것을 &lt;em&gt;session&lt;/em&gt; 을 detach 한다고 하는데 command mode 에서 &lt;code&gt;detach&lt;/code&gt; 를 입력하여 실행할 수 있다. 또는 &lt;code&gt;ctrl + b, d&lt;/code&gt; 를 입력해도 된다.&lt;/p&gt;
&lt;p&gt;이미 생성된 session 의 목록을 확인하려면 아래 명령을 실행한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ tmux list-sessions
testsession: &lt;span class="m"&gt;1&lt;/span&gt; windows &lt;span class="o"&gt;(&lt;/span&gt;created Thu Dec &lt;span class="m"&gt;22&lt;/span&gt; 09:31:45 2016&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;224x41&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;특정 session 에 다시 접속하려면 아래 명령을 실행한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ tmux attach-session -t testsession
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;위 명령을 아래 처럼 짧게 사용할 수도 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ tmux attach -t testsession
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Window&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;window&lt;/em&gt; 는 &lt;em&gt;session&lt;/em&gt; 내에서 나누어지는 공간이다. 일반적으로 인터넷 브라우저나 다른 어플리케이션에서 볼 수 있는 탭과 같은 것이다. &lt;em&gt;session&lt;/em&gt; 이라는 workspace 에 여러 &lt;em&gt;window&lt;/em&gt; 를 생성하여 한번에 여러가지 일들을 동시에 할 수 있게 된다.&lt;/p&gt;
&lt;h3&gt;create, rename, close window&lt;/h3&gt;
&lt;p&gt;최초에 &lt;em&gt;session&lt;/em&gt; 이 생성되면 무조건 1 개의 &lt;em&gt;window&lt;/em&gt; 가 생성된다. 최대 10개까지 생성할 수 있다. 화면 아래에 있는 status bar 에서 현재 &lt;em&gt;window&lt;/em&gt; 는 &lt;code&gt;*&lt;/code&gt; 가 window name 옆에 표시된다.&lt;/p&gt;
&lt;p&gt;현재 &lt;em&gt;session&lt;/em&gt; 에서 새로운 &lt;em&gt;window&lt;/em&gt; 를 생성하려면 &lt;code&gt;ctrl + b, c&lt;/code&gt; 를 입력한다. &lt;em&gt;tmux&lt;/em&gt; 로 새로운 &lt;em&gt;session&lt;/em&gt; 을 생성하면서 동시에 &lt;em&gt;session&lt;/em&gt; 과 &lt;em&gt;window&lt;/em&gt; 의 이름을 지정하려면 &lt;code&gt;tmux new-session -s testsession -n testwindow&lt;/code&gt; 명령으로 &lt;em&gt;tmux&lt;/em&gt; 를 실행하면 된다:&lt;/p&gt;
&lt;p&gt;현재 활성화된(&lt;code&gt;*&lt;/code&gt; 로 표시된) &lt;em&gt;window&lt;/em&gt; 의 name 을 변경하려면 &lt;code&gt;ctrl + b, ,&lt;/code&gt; 을 입력한다.&lt;/p&gt;
&lt;p&gt;현재 활성화된 &lt;em&gt;window&lt;/em&gt; 를 삭제하려면 &lt;code&gt;ctrl + b, &amp;amp;&lt;/code&gt; 를 입력하거나 &lt;code&gt;ctrl + d&lt;/code&gt; 를 입력한다.&lt;/p&gt;
&lt;h3&gt;Move to window&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;window&lt;/em&gt; 사이를 이동하려면 &lt;code&gt;ctrl + b, &amp;lt;window number: 0–9&amp;gt;&lt;/code&gt; 를 입력한다. 또는 &lt;code&gt;ctrl + b, n&lt;/code&gt; 으로 다음 &lt;em&gt;window&lt;/em&gt; 로, &lt;code&gt;ctrl + b, p&lt;/code&gt; 로 이전 &lt;em&gt;window&lt;/em&gt; 로 이동할 수 있다. 바로 직전에 작업하고 있던 &lt;em&gt;window&lt;/em&gt; 로 가려면 &lt;code&gt;ctrl + b, l&lt;/code&gt; 을 사용한다. l 의 의미는 last-window 이다.&lt;/p&gt;
&lt;p&gt;또 다른 &lt;em&gt;window&lt;/em&gt; 를 이동하는 방법은 &lt;code&gt;ctrl + b, w&lt;/code&gt; 를 사용하는 방법이다. 이 키를 입력하면 화면에 현재 &lt;em&gt;session&lt;/em&gt; 내에 열려 있는 &lt;em&gt;window&lt;/em&gt; 들이 list-up 된다. 원하는 &lt;em&gt;window&lt;/em&gt; 를 선택하여 바로 이동할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ctrl + b, f&lt;/code&gt; 를 이용하면 검색을 이용하여 &lt;em&gt;window&lt;/em&gt; 를 이동할 수 있다. 검색 결과가 복수이면 해당 &lt;em&gt;window&lt;/em&gt; 들이 list-up 된다. 원하는 &lt;em&gt;window&lt;/em&gt; 를 선택해서 이동할 수 있다.&lt;/p&gt;
&lt;h3&gt;Exit window&lt;/h3&gt;
&lt;p&gt;현재 &lt;em&gt;window&lt;/em&gt; 를 종료하려면 terminal 에서 &lt;code&gt;exit&lt;/code&gt; command 를 실행한다. 또는 &lt;code&gt;ctrl + d&lt;/code&gt; 를 입력한다. 모든 &lt;em&gt;window&lt;/em&gt; 가 종료되면 &lt;em&gt;session&lt;/em&gt; 도 종료된다.&lt;/p&gt;
&lt;h2&gt;Pane&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;pane&lt;/em&gt; 은 &lt;em&gt;windows&lt;/em&gt; 를 구성하는 화면들이다. &lt;em&gt;windows&lt;/em&gt; 는 1개 또는 여러 개의 pane 들로 구성될 수 있다. 때문에 2개의 &lt;em&gt;pane&lt;/em&gt; 을 만들어서 &lt;em&gt;window&lt;/em&gt; 를 좌우로 나누어 사용할 수도 있다.&lt;/p&gt;
&lt;h3&gt;Split&lt;/h3&gt;
&lt;p&gt;좌우로 window 분할(Split vertical)하려면 &lt;code&gt;ctrl + b, %&lt;/code&gt; 를 입력한다. 또는 command mode 로 &lt;code&gt;split-window -h&lt;/code&gt; 를 입력한다.&lt;/p&gt;
&lt;p&gt;상하로 window 분할(Split horizontal)하려면 &lt;code&gt;ctrl + b, "&lt;/code&gt; 를 입력한다. 또는 command mode 로 &lt;code&gt;split-window -v&lt;/code&gt; 를 입력한다.&lt;/p&gt;
&lt;h3&gt;Move to pane&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ctrl + b, q&lt;/code&gt; 를 입력하면 각 &lt;em&gt;pane&lt;/em&gt; 에 숫자가 잠시 표시된다. 이 때 원하는 pane 의 숫자를 입력하면 해당 &lt;em&gt;pane&lt;/em&gt; 으로 이동한다. 2초 간의 timeout 내에 입력해야 한다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ctrl + b, o&lt;/code&gt; 를 입력하면 정해진 순서에 따라 현재 &lt;em&gt;window&lt;/em&gt; 에 생성된 &lt;em&gt;pane&lt;/em&gt; 들을 차례대로 이동한다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ctrl + b, 방향키(Arrow key)&lt;/code&gt; 를 입력하면 인접한 방향의 &lt;em&gt;pane&lt;/em&gt; 으로 이동한다.&lt;/p&gt;
&lt;h3&gt;Exit pane&lt;/h3&gt;
&lt;p&gt;현재 &lt;em&gt;pane&lt;/em&gt; 을 종료시키려면 terminal 에서 &lt;code&gt;exit&lt;/code&gt; command 를 실행한다. 또는 &lt;code&gt;ctrl + d&lt;/code&gt; 를 입력한다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ctrl + b, x&lt;/code&gt; 를 입력하면 status bar 에 y/n 을 묻는 prompt 가 표시된다. y 를 선택하면 종료된다.&lt;/p&gt;
&lt;p&gt;모든 &lt;em&gt;pane&lt;/em&gt; 들이 종료되면 &lt;em&gt;window&lt;/em&gt; 도 종료된다.&lt;/p&gt;
&lt;h3&gt;Resizing pane&lt;/h3&gt;
&lt;p&gt;command mode 에서 명령을 입력하며 &lt;em&gt;pane&lt;/em&gt; 의 size 를 조절할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;왼쪽으로 10 줄이기 : &lt;code&gt;resize-pane -L 10&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;오른쪽으로 10 늘리기 : &lt;code&gt;resize-pane -R 10&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;아래쪽으로 10 늘리기 : &lt;code&gt;resize-pane -D 10&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;위쪽으로 10 늘리기 : &lt;code&gt;resize-pane -U 10&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Configuration file&lt;/h1&gt;
&lt;p&gt;tmux configuration file 은 &lt;code&gt;~/.tmux.conf&lt;/code&gt; 이다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;setw -g mode-keys vi
set -g status-keys vi

# 0 is too far from `.
set -g base-index 1

# To change prefix
set -g prefix C-a
unbind-key C-b
bind-key C-a send-prefix

bind-key v split-window -h
bind-key s split-window -v

bind-key J resize-pane -D 5
bind-key K resize-pane -U 5
bind-key H resize-pane -L 5
bind-key L resize-pane -R 5

bind-key M-j resize-pane -D
bind-key M-k resize-pane -U
bind-key M-h resize-pane -L
bind-key M-l resize-pane -R

# Vim style pane selection
bind h select-pane -L
bind j select-pane -D 
bind k select-pane -U
bind l select-pane -R

# Use Alt-vim keys without prefix key to switch panes
bind -n M-h select-pane -L
bind -n M-j select-pane -D 
bind -n M-k select-pane -U
bind -n M-l select-pane -R

# Use Alt-arrow keys without prefix key to switch panes
bind -n M-Left select-pane -L
bind -n M-Right select-pane -R
bind -n M-Up select-pane -U
bind -n M-Down select-pane -D

# Shift arrow to switch windows
bind -n S-Left  previous-window
bind -n S-Right next-window

# Reload tmux config
bind r source-file ~/.tmux.conf

# THEME
set -g status-bg black
set -g status-fg white
set -g window-status-current-bg white
set -g window-status-current-fg black
set -g window-status-current-attr bold
set -g status-interval 60
set -g status-left-length 30
set -g status-left &amp;#39;#[fg=green](#S) #(whoami)&amp;#39;
set -g status-right &amp;#39;#[fg=yellow]#(cut -d &amp;quot; &amp;quot; -f 1-3 /proc/loadavg)#[default] #[fg=white]%H:%M#[default]&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Key binding&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;ctrl + b + ?&lt;/code&gt; 을 입력하면 현재의 key binding 리스트를 볼 수 있다.&lt;/p&gt;
&lt;p&gt;사용자가 원하면 &lt;code&gt;~/.tmux.conf&lt;/code&gt; 파일에 key binding 를 설정할 수 있다. 자세한 내용은 tmux manpage 를 참고하자.&lt;/p&gt;
&lt;h1&gt;Copy mode&lt;/h1&gt;
&lt;p&gt;tmux 를 실행하고 있는 환경에서는 scroll bar 가 없다. 이때 &lt;em&gt;Copy mode&lt;/em&gt; 를 사용하면 이전 출력들을 볼 수 있다. 또한 &lt;em&gt;session&lt;/em&gt; 안에서 원하는 text 를 copy / paste 할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ctrl + b, [&lt;/code&gt; 를 입력하면 &lt;em&gt;Copy mode&lt;/em&gt; 로 진입한다. &lt;em&gt;pane&lt;/em&gt; 의 오른쪽 상단에 buffer 에 저장된 총 line 수가 출력된다. &lt;em&gt;Copy mode&lt;/em&gt; 를 종료하고 싶으면 &lt;code&gt;Enter&lt;/code&gt; 를 입력하거나 &lt;code&gt;q&lt;/code&gt; 를 입력한다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Copy mode&lt;/em&gt; 에서 이동은 &lt;code&gt;방향키(Arrow key)&lt;/code&gt;, &lt;code&gt;PageUp&lt;/code&gt;, &lt;code&gt;PageDown&lt;/code&gt; 키들을 사용한다. 만약 vi editor 의 방식으로 이동하고 싶으면 &lt;code&gt;~/.tmux.conf&lt;/code&gt; 파일에 &lt;code&gt;setw -g mode-keys vi&lt;/code&gt; 를 추가한다. 이 설정을 하면 &lt;code&gt;h&lt;/code&gt;, &lt;code&gt;j&lt;/code&gt;, &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;l&lt;/code&gt;, &lt;code&gt;G&lt;/code&gt;, &lt;code&gt;g&lt;/code&gt;, &lt;code&gt;ctrl + f&lt;/code&gt;, &lt;code&gt;ctrl + b&lt;/code&gt; 등 vi editor 에서 cursor 이동에 사용되는 key 들을 사용할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Copy mode&lt;/em&gt; 에서 검색은 &lt;code&gt;?&lt;/code&gt; 와 &lt;code&gt;/&lt;/code&gt; 를 사용한다. &lt;code&gt;?&lt;/code&gt; 또는 &lt;code&gt;/&lt;/code&gt; 를 입력하면 &lt;em&gt;pane&lt;/em&gt; 왼쪽 아래부분에 &lt;code&gt;Search Up:&lt;/code&gt; 이라고 표시된다. 여기에 검색어를 입력한다. &lt;code&gt;?&lt;/code&gt; 를 입력하면 위로 검색, &lt;code&gt;/&lt;/code&gt; 를 입력하면 아래로 검색한다. 다음, 이전 검색은 &lt;code&gt;N&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt; 을 입력한다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Copy mode&lt;/em&gt; 에서 &lt;code&gt;SPACEBAR&lt;/code&gt; 키를 입력하면 &lt;em&gt;Visual mode&lt;/em&gt; 가 되며, Text 를 선택할 수 있게 된다. 선택한 Text 를 복사하고 싶으면 &lt;code&gt;Enter&lt;/code&gt; 키를 입력한다. &lt;em&gt;Copy mode&lt;/em&gt; 에서는 quit 의 의미이지만 &lt;em&gt;Visual mode&lt;/em&gt; 에서는 복사와 함꼐 quit 를 수행한다. 복사한 Text 를 붙여넣고 싶다면 &lt;code&gt;ctrl + b, ]&lt;/code&gt; 를 입력한다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ctrl + b, :&lt;/code&gt; 를 입력하여 command mode 를 실행한 후 &lt;code&gt;list-buffers&lt;/code&gt; 를 실행하면 현재 저장된 모든 buffer 들을 볼 수 있다. &lt;code&gt;choose-buffer&lt;/code&gt; 를 입력하면 모든 buffer 들의 리스트가 출력되고 원하는 buffer 를 선택할 수 있다. &lt;code&gt;show-buffer&lt;/code&gt; 를 입력하면 0번째 buffer 의 내용을 보여준다. 참고로 &lt;code&gt;ctrl + b, ]&lt;/code&gt; 는 무조건 0번째 buffer 를 붙여넣기 한다.&lt;/p&gt;
&lt;h1&gt;Start with script&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;session&lt;/em&gt; 을 만들고, 화면을 분할하고, 특정 directory 를 생성하고, 패키지를 설치하고, 기타 필요한 작업들을 script 로 작성하여 &lt;em&gt;session&lt;/em&gt; 을 생성할 때 한꺼번에 수행되도록 할 수 있다.&lt;/p&gt;
&lt;p&gt;tmux initilizing automation script example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ cat start_with_tmux.sh
&lt;span class="c1"&gt;#!/bin/bash&lt;/span&gt;
&lt;span class="nv"&gt;SESSION&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;tmuxtest
&lt;span class="nv"&gt;PROJECT_HOME&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;~/Projects&amp;quot;&lt;/span&gt;
&lt;span class="nv"&gt;PROJECT_NAME&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;1&lt;/span&gt;&lt;span class="k"&gt;:-&lt;/span&gt;&lt;span class="nv"&gt;node&lt;/span&gt;&lt;span class="p"&gt;-project&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;
&lt;span class="nv"&gt;TMUX&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;tmux&amp;quot;&lt;/span&gt;
&lt;span class="c1"&gt;# Create new session&lt;/span&gt;
&lt;span class="nv"&gt;$TMUX&lt;/span&gt; new-session -d -s &lt;span class="nv"&gt;$SESSION&lt;/span&gt;
&lt;span class="c1"&gt;# Create new windows&lt;/span&gt;
&lt;span class="nv"&gt;$TMUX&lt;/span&gt; new-window -t &lt;span class="nv"&gt;$SESSION&lt;/span&gt;:1 -n withindex
&lt;span class="nv"&gt;$TMUX&lt;/span&gt; new-window -t &lt;span class="nv"&gt;$SESSION&lt;/span&gt; -n withoutindex
&lt;span class="c1"&gt;# Select window&lt;/span&gt;
&lt;span class="nv"&gt;$TMUX&lt;/span&gt; &lt;span class="k"&gt;select&lt;/span&gt;-window -t withindex
&lt;span class="c1"&gt;# Split window&lt;/span&gt;
&lt;span class="nv"&gt;$TMUX&lt;/span&gt; split-window -h
&lt;span class="c1"&gt;# Select pane and run commands&lt;/span&gt;
&lt;span class="nv"&gt;$TMUX&lt;/span&gt; &lt;span class="k"&gt;select&lt;/span&gt;-pane -t 0
&lt;span class="nv"&gt;$TMUX&lt;/span&gt; send-keys &lt;span class="s2"&gt;&amp;quot;mkdir -p &lt;/span&gt;&lt;span class="nv"&gt;$PROJECT_HOME&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; Enter
&lt;span class="nv"&gt;$TMUX&lt;/span&gt; send-keys &lt;span class="s2"&gt;&amp;quot;cd &lt;/span&gt;&lt;span class="nv"&gt;$PROJECT_HOME&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; Enter
&lt;span class="nv"&gt;$TMUX&lt;/span&gt; send-keys &lt;span class="s2"&gt;&amp;quot;echo &amp;#39;date&amp;#39; &amp;gt; test.txt&amp;quot;&lt;/span&gt; Enter
&lt;span class="nv"&gt;$TMUX&lt;/span&gt; split-window -v
&lt;span class="c1"&gt;# C-m means Carriage Return (one of control characters)&lt;/span&gt;
&lt;span class="nv"&gt;$TMUX&lt;/span&gt; send-keys &lt;span class="s2"&gt;&amp;quot;cd &lt;/span&gt;&lt;span class="nv"&gt;$PROJECT_HOME&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; Enter
&lt;span class="nv"&gt;$TMUX&lt;/span&gt; send-keys &lt;span class="s2"&gt;&amp;quot;tail -f test.txt&amp;quot;&lt;/span&gt; C-m
&lt;span class="c1"&gt;# Select pane and run commands&lt;/span&gt;
&lt;span class="nv"&gt;$TMUX&lt;/span&gt; &lt;span class="k"&gt;select&lt;/span&gt;-pane -t 2
&lt;span class="nv"&gt;$TMUX&lt;/span&gt; send-keys &lt;span class="s2"&gt;&amp;quot;ls -ail&amp;quot;&lt;/span&gt; Enter
References
http://tmux.github.io/
https://github.com/tmux/tmux
http://haruair.com/blog/2124
http://nodeqa.com/nodejs_ref/99
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Summary&lt;/h1&gt;
&lt;h2&gt;Sessions&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;start new session : &lt;code&gt;tmux&lt;/code&gt;, &lt;code&gt;tmux new-session -s testsession&lt;/code&gt;, &lt;code&gt;tmux new -s testsession&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;attach session : &lt;code&gt;tmux attach-session -t testsession&lt;/code&gt;, &lt;code&gt;tmux attach -t testsession&lt;/code&gt;, &lt;code&gt;tmux a -t testsession&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;detach current session : &lt;code&gt;ctrl + b, d&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;list sessions : &lt;code&gt;tmux list-sessions&lt;/code&gt;, &lt;code&gt;tmux ls&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;kill session : &lt;code&gt;tmux kill-session -t testsession&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Run tmux commands in tmux session&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;open tmux command prompt : &lt;code&gt;ctrl + b, :&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;list binding keys (shortcuts) : &lt;code&gt;ctrl + b, ?&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Windows&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;create window : &lt;code&gt;ctrl + b, c&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;list windows : &lt;code&gt;ctrl + b, w&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;next window : &lt;code&gt;ctrl + b, n&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;previous window : &lt;code&gt;ctrl + b, p&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;kill window : &lt;code&gt;ctrl + b, &amp;amp;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Panes&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;vertical split : &lt;code&gt;ctrl + b, %&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;horizontal split : &lt;code&gt;ctrl + b, "&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;swap panes : &lt;code&gt;ctrl + b, o&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;show pan numbers : &lt;code&gt;ctrl + b, o&lt;/code&gt; (when the numbers show up, type the key to goto that pane)&lt;/li&gt;
&lt;li&gt;kill pane : &lt;code&gt;ctrl + b, x&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;move the current pane left : &lt;code&gt;ctrl + b, {&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;move the current pane right : &lt;code&gt;ctrl + b, }&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;toggle pane zoom : &lt;code&gt;ctrl + b, z&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Resizing Panes&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Resizes the current pane down : &lt;code&gt;ctrl + b, :&lt;/code&gt; and &lt;code&gt;resize-pane -D&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Resizes the current pane up : &lt;code&gt;ctrl + b, :&lt;/code&gt; and &lt;code&gt;resize-pane -U&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Resizes the current pane left : &lt;code&gt;ctrl + b, :&lt;/code&gt; and &lt;code&gt;resize-pane -L&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Resizes the current pane right : &lt;code&gt;ctrl + b, :&lt;/code&gt; and &lt;code&gt;resize-pane -R&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Resizes the current pane down by 20 cells : &lt;code&gt;ctrl + b, :&lt;/code&gt; and &lt;code&gt;resize-pane -D 20&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Resizes the current pane up by 20 cells : &lt;code&gt;ctrl + b, :&lt;/code&gt; and &lt;code&gt;resize-pane -U 20&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Resizes the current pane left by 20 cells : &lt;code&gt;ctrl + b, :&lt;/code&gt; and &lt;code&gt;resize-pane -L 20&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Resizes the current pane right by 20 cells : &lt;code&gt;ctrl + b, :&lt;/code&gt; and &lt;code&gt;resize-pane -R 20&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Copy mode&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Copy mode on : &lt;code&gt;ctrl + b, [&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;References&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://tmux.github.io"&gt;tmux web&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/tmux/tmux"&gt;tmux github&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="tmux"></category></entry><entry><title>자바에서 % 출력하기</title><link href="https://imjang57.github.io/garret/print-percent-sign-in-java.html" rel="alternate"></link><published>2016-12-30T00:00:00+09:00</published><updated>2016-12-30T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2016-12-30:/garret/print-percent-sign-in-java.html</id><summary type="html">&lt;p&gt;자바에서 % 문자 출력하기&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Java String 에서 % 문자 출력하기&lt;/h1&gt;
&lt;p&gt;오늘 개발하다가 &lt;code&gt;%&lt;/code&gt; 문자가 들어가는 문자열을 처리할 일이 있었다. 처음에 아무 생각없이 아래처럼 작성했다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;str1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;test&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;str2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;format&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;string is \&amp;quot;%%s%\&amp;quot;.&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;str1&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;원하는 결과는 아래와 같이 나오는 것이었다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;string is &amp;quot;%test%&amp;quot;.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;당연히 String.format 에서 에러가 발생했다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Exception in thread &amp;quot;main&amp;quot; java.util.UnknownFormatConversionException: Conversion = &amp;#39;&amp;quot;&amp;#39;
 at java.util.Formatter.checkText(Formatter.java:2579)
 at java.util.Formatter.parse(Formatter.java:2565)
 at java.util.Formatter.format(Formatter.java:2501)
 at java.util.Formatter.format(Formatter.java:2455)
 at java.lang.String.format(String.java:2940)
 at StringTest.main(StringTest.java:7)
 at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
 at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
 at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
 at java.lang.reflect.Method.invoke(Method.java:497)
 at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;\&lt;/code&gt; 는 특정 &lt;em&gt;espace character&lt;/em&gt; 로 이미 약속된 문자들과 사용돼야 한다. 그런데 그 문자들 중에 &lt;code&gt;%&lt;/code&gt; 는 없다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;%&lt;/code&gt; 는 &lt;em&gt;Formatting&lt;/em&gt; 을 위한 문자로, &lt;code&gt;String.format("%d", 123);&lt;/code&gt; 과 같이 사용된다. 이 때 &lt;code&gt;%&lt;/code&gt; 자체를 출력하기 위해서도 &lt;code&gt;%&lt;/code&gt; 를 prefix 로 사용하여 &lt;code&gt;%%&lt;/code&gt; 와 같이 처리해야 한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;str1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;test&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;str2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;format&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;string is %%%s%%.&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;str1&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;%&lt;/code&gt; 는 그냥 문자가 아니라 포맷을 지정하기 위한 포맷 지시자 (format specifier 또는 format string) 역할을 하는 특수한 문자이기 때문이다.&lt;/p&gt;
&lt;p&gt;알고 있던 거였는데.. 역시 오래동안 안쓰면 머리에서 삭제되어 버린다. ㅠㅠ&lt;/p&gt;</content></entry><entry><title>Linux Directory Structure</title><link href="https://imjang57.github.io/garret/linux-directory-structure.html" rel="alternate"></link><published>2016-12-22T00:00:00+09:00</published><updated>2016-12-22T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2016-12-22:/garret/linux-directory-structure.html</id><summary type="html">&lt;p&gt;리눅스 디렉터리 구조&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Linux directory&lt;/h1&gt;
&lt;p&gt;수많은 배포판을 가진 리눅스는 배포판마다 각각의 특징을 가지며 조금씩 다른 시스템 구조를 가지고 있다. 하지만 대부분의 대포판들은 리눅스 파일시스템 표준인 &lt;strong&gt;FSSTND(Filesystem Hierarchy Standard)&lt;/strong&gt; 스펙을 준수하고 있다. 우리가 익히 많이 들어 알고 있는 대부분의 배포판들은 이 표준을 지키며 개발되었다. FSSTND 파일시스템 표준은 디렉토리의 용도에 대한 기준을 준비해 두고서 그 용도에 맞도록 사용하자는 리눅스 파일시스템 구성의 기준이 되는 표준안이라고 할 수 있다.&lt;/p&gt;
&lt;p&gt;FSSTND에 대한 자세한 설명은 다음 URL들을 참고하자.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;wikipedia: https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard&lt;/li&gt;
&lt;li&gt;official web site: https://wiki.linuxfoundation.org/lsb/fhs&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;여러 디렉터리의 용도가 정의되어 있지만 자주 사용되는 디렉터리들에 대해 설명하면 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/&lt;/code&gt; : 최상위 디렉토리. 루트디렉토리를 의미하고 리눅스 모든 디렉토리의 시작점이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/bin&lt;/code&gt; : 기본적인 명령어가 저장된 디렉토리. 리눅스 사용에 있어 가장 기본적인 명령어인 &lt;code&gt;mv&lt;/code&gt;, &lt;code&gt;cp&lt;/code&gt;, &lt;code&gt;df&lt;/code&gt;, &lt;code&gt;rm&lt;/code&gt; 등이 이 디렉토리에 존재한다. 그리고 이 디렉토리 안에 있는 명령어들은 &lt;code&gt;root&lt;/code&gt; 뿐만 아니라 일반 사용자들도 사용할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/boot&lt;/code&gt; : 리눅스 부트로더(boot loader)가 존재하는 디렉토리. 즉 GRUB과 같은 부트로더에 관한 파일들이 여기에 존재한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/dev&lt;/code&gt; : 시스템 디바이스(device) 파일을 저장하고 있는 디렉토리. 하드디스크 &lt;code&gt;/dev/sda&lt;/code&gt;, CDROM &lt;code&gt;/dev/cdrom&lt;/code&gt; 등과 같은 장치파일이 이곳에 존재한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/etc&lt;/code&gt; : 리눅스 시스템의 거의 모든 설정파일이 존재하는 디렉토리. &lt;code&gt;/etc/passwd&lt;/code&gt;, &lt;code&gt;/etc/group&lt;/code&gt; 등 거의 모든 시스템관련 설정파일이 이곳에 존재한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/home&lt;/code&gt; : 사용자 홈 디렉토리. 안에 각 사용자들의 디렉토리들이 모여있다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/lib&lt;/code&gt; : 커널모듈파일과 라이브러리파일 등이 존재하는 디렉토리&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/media&lt;/code&gt; : USB, CDROM 등과 같이 탈부착이 가능한 장치들의 마운트포인트로 사용되는 디렉토리&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/mnt&lt;/code&gt; : &lt;code&gt;/media&lt;/code&gt; 디렉토리와 비슷한 용도로 사용&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/proc&lt;/code&gt; : 가상파일시스템이라고 불리는 곳으로 현재 메모리에 존재하는 모든 작업들이 파일형태로 존재하는 디렉토리. 디스크상에 존재하는 것이 아니라 메모리상에 존재하기 때문에 가상파일시스템이라고 부른다. 이곳에 존재하는 파일 중에 커널의 옵션값을 변경할 수 있는 파라미터파일들이 있기 때문에 시스템 운용에 있어 매우 중요한 의미를 가진다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/root&lt;/code&gt; : 시스템 최고관리자의 홈 디렉토리&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/sbin&lt;/code&gt; : &lt;code&gt;/bin&lt;/code&gt;과는 달리 시스템 관리자들이 사용하는 리눅스 명령어들(&lt;code&gt;halt&lt;/code&gt;, &lt;code&gt;shutdown&lt;/code&gt; 등)이 모여있는 디렉토리&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/tmp&lt;/code&gt; : 시스템 모든 사용자들이 공동으로 사용하는 디렉토리. 일반 사용자 또는 각종 프로세서에서 사용되는 파일들이 생성되는 곳이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/usr&lt;/code&gt; : 시스템이 아닌 일반 사용자들이 주로 사용하는 디렉토리&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/usr/bin&lt;/code&gt; : 일반 사용자들이 사용 가능한 명령어 파일들이 존재하는 디렉토리&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/usr/include&lt;/code&gt; : C 프로그래밍에 필요한 헤더파일이 모여 있는 디렉토리&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/usr/lib&lt;/code&gt; : &lt;code&gt;/lib&lt;/code&gt;에 들어가지 않은 라이브러리들이 모여 있는 디렉토리&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/usr/sbin&lt;/code&gt; : &lt;code&gt;/bin&lt;/code&gt;에 제외된 명령어와 네트워크 관련 명령어들이 들어있는 디렉토리&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/usr/src&lt;/code&gt; : 프로그램 소스가 저장되는 곳&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/usr/local&lt;/code&gt; : mysql, apache, php 등과 같은 어플리케이션들을 소스로 컴파일설치할 때 사용되는 디렉토리&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/var&lt;/code&gt; : 시스템 사용중 임시로 생성되고 삭제되는 데이터를 저장하기 위한 디렉토리. 모든 시스템 로그파일은 &lt;code&gt;/var/log&lt;/code&gt;에 저장된다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/lost+found&lt;/code&gt; : 최상위 디렉토리인 &lt;code&gt;/&lt;/code&gt; 디렉토리에만 존재하는 것이 아니라 파일 시스템마다 존재할 수 있는 디렉토리. 이 디렉토리는 &lt;code&gt;fsck&lt;/code&gt; 또는 &lt;code&gt;e2fsck&lt;/code&gt; 등과 같은 파일 시스템 체크 및 복구유틸리티 실행후에 주로 생성되는 것으로 복구되지 앟은 채로 블록(block)만 존재하는 파일이 존재하는 곳.&lt;/li&gt;
&lt;/ul&gt;</content><category term="linux"></category><category term="directory"></category></entry><entry><title>Integer types header file (stdint.h)</title><link href="https://imjang57.github.io/garret/integer-types-header-file-stdint.html" rel="alternate"></link><published>2016-01-02T00:00:00+09:00</published><updated>2016-01-02T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2016-01-02:/garret/integer-types-header-file-stdint.html</id><summary type="html">&lt;p&gt;C 언어의 Integer data type 의 크기를 정의한 stdint.h 헤더파일&lt;/p&gt;</summary><content type="html">&lt;h1&gt;uintXX_t data types in stdint.h&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;_t&lt;/code&gt; 는 구조체에 붙이는 것이라기 보다는 user-defined type 에 붙이는 것이다. &lt;code&gt;uint8_t&lt;/code&gt;, &lt;code&gt;uint32_t&lt;/code&gt; 등은 &lt;code&gt;stdint.h&lt;/code&gt; 헤더파일에 정의되어 있으며 C99 표준에서 도입되었다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;stdint.h&lt;/code&gt; : This header defines a set of integral type aliases with specific width requirements, along with macros specifying their limits and macro functions to create values of these types.&lt;/p&gt;
&lt;p&gt;C 언어 표준에는 &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt; 등과 같은 Primitive data type 을 지원한다. 하지만 표준에서 이런 type 들이 몇 bytes 를 필요로 하는지 정확한 정의를 하지 않았다. 때문에 Machine (CPU) 의 종류에 따라 &lt;code&gt;int&lt;/code&gt; 나 &lt;code&gt;long&lt;/code&gt; 등의 크기가 달라지게 되었다. (대부분은 &lt;code&gt;char&lt;/code&gt; 1 byte, &lt;code&gt;short&lt;/code&gt; 2 bytes, &lt;code&gt;int&lt;/code&gt; 4 bytes 로 알고 가르치지만 대부분의 machine 에서 이렇게 사용할 뿐이지 다 똑같은 건 아니다. 표준은 &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt; 에 대해 &lt;code&gt;short&lt;/code&gt; 은 최소 &lt;code&gt;int&lt;/code&gt; 보다 같거나 작아야 한다고 정의되어 있으며, &lt;code&gt;long&lt;/code&gt; 은 &lt;code&gt;int&lt;/code&gt; 보다 같거나 커야 한다고 정의되어 있을 뿐이다.) 이는 C 언어로 작성된 프로그램의 호환성(Portability) 에 매우 큰 악영향을 미칠 수 있는 요소였다.&lt;/p&gt;
&lt;p&gt;이러한 machine 에 따른 호환성 문제를 해결하기 위해 C99 표준에서는 &lt;code&gt;int8_t&lt;/code&gt;, &lt;code&gt;uint8_t&lt;/code&gt;, &lt;code&gt;int16_t&lt;/code&gt;, &lt;code&gt;uint16_t&lt;/code&gt;, &lt;code&gt;int32_t&lt;/code&gt;, &lt;code&gt;uint32_t&lt;/code&gt;, &lt;code&gt;int64_t&lt;/code&gt;, &lt;code&gt;uint64_t&lt;/code&gt; 등을 도입하였다.&lt;/p&gt;
&lt;p&gt;C99 에서 도입된 &lt;code&gt;stdint.h&lt;/code&gt; 는 이전에 존재하던 &lt;code&gt;limits.h&lt;/code&gt; 와는 성격이 다르다. 기존의 &lt;code&gt;limits.h&lt;/code&gt; 가 machine-dependent data type 의 크기를 서술한 것이라면, &lt;code&gt;stdint.h&lt;/code&gt; 는 data type 의 size 를 명확하게 정의한다. &lt;code&gt;limits.h&lt;/code&gt; 는 기계마다 다르게 정의되는 각 data type 의 크기만 알려줄 뿐이며, 원하는 크기의 자료형을 선언하는데는 크게 도움이 되지 않는다. 반면 &lt;code&gt;stdint.h&lt;/code&gt; 는 기존의 &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt; 과 같은 자료형을 보다 명확하게 수치로 나타낸다.&lt;/p&gt;
&lt;p&gt;32 비트 기계에서 16 비트 크기를 가지는 정수 자료형을 명확하게 선언하고 싶다면, &lt;code&gt;int16_t&lt;/code&gt; 를 사용하고, 32 비트 정수 자료형이라면 &lt;code&gt;int32_t&lt;/code&gt; 를 사용하여 선언한다. 기본 자료형을 다시 재정의하는 것은 쓸데없이 혼란을 가중시킬거라 생각할지도 모르지만, 이런 식으로 보다 명확하게 자료형을 재정의하는 것은 훨씬 명확한 코드를 작성하는데 도움이 된다. 부동소수점 자료형을 제외한 정수 자료형들은 모두 이런 &lt;code&gt;intN_t&lt;/code&gt; 스타일로 정의할 수 있는데, &lt;code&gt;char&lt;/code&gt; 도 &lt;code&gt;int8_t&lt;/code&gt; 와 같이 선언할 수 있다. C 에서 &lt;code&gt;char&lt;/code&gt; 타입은 정수형으로도 간주될 수 있기 때문이다. 자료형의 크기를 명확하게 밝혀준다는 장점 외에도, &lt;code&gt;unsigned int&lt;/code&gt; 와 같은 긴 문장을 간단하게 &lt;code&gt;uint32_t&lt;/code&gt; 로 표현할 수 있다는 장점도 있다. 호환성을 염두에 둔 코드를 작성한다면, &lt;code&gt;stdint.h&lt;/code&gt; 는 매우 편리한 존재가 아닐 수 없다. C99 에서 새롭게 도입된 &lt;code&gt;stdint.h&lt;/code&gt; 는 C++ 에도 &lt;code&gt;cstdint&lt;/code&gt; 헤더 파일로 포함되어 있다.&lt;/p&gt;</content><category term="c programming language"></category><category term="stdint.h"></category></entry></feed>