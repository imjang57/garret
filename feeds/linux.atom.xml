<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>garret - linux</title><link href="https://imjang57.github.io/garret/" rel="alternate"></link><link href="https://imjang57.github.io/garret/feeds/linux.atom.xml" rel="self"></link><id>https://imjang57.github.io/garret/</id><updated>2017-05-08T00:00:00+09:00</updated><entry><title>Bash script 로 각 디렉터리들의 실제 사용량 조회하기</title><link href="https://imjang57.github.io/garret/check-disk-usage-of-directories-with-bash-script.html" rel="alternate"></link><published>2017-01-18T00:00:00+09:00</published><updated>2017-01-18T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-18:/garret/check-disk-usage-of-directories-with-bash-script.html</id><summary type="html">&lt;p&gt;Bash script 로 각 디렉터리들이 실제 사용하고 있는 디스크 크기를 알아보는 방법&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Linux 에서 각 디렉터리 별 디스크 사용량 확인하기&lt;/h1&gt;
&lt;p&gt;리눅스에서 각 디렉터리마다 디스크를 얼마나 사용하고 있는지 확인하기 위한 bash script 이다.&lt;/p&gt;
&lt;p&gt;스크립트:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# make newlines the only seperator (IFS : Internal Field Separator)&lt;/span&gt;
&lt;span class="nv"&gt;IFS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;$&amp;#39;\n&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; d in &lt;span class="k"&gt;$(&lt;/span&gt;ls -l &lt;span class="p"&gt;|&lt;/span&gt; grep &lt;span class="s1"&gt;&amp;#39;^d&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; awk &lt;span class="s1"&gt;&amp;#39;{ print substr($0, index($0, $9)) }&amp;#39;&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt; du -hs &lt;span class="nv"&gt;$d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;처음에 &lt;code&gt;IFS&lt;/code&gt; 를 지정해주지 않으면 디렉터리 이름에 공백이 들어간 경우 디렉터리 이름이 공백을 기준으로 split 되어 별도의 디렉터리처럼 동작하게 된다.&lt;/p&gt;
&lt;p&gt;나머지들은 워낙 기본적인 것들이니 간단하게 언급만 하면, 현재 디렉터리의 파일 목록을 조회하고, &lt;code&gt;grep&lt;/code&gt; 으로 디렉터리만 뽑아내고, &lt;code&gt;awk&lt;/code&gt; 로 파일 이름만 뽑아내고, &lt;code&gt;for&lt;/code&gt; statement 를 사용해서 각 디렉터리마다 &lt;code&gt;du&lt;/code&gt; 명령을 사용한다.&lt;/p&gt;</content><category term="bash"></category><category term="linux"></category><category term="du"></category><category term="disk"></category></entry><entry><title>SSH with key</title><link href="https://imjang57.github.io/garret/ssh-with-key.html" rel="alternate"></link><published>2017-01-02T00:00:00+09:00</published><updated>2017-01-02T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-02:/garret/ssh-with-key.html</id><summary type="html">&lt;p&gt;Key 로 SSH 로그인 하기 위한 과정&lt;/p&gt;</summary><content type="html">&lt;h1&gt;SSH with key file&lt;/h1&gt;
&lt;p&gt;SSH 를 사용할 때 비밀번호를 일일이 입력하기 귀찮을 때가 있다. 특히 개발용 서버에 수시로 접속할 때.. 이 때 key 파일을 이용한 로그인을 하면 비밀번호를 입력하는 번거로움을 피할 수 있다.&lt;/p&gt;
&lt;p&gt;SSH 에서 key 를 이용한 로그인을 위해 RSA asymmetric encryption (RSA 비대칭키 암호화) 방식을 이용할 수 있다. 이 방법은 아래와 같은 절차를 따라 동작한다. (물론 당연히 다른 암호화 방식의 Key 를 사용해도 된다.)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Public Key (공개키) 와 Private Key (비공개키) 를 생성&lt;/li&gt;
&lt;li&gt;Local Host (SSH Client) 에 Private Key 저장&lt;/li&gt;
&lt;li&gt;Remote Host (SSH Server) 에 Public Key 등록&lt;/li&gt;
&lt;li&gt;Local Host 가 Remote  Host 에 접속 요청을 하면서 Public Key 전달&lt;/li&gt;
&lt;li&gt;Remote Host 는 Public Key 를 받아서 등록된 Public Key 인지 검사한 후 승인 또는 비승인&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Key 생성&lt;/h2&gt;
&lt;p&gt;먼저 Public Key 와 Private Key 를 생성한다. 리눅스에서는 아래와 같은 명령을 실행하면 된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ ssh-keygen -t rsa
Generating public/private rsa key pair.
Enter file in which to save the key &lt;span class="o"&gt;(&lt;/span&gt;/home/axl/.ssh/id_rsa&lt;span class="o"&gt;)&lt;/span&gt;: &amp;lt;&lt;span class="k"&gt;return&lt;/span&gt;&amp;gt;
Enter passphrase &lt;span class="o"&gt;(&lt;/span&gt;empty &lt;span class="k"&gt;for&lt;/span&gt; no passphrase&lt;span class="o"&gt;)&lt;/span&gt;: &amp;lt;Type the passphrase&amp;gt;
Enter same passphrase again: &amp;lt;Type the passphrase&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;ssh-keygen&lt;/code&gt; 을 실행하면 key file 이 저장될 위치와 passphrase 를 차례대로 묻는다. 저장될 위치는 기본값으로 &lt;code&gt;$HOME/.ssh&lt;/code&gt; 이다. 특별히 변경할 일이 없다면 그대로 엔터를 입력하여 기본값으로 사용하자. passphrase 는 비공개키를 생성하는데 사용될 문자열로 이 문자열을 암호화하여 키를 생성한다. 자동 로그인을 원한다면 생략해야 한다.&lt;/p&gt;
&lt;p&gt;키가 정상적으로 생성되면 키가 생성된 곳에 아래와 같은 파일들을 볼 수 있다. 참고로 파일들은 SSH 를 사용할 때 보안에 매우 중요한 파일들이다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;drwx------  &lt;span class="m"&gt;2&lt;/span&gt; ubuntu ubuntu &lt;span class="m"&gt;4096&lt;/span&gt; Feb &lt;span class="m"&gt;18&lt;/span&gt; 18:54 .
drwxr-xr-x &lt;span class="m"&gt;16&lt;/span&gt; ubuntu ubuntu &lt;span class="m"&gt;4096&lt;/span&gt; Mar  &lt;span class="m"&gt;1&lt;/span&gt; 06:02 ..
-rw-rw-r--  &lt;span class="m"&gt;1&lt;/span&gt; ubuntu ubuntu  &lt;span class="m"&gt;790&lt;/span&gt; Feb &lt;span class="m"&gt;19&lt;/span&gt; 06:04 authorized_keys
-rw-------  &lt;span class="m"&gt;1&lt;/span&gt; ubuntu ubuntu &lt;span class="m"&gt;1675&lt;/span&gt; Feb &lt;span class="m"&gt;18&lt;/span&gt; 18:51 id_rsa
-rw-r--r--  &lt;span class="m"&gt;1&lt;/span&gt; ubuntu ubuntu  &lt;span class="m"&gt;395&lt;/span&gt; Feb &lt;span class="m"&gt;18&lt;/span&gt; 18:51 id_rsa.pub
-rw-r--r--  &lt;span class="m"&gt;1&lt;/span&gt; ubuntu ubuntu &lt;span class="m"&gt;2216&lt;/span&gt; Feb &lt;span class="m"&gt;19&lt;/span&gt; 18:34 known_hosts
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;authorized_keys&lt;/code&gt; 파일은 없을수도 있다. &lt;code&gt;id_rsa&lt;/code&gt; 파일은 private key 이다. 매우 중요하므로 절대로 타인에게 노출되면 안된다. &lt;code&gt;id_rsa.pub&lt;/code&gt; 파일은 public key 이다. 접속하려는 Remote Host 의 &lt;code&gt;authorized_keys&lt;/code&gt; 에 입력한다. &lt;code&gt;authorized_keys&lt;/code&gt; 파일은 Remote Host 의 &lt;code&gt;.ssh&lt;/code&gt; 디렉토리 아래에 위치하면서 &lt;code&gt;id_rsa.pub&lt;/code&gt; 키의 값을 저장한다.&lt;/p&gt;
&lt;h2&gt;Remote Host 에 Public Key 등록&lt;/h2&gt;
&lt;p&gt;이제 &lt;code&gt;id_rsa.pub&lt;/code&gt; 파일을 리모트 서버의 &lt;code&gt;$HOME/.ssh/authorized_keys&lt;/code&gt; 파일에 추가해줘야 한다. SSH Server의 &lt;code&gt;authorized_keys&lt;/code&gt; 의 내용이 SSH Client의 &lt;code&gt;id_rsa.pub&lt;/code&gt; 파일과 같아야 한다.&lt;/p&gt;
&lt;p&gt;아래와 같이 SCP (Secure Copy) 를 이용하여 Public Key 를 Remote Host 에 복사한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;scp &lt;span class="nv"&gt;$HOME&lt;/span&gt;/.ssh/id_rsa.pub root@server.net:id_rsa.pub
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;그리고 Public Key 를 Remote Host 의 authorized_keys 에 추가한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;cat &lt;span class="nv"&gt;$HOME&lt;/span&gt;/id_rsa.pub &amp;gt;&amp;gt; &lt;span class="nv"&gt;$HOME&lt;/span&gt;/.ssh/authorized_keys
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;SSH 접속&lt;/h2&gt;
&lt;p&gt;이후에는 비밀번호 없이 바로 SSH 접속이 가능하다.&lt;/p&gt;
&lt;p&gt;만약 Private Key 를 다른 곳에 저장했다면 아래와 같이 &lt;code&gt;-i&lt;/code&gt; 옵션을 사용하여 키를 지정할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ ssh root@server.net -i keyfile
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Remote Host 의 SSHD 설정&lt;/h2&gt;
&lt;p&gt;Key 를 이용한 SSH 로그인을 사용하기 위해서는 Remote Host 의 SSHD 설정에서 RSA 키 인증을 사용하도록 설정해야 한다. 아래와 같은 내용이 있는지 SSHD 설정 파일 (&lt;code&gt;/etc/ssh/sshd_config&lt;/code&gt;) 을 확인한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;RSAAuthentication yes
#DSAAuthentication yes
PubkeyAuthentication yes
AuthorizedKeysFile .ssh/authorized_keys
&lt;/pre&gt;&lt;/div&gt;</content><category term="linux"></category><category term="ssh"></category><category term="key-gen"></category></entry><entry><title>SSH Brute force 막기</title><link href="https://imjang57.github.io/garret/defence-ssh-brute-force.html" rel="alternate"></link><published>2017-01-01T00:00:00+09:00</published><updated>2017-01-01T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-01:/garret/defence-ssh-brute-force.html</id><summary type="html">&lt;p&gt;SSH Brute force 공격 시도를 막는 설정&lt;/p&gt;</summary><content type="html">&lt;h1&gt;ssh brute force 막기&lt;/h1&gt;
&lt;p&gt;AWS EC2 를 사용하고 있었는데 갑자기 인스턴스가 엄청나게 느려졌다. 확인해보니 SSH 연결 시도가 엄청나게 쌓이고 있었다. 인터넷에서 Source 주소를 입력해서 찾아보니 중국이라고 나오는데 그거는 뭐 알 수 없는 거고.. 어쨌든 Security Group 을 22번 포트에 대해 그냥 다 열어놨더니 이런 일이 발생했나보다. 그래도 진짜 공격 받아보긴 처음이네 ㅎㅎ..&lt;/p&gt;
&lt;p&gt;어쨌뜬 그래서 이 글에 brute force 방식으로 SSH 비밀번호를 해킹하려는 시도를 차단하기 위한 설정을 남긴다. (물론 AWS 인스턴스는 Security Group 을 내 주소로만 SSH 허용하도록 바꿔서 문제없지만 나중에 필요하게 될지 모르니....)&lt;/p&gt;
&lt;p&gt;brute force 공격이 들어오면 매번 로그인 시도때마다 SSH 서버의 Resource 가 소모되기 때문에 보안성이 좋은 비밀번호나 키를 사용하더라도 이를 방지해주는 것이 좋다.&lt;/p&gt;
&lt;p&gt;ssh port 로 20초간 5회 이상 접속을 시도하면 10분간 접속을 차단하는 iptables rule 을 만들어 보자.&lt;/p&gt;
&lt;p&gt;blacklist 와 ssh chain 생성:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# iptables -N blacklist
# iptables -N ssh
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;INPUT chain 에서 state module 로 ssh port 에 접속이 시작되면 ssh chain 으로 보낸다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# iptables -A INPUT -m state --state NEW -p tcp --dport ssh -j ssh
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;blacklist chain 에서는 recent module 로 "blacklist" 라는 목록에 접속 주소를 기록하고 접속을 거부한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# iptables -A blacklist -m recent --set --name blacklist
# iptables -A blacklist -j REJECT
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;ssh chain 은 다음과 같다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# iptables -A ssh -m recent --update --seconds 600 --hitcount 1 --name blacklist -j REJECT
# iptables -A ssh -m recent --set --name ssh
# iptables -A ssh -m recent --update --seconds 20 --hitcount 5 --name ssh -j blacklist
# iptables -A ssh -j ACCEPT
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;이 ssh chain 은 다음과 같이 동작한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;접속 주소가 이미 blacklist 에 들어 있고 지난 10분간 1회 이상 접속이 있었으면 접속을 거부한다.&lt;/li&gt;
&lt;li&gt;접속 주소를 "ssh" 목록이 기록한다.&lt;/li&gt;
&lt;li&gt;접속 주소가 이미 "ssh" 목록에 있으면, 지난 20초간 5회 이상 접속이 있었으면 blacklist chain 으로 보낸다.&lt;/li&gt;
&lt;li&gt;위의 3개가 다 통과하면 ssh 접속을 허락한다.&lt;/li&gt;
&lt;/ol&gt;</content><category term="ssh"></category><category term="iptables"></category><category term="brute force"></category></entry><entry><title>iptables</title><link href="https://imjang57.github.io/garret/iptables.html" rel="alternate"></link><published>2017-01-01T00:00:00+09:00</published><updated>2017-01-01T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-01:/garret/iptables.html</id><summary type="html">&lt;p&gt;iptables 사용법&lt;/p&gt;</summary><content type="html">&lt;h1&gt;iptables&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;iptables&lt;/em&gt; 는 리눅스에서 네트웍 방화벽으로 사용되는 도구이다. Source, Destination, Protocol, State 등으로 다양한 조건을 설정할 수 있다. 리눅스 호스트에서 제공되는 가장 기초적인 방화벽 도구이며, C언어로 작성된 packet filtering framework 인 &lt;a href="https://www.netfilter.org"&gt;netfilter&lt;/a&gt; 를 기반으로 동작한다. 사실은 iptables 가 netfilter 의 하위 프로젝트라고 볼 수도 있다. 보통 &lt;em&gt;netfilter/iptables&lt;/em&gt; 와 같이 함께 언급되기도 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.netfilter.org"&gt;netfilter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.netfilter.org/projects/iptables/index.html"&gt;iptables&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://git.netfilter.org/"&gt;netfilter git repository&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://git.netfilter.org/iptables/"&gt;iptables git repository&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;대부분의 리눅스 배포판에서 &lt;em&gt;iptables&lt;/em&gt; 는 기본적으로 제공된다. &lt;code&gt;iptables&lt;/code&gt; 명령으로 방화벽 정책 관련 작업을 수행할 수 있고 &lt;em&gt;iptables-service&lt;/em&gt; 패키지를 설치하면 Daemon 형태로 관리가 가능하다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;iptables&lt;/em&gt; 에서 사용되는 정책(Rule)을 저장하기 위한 파일의 위치는 &lt;code&gt;/etc/sysconfig/iptables&lt;/code&gt; 이다.&lt;/p&gt;
&lt;p&gt;참고로, CentOS 7 부터는 &lt;em&gt;iptables&lt;/em&gt; 대신 &lt;a href="http://www.firewalld.org"&gt;firewalld&lt;/a&gt; 가 사용된다. 클라우드 환경에서의 조금 더 유연한 방화벽 관리를 위해 python 으로 만든 도구인데, 내부적으로는 &lt;em&gt;netfilter/iptables&lt;/em&gt; 를 사용한 front-end for the iptables 이다. 사용자 입장에서는 그저 명령어를 &lt;code&gt;iptables&lt;/code&gt; 대신에 &lt;code&gt;firewall-cmd&lt;/code&gt; 나 &lt;code&gt;firewall-config&lt;/code&gt; 를 사용하게 된 것이다. CentOS 7 에는 &lt;em&gt;iptables&lt;/em&gt; 자체는 있지만 &lt;em&gt;iptables-service&lt;/em&gt; 가 없어서 &lt;em&gt;firewalld&lt;/em&gt; 로 방화벽을 관리하도록 하는데, 사실 &lt;em&gt;filrewalld&lt;/em&gt; 를 끄고, &lt;em&gt;iptables-service&lt;/em&gt; 를 설치한 후 사용할 수도 있다(인터넷에 찾으면 많이 나온다). 하지만 이왕 바뀐거 나중에 다시 롤백되지 않을 가능성이 크니 익숙해지는게 좋을 테고 익숙해지면 &lt;em&gt;Redhat&lt;/em&gt; 이 &lt;em&gt;firewalld&lt;/em&gt; 를 선택한 이유도 알게 될 지도.. 어쨌든 이 글에선 &lt;em&gt;firewalld&lt;/em&gt; 에 대해선 다루지 않는다.&lt;/p&gt;
&lt;p&gt;만약 iptables 가 설치되어 있지 않다면 아래와 같이 설치하자.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ yum install iptables iptables-service
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;tables&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;iptables&lt;/em&gt; 는 4개의 &lt;em&gt;table&lt;/em&gt; 을 관리한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;filter&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;nat&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;mangle&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;raw&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;보통 사용하는 &lt;em&gt;table&lt;/em&gt; 은 &lt;em&gt;filter&lt;/em&gt; 이다.&lt;/p&gt;
&lt;h2&gt;chain&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;filter table&lt;/em&gt; 에는 &lt;em&gt;INPUT&lt;/em&gt;, &lt;em&gt;OUTPUT&lt;/em&gt;, &lt;em&gt;FORWARD&lt;/em&gt; 3개의 &lt;em&gt;chain&lt;/em&gt; 이 있다. 각 &lt;em&gt;chain&lt;/em&gt; 들은 Network Traffic (IP Packet) 에 대하여 정해진 규칙들을 수행한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;INPUT&lt;/em&gt; : Host 를 향해 들어오는 Packet&lt;/li&gt;
&lt;li&gt;&lt;em&gt;OUTPUT&lt;/em&gt; : Host 에서 나가는 Packet&lt;/li&gt;
&lt;li&gt;&lt;em&gt;FORWARD&lt;/em&gt; : Host 가 Destination 이 아닌 Packet&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;INPUT chain&lt;/em&gt; 에 해당하는 Packet 을 허용(&lt;em&gt;ACCEPT&lt;/em&gt;), 거부(&lt;em&gt;REJECT&lt;/em&gt;), 또는 드랍(&lt;em&gt;DROP&lt;/em&gt;) 할 지 결정할 수 있다.&lt;/p&gt;
&lt;h2&gt;match&lt;/h2&gt;
&lt;p&gt;어떤 Packet 에 규칙을 적용할지 판단하기 위한 조건이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--source&lt;/code&gt; (&lt;code&gt;-s&lt;/code&gt;) : Source IP address 또는 Network&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--destination&lt;/code&gt; (&lt;code&gt;-d&lt;/code&gt;) : Destination address 또는 Network&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--protocol&lt;/code&gt; (&lt;code&gt;-p&lt;/code&gt;) : Protocol&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--in-interface&lt;/code&gt; (&lt;code&gt;-i&lt;/code&gt;) : 입력 interface&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--out-interface&lt;/code&gt; (&lt;code&gt;-o&lt;/code&gt;) : 출력 interface&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--state&lt;/code&gt; : 연결 상태&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--string&lt;/code&gt; : Application Layer Data 의 Byte 순서&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--comment&lt;/code&gt; : Kernel memory 내의 규칙과 연계되는 최대 256 bytes 주석&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--syn&lt;/code&gt; (&lt;code&gt;-y&lt;/code&gt;) : SYN Packet 을 허용하지 않음&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--fragment&lt;/code&gt; (&lt;code&gt;-f&lt;/code&gt;) : 두 번째 이후의 조각에 대해서 규칙을 명시&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--table&lt;/code&gt; (&lt;code&gt;-t&lt;/code&gt;) : 처리될 table&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--jump&lt;/code&gt; (&lt;code&gt;-j&lt;/code&gt;) : 규칙에 맞는 Packet 을 어떻게 처리할 것인가를 명시&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--match&lt;/code&gt; (&lt;code&gt;-m&lt;/code&gt;) : 특정 module 과의 매치&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;target&lt;/h2&gt;
&lt;p&gt;Packet 에 적용하려는 동작이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;ACCEPT&lt;/em&gt; : Packet 을 받아들인다.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;DROP&lt;/em&gt; : Packet 을 버린다. Packet 을 송신한 쪽은 아무런 응답도 받지 못한다.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;REJECT&lt;/em&gt; : Packet 을 버리고 이와 동시에 적절한 응답 패킷(connection refused)을 전송한다.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;LOG&lt;/em&gt; : Packet 을 syslog에 기록한다.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;RETURN&lt;/em&gt; : 호출 체인 내에서 Packet 처리를 계속한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;연결 추적(Connection Tracking)&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;iptables&lt;/em&gt; 는 연결 추적(connection tracking)이라는 방법을 사용하여 내부 Network 상 서비스 연결 상태에 따라서 그 연결을 감시하고 제한할 수 있게 해준다. 연결 추적 방식은 연결 상태를 표에 저장하기 때문에, 다음과 같은 연결 상태에 따라서 시스템 관리자가 연결을 허용하거나 거부할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;NEW&lt;/em&gt; : 새로운 Connection 을 요청하는 Packet, (예: &lt;em&gt;HTTP&lt;/em&gt; 요청)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;ESTABLISHED&lt;/em&gt; : 기존 Connection 의 일부인 Packet&lt;/li&gt;
&lt;li&gt;&lt;em&gt;RELATED&lt;/em&gt; : 기존 Connection 에 속하지만 새로운 Connection 을 요청하는 Packet, 예를 들면 접속 port 가 20인 수동 FTP의 경우 전송 포트는 사용되지 않은 1024 이상의 어느 port 라도 사용 가능하다.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;INVALID&lt;/em&gt; : 연결 추적표에서 어디 Connection 에도 속하지 않은 Packet&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;상태에 기반(stateful)한 &lt;em&gt;iptables&lt;/em&gt; 연결 추적 기능은 어느 Network Protocol 에서나 사용 가능하다. &lt;em&gt;UDP&lt;/em&gt; 와 같이 상태를 저장하지 않는 (stateless) Protocol 에서도 사용할 수 있다.&lt;/p&gt;
&lt;h2&gt;명령어(commond)&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;iptables&lt;/em&gt; 에서 사용 가능한 명령들의 목록:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-A&lt;/code&gt; (&lt;code&gt;--append&lt;/code&gt;) : 새로운 규칙을 추가한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-D&lt;/code&gt; (&lt;code&gt;--delete&lt;/code&gt;) : 규칙을 삭제한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-C&lt;/code&gt; (&lt;code&gt;--check&lt;/code&gt;) : 패킷을 테스트한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-R&lt;/code&gt; (&lt;code&gt;--replace&lt;/code&gt;) : 새로운 규칙으로 교체한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-I&lt;/code&gt; (&lt;code&gt;--insert&lt;/code&gt;) : 새로운 규칙을 삽입한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-L&lt;/code&gt; (&lt;code&gt;--list&lt;/code&gt;) : 규칙을 출력한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-F&lt;/code&gt; (&lt;code&gt;--flush&lt;/code&gt;) : &lt;em&gt;chain&lt;/em&gt; 으로부터 규칙을 모두 삭제한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-Z&lt;/code&gt; (&lt;code&gt;--zero&lt;/code&gt;) : 모든 &lt;em&gt;chain&lt;/em&gt; 의 패킷과 바이트 카운터 값을 0으로 만든다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-N&lt;/code&gt; (&lt;code&gt;--new&lt;/code&gt;) : 새로운 &lt;em&gt;chain&lt;/em&gt; 을 만든다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-X&lt;/code&gt; (&lt;code&gt;--delete-chain&lt;/code&gt;) : &lt;em&gt;chain&lt;/em&gt; 을 삭제한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-P&lt;/code&gt; (&lt;code&gt;--policy&lt;/code&gt;) : 기본정책을 변경한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;추가로 &lt;code&gt;-L&lt;/code&gt; 옵션 이용시 &lt;code&gt;-n&lt;/code&gt; (&lt;code&gt;--numeric&lt;/code&gt;) 옵션을 추가하면 address 와 port 를 더 편하게 볼 수 있다. (&lt;code&gt;iptables -nL&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;내용을 확인할 때 &lt;code&gt;--line-numbers&lt;/code&gt; 를 추가하면 각 Ruleset 들의 순서도 같이 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-v&lt;/code&gt; (&lt;code&gt;--verbose&lt;/code&gt;) 옵션을 사용하면 더 다양한 정보를 볼 수 있다.&lt;/p&gt;
&lt;p&gt;추가 사용법은 &lt;code&gt;-h&lt;/code&gt; (&lt;code&gt;--help&lt;/code&gt;) 를 확인하자.&lt;/p&gt;
&lt;h2&gt;기본 동작&lt;/h2&gt;
&lt;p&gt;다음은 &lt;em&gt;iptables&lt;/em&gt; 의 기본 동작 과정이다.&lt;/p&gt;
&lt;p&gt;패킷에 대한 동작은 위에서 부터 차례로 각 규칙에 대해 검사하고, 그 규칙과 일치하는 패킷에 대하여 타겟에 지정한 &lt;em&gt;ACCEPT&lt;/em&gt;, &lt;em&gt;DROP&lt;/em&gt; 등을 수행한다.&lt;/p&gt;
&lt;p&gt;규칙이 일치하고 작업이 수행되면, 그 패킷은 해당 규칙의 결과에 따리 처리하고 체인에서 추가 규칙을 무시한다.&lt;/p&gt;
&lt;p&gt;패킷이 체인의 모든 규칙과 매치하지 않아 규칙의 바닥에 도달하면 정해진 기본정책(policy)이 수행된다.&lt;/p&gt;
&lt;p&gt;기본 정책은 policy &lt;em&gt;ACCEPT&lt;/em&gt;, policy &lt;em&gt;DROP&lt;/em&gt; 으로 설정할 수 있다.&lt;/p&gt;
&lt;p&gt;일반적으로 기본정책은 모든 패킷에 대해 &lt;em&gt;DROP&lt;/em&gt; 을 설정하고 특별히 지정된 포트와 IP주소등에 대해 &lt;em&gt;ACCEPT&lt;/em&gt; 를 수행하게 만든다.&lt;/p&gt;
&lt;h1&gt;iptables 사용하기&lt;/h1&gt;
&lt;p&gt;iptables 적용 예:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;iptables -P INPUT ACCEPT&lt;/code&gt; : &lt;em&gt;INPUT Chain&lt;/em&gt; 의 기본 정책을 &lt;em&gt;ACCEPT&lt;/em&gt; 로 설정&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iptables -P INPUT DROP&lt;/code&gt; : &lt;em&gt;INPUT Chain&lt;/em&gt; 의 기본정책을 &lt;em&gt;DROP&lt;/em&gt; 으로 설정&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iptables -F&lt;/code&gt; : &lt;em&gt;Chain&lt;/em&gt; 에 정의된 모든 규칙을 삭제&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iptables -nL&lt;/code&gt; : 현재 ruleset 설정 확인(address 와 port 는 숫자로 출력)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iptables -A INPUT -i lo -j ACCEPT&lt;/code&gt; : &lt;em&gt;INPUT Chain&lt;/em&gt; 에 localhost interface 인 Packet 은 모두 &lt;em&gt;ACCEPT&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iptables -A INPUT -m state — state ESTABLISHED,RELATED -j ACCEPT&lt;/code&gt; : &lt;em&gt;INPUT Chain&lt;/em&gt; 에 state module 의 state 가 &lt;em&gt;ESTABLISHED&lt;/em&gt;, &lt;em&gt;RELATED&lt;/em&gt; 인 Packet 에 대해 &lt;em&gt;ACCEPT&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iptables -A INPUT -p tcp -m tcp — dport 22 -j ACCEPT&lt;/code&gt; : &lt;em&gt;INPUT Chain&lt;/em&gt; 에 Protocol 의 &lt;em&gt;TCP&lt;/em&gt; 이며 destination port 가 22번인 Packet 에 대해 &lt;em&gt;ACCEPT&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;service iptables save&lt;/code&gt; 명령을 실행하면 &lt;code&gt;/etc/sysconfig/iptables&lt;/code&gt; 에 &lt;em&gt;iptables&lt;/em&gt; 현재 설정이 저장된다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;iptables&lt;/em&gt; 규칙을 만들 때는 순서가 매우 중요하다. 예를 들어 만일 &lt;em&gt;chain&lt;/em&gt; 에서 local network 인 192.168.100.0/24 subnetwork 에서 들어오는 모든 packet 을 &lt;em&gt;DROP&lt;/em&gt; 하도록 지정한 후 (&lt;em&gt;DROP&lt;/em&gt; 하도록 지정된 subnetwork 에 포함되는) 192.168.100.13 에서 들어오는 packet 을 모두 허용하는 &lt;em&gt;chain&lt;/em&gt; (&lt;code&gt;-A&lt;/code&gt;)을 그 후에 추가하면 뒤에 추가된 추가 규칙이 무시된다. 먼저 192.168.100.13 을 허용하는 규칙을 설정한 후 subnet 을 &lt;em&gt;DROP&lt;/em&gt; 하는 규칙을 설정해야한다.&lt;/p&gt;
&lt;p&gt;HTTP Web Server 를 용할 경우:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;iptables -A INPUT -p tcp -m tcp --dport 80 -j ACCEPT
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;HTTPS:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;iptables -A INPUT -p tcp -m tcp --dport 443 -j ACCEPT
-A INPUT -m state --state NEW -m tcp -p tcp -m multiport --dports 80,443 -j ACCEPT
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;MySQL (port 3306):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;iptables -A INPUT -p tcp --dport 3306 -j ACCEPT
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;FTP(passive mode):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;iptables -A INPUT -p tcp --dport 21 -j ACCEPT
iptables -A OUTPUT -p tcp --sport 21 -j ACCEPT
iptables -A INPUT -p tcp --dport 1024:65535 -j ACCEPT
iptables -A OUTPUT -p tcp --sport 1024:65535 -j ACCEPT
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;NTP 시간동기화:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;iptables -A INPUT -p udp --dport 123 -j ACCEPT
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;서버의 취약점을 차단하기 위한 iptables 설정 예&lt;/h1&gt;
&lt;p&gt;NULL 패킷 차단: &lt;code&gt;iptables -A INPUT -p tcp --tcp-flags ALL NONE -j DROP&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;NULL 패킷은 정찰 패킷으로 서버설정의 약한 곳을 찾기위한 방법으로 사용된다.&lt;/p&gt;
&lt;h1&gt;기타 사용법&lt;/h1&gt;
&lt;p&gt;기타 &lt;em&gt;iptables&lt;/em&gt; 사용법에 대해 알아보자.&lt;/p&gt;
&lt;h2&gt;iptables 수정&lt;/h2&gt;
&lt;p&gt;등록된 &lt;em&gt;iptables&lt;/em&gt; 를 수정하는 방법은 &lt;code&gt;/etc/sysconfig/iptables&lt;/code&gt; 에서 직접 vi로 수정하거나 &lt;code&gt;iptables&lt;/code&gt; 명령어를 사용한다.&lt;/p&gt;
&lt;p&gt;실행 순번을 확인하기: &lt;code&gt;iptables -nL --line-number&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;순번 3의 행을 수정(replace, &lt;code&gt;-R&lt;/code&gt;): &lt;code&gt;iptables -R INPUT 3 -p tcp --dport 2222 -j ACCEPT&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;인터페이스 지정&lt;/h2&gt;
&lt;p&gt;Network interface 를 지정하여 &lt;em&gt;iptables&lt;/em&gt; 를 적용할 수도 있다.&lt;/p&gt;
&lt;p&gt;루프백 인터페이스에 대해 모든 패킷을 허용: &lt;code&gt;iptables -A INPUT -i lo -j ACCEPT&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;랜카드 지정에 대해 모든 패킷을 허용: &lt;code&gt;iptables -A INPUT -i eth0 -j ACCEPT&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;IP 주소 지정&lt;/h2&gt;
&lt;p&gt;IP address 를 지정하여 iptables 를 적용할 수도 있다.&lt;/p&gt;
&lt;p&gt;신뢰할 만한 ip에 대해 모든 패킷을 허용: &lt;code&gt;iptables -A INPUT -s 192.168.0.3 -j ACCEPT&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;신뢰할 만한 ip 대역에 대해 모든 패킷을 허용: &lt;code&gt;iptables -A INPUT -s 192.168.0.0/24 -j ACCEPT&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;신뢰할 만한 ip 대역에 대해 모든 패킷을 허용: &lt;code&gt;iptables -A INPUT -s 192.168.0.0/255.255.255.0 -j ACCEPT&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;신뢰할 만한 ip와 MAC주소에 대해 모든 패킷을 허용: &lt;code&gt;iptables -A INPUT -s 192.168.0.3 -m mac — mac-source 00:50:80:FD:E6:32 -j ACCEPT&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;포트 범위지정: &lt;code&gt;iptables -A INPUT -p tcp --dport 6881:6890 -j ACCEPT&lt;/code&gt;&lt;/p&gt;
&lt;h1&gt;자동화 스크립트&lt;/h1&gt;
&lt;p&gt;자주 방화벽 설정을 초기화하고 재설정해야 한다면 자동화 스크립트를 짜놓는게 좋다. 아래는 그에 대한 예이다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/bin/bash&lt;/span&gt;
&lt;span class="c1"&gt;# iptables 설정 자동화 스크립트&lt;/span&gt;
&lt;span class="c1"&gt;# 입맛에 따라 수정해서 사용합시다.&lt;/span&gt;
iptables -F
&lt;span class="c1"&gt;# TCP 포트 22번을 SSH 접속을 위해 허용&lt;/span&gt;
&lt;span class="c1"&gt;# 원격 접속을 위해 먼저 설정합니다&lt;/span&gt;
iptables -A INPUT -p tcp -m tcp --dport &lt;span class="m"&gt;22&lt;/span&gt; -j ACCEPT
&lt;span class="c1"&gt;# 기본 정책을 설정합니다&lt;/span&gt;
iptables -P INPUT DROP
iptables -P FORWARD DROP
 iptables -P OUTPUT ACCEPT
&lt;span class="c1"&gt;# localhost 접속 허용&lt;/span&gt;
iptables -A INPUT -i lo -j ACCEPT
&lt;span class="c1"&gt;# established and related 접속을 허용&lt;/span&gt;
iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
&lt;span class="c1"&gt;# Apache 포트 80 허용&lt;/span&gt;
iptables -A INPUT -p tcp --dport &lt;span class="m"&gt;80&lt;/span&gt; -j ACCEPT
&lt;span class="c1"&gt;# 설정을 저장&lt;/span&gt;
/sbin/service iptables save
&lt;span class="c1"&gt;# 설정한 내용을 출력&lt;/span&gt;
iptables -L -v
위 내용을 입맛에 맞게 수정한 후에 저장&lt;span class="o"&gt;(&lt;/span&gt;myfirewall&lt;span class="o"&gt;)&lt;/span&gt;
권한부여: chmod +x myfirewall
실행: ./myfirewall
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;References&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;http://webdir.tistory.com/170&lt;/li&gt;
&lt;/ul&gt;</content><category term="iptables"></category></entry><entry><title>Linux 에서 파일 관리를 위한 명령어들</title><link href="https://imjang57.github.io/garret/linux-command-for-file-management.html" rel="alternate"></link><published>2017-01-01T00:00:00+09:00</published><updated>2017-05-08T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-01:/garret/linux-command-for-file-management.html</id><summary type="html">&lt;p&gt;Linux 에서 파일 관리일 위한 명령어들(ls, lsof, chown, chmod, mv, cp, rm, rmdir, mkdir, fuser, ln, file, diff, patch, cat, tail, head, etc)&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Linux 에서 사용자 관리를 위한 명령어들&lt;/h1&gt;
&lt;p&gt;Linux 에서 파일 목록 확인, 파일 내용 확인, 사용 중인 파일 확인, 파일 정보 변경, 파일 비교, 패치 등을 위한 명령어들을 정리한 글이다.&lt;/p&gt;
&lt;p&gt;리눅스에서는 모든 것이 파일로 관리된다. 일반적으로 알고 있는 파일 외에 console, socket, device 등도 모두 파일이다. 그래서 리눅스에서 모든 인터페이스는 File Descriptor 를 기반으로 하고 모든 입력과 출력은 File Descriptor 를 통해 이루어진다.&lt;/p&gt;
&lt;h1&gt;파일 목록 조회&lt;/h1&gt;
&lt;p&gt;일반적으로 파일 목록을 조회하는 명령어는 &lt;code&gt;ls&lt;/code&gt; 이다. &lt;code&gt;ls -alh [path]&lt;/code&gt; 와 같이 여러 옵션을 전달할 수 있다. &lt;code&gt;-a&lt;/code&gt; 는 숨김파일(리눅스에서는 &lt;code&gt;.&lt;/code&gt; 으로 시작하면 숨김파일로 처리한다)을 포함한 모든 파일을 보여준다. &lt;code&gt;-l&lt;/code&gt; 옵션을 file name 외에 mode bits, owner, group, modification time 등의 추가적인 정보도 보여준다. &lt;code&gt;-h&lt;/code&gt; 옵션을 파일의 크기를 사람이 쉽게 인식할 수 있도록 크기에 따라 KB, MB, GB 단위로 바꿔서 보여준다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lsof&lt;/code&gt; 명령어는 사용 중인 파일, 즉 열려 있는 파일들을 확인할 수 있는 명령어이다. user name, process id, network protocol, network port, command name 등 여러 기준으로 사용 중인 파일들을 확인할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;lsof -u &amp;lt;usrename&amp;gt;&lt;/code&gt; : 특정 사용자가 열어서 사용중인 파일들을 검색&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lsof &amp;lt;file path&amp;gt;&lt;/code&gt; : 특정 파일을 사용하는 프로세스와 사용자 확인 가능&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lsof +D &amp;lt;directory path&amp;gt;&lt;/code&gt; : 특정 directory 밑에 있는 열려있는 파일들을 검색&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lsof -p &amp;lt;process id&amp;gt;&lt;/code&gt; : process id 가 사용 중인 파일들을 검색&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lsof -i&lt;/code&gt; : 모든 네트웍 포트 중 열려있는 포트를 검색&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lsof -i TCP&lt;/code&gt; : 모든 TCP 포트 중 열려있는 포트를 검색&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lsof -i TCP:22&lt;/code&gt; : 22번 TCP 포트를 사용중인 프로세스와 사용자 확인 가능&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lsof -i TCP:22-80&lt;/code&gt; : 22번에서 80번까지의 TCP 포트 중 열려있는 포트를 검색&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lsof -c httpd&lt;/code&gt; : httpd command 가 사용 중인 파일들을 검색&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;또한 &lt;code&gt;fuser&lt;/code&gt; 명령어를 사용하면 파일을 사용 중인 process id 를 확인할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fuser -n tcp 22&lt;/code&gt; : tcp 22 port 를 사용중인 process id 를 확인&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fuser -n file &amp;lt;file path&amp;gt;&lt;/code&gt; : 특정 파일을 사용중인 process id 를 확인&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;file&lt;/code&gt; 이라는 명령어를 사용하면 특정 파일의 type 을 확인할 수 있다. 일반적인 파일이 어떤 파일인지 확인할 때 사용되는데 Text file 인지, 실행 파일, Python code 인지, Shell script 인지를 알 수 있으며 Encoding(ASCII, UTF-8 등) 이 무엇인지도 확인가능하다.&lt;/p&gt;
&lt;h1&gt;파일 메타 정보 변경&lt;/h1&gt;
&lt;p&gt;Linux 에서 파일은 Owner 와 Group owner 가 있고, mode bits 가 있어서 여러 사용자들이 파일에 대해 어떤 권한까지 접근할 수 있는지를 지정할 수 있다. 이 정보들은 &lt;code&gt;ls -l&lt;/code&gt; 을 실행하면 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;chown&lt;/code&gt; 은 파일의 owner 정보를 변경한다. &lt;code&gt;chown [-R] &amp;lt;username&amp;gt;:&amp;lt;groupname&amp;gt; &amp;lt;path&amp;gt;&lt;/code&gt; 와 같이실행할 수 있고 &lt;code&gt;-R&lt;/code&gt; 옵션이 있으면 하위 디렉터리들과 파일들도 모두 같이 변경한다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;chmod&lt;/code&gt; 는 파일의 mode bits 를 변경한다. &lt;code&gt;chown [-R] 755 &amp;lt;path&amp;gt;&lt;/code&gt; 와 같이 실행할 수 있고 &lt;code&gt;-R&lt;/code&gt; 옵션이 있으면 하위 디렉터리들과 파일들도 모두 같이 변경한다. 또한 sticky bit 를 설정하려면 &lt;code&gt;chown [-R] 1777 &amp;lt;path&amp;gt;&lt;/code&gt; 와 같이 mode bits 를 1777 하면 된다.&lt;/p&gt;
&lt;h1&gt;파일 처리&lt;/h1&gt;
&lt;p&gt;파일은 복사, 이동, 삭제 등이 가능하다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mv&lt;/code&gt; : move (rename) files&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cp&lt;/code&gt; : copy files and directories&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cp -r &amp;lt;src&amp;gt; &amp;lt;dst&amp;gt;&lt;/code&gt; : &lt;code&gt;-r&lt;/code&gt; 옵션을 전달하면 recursive 하게 복사를 수행하여 하위 파일들과 디렉터리들도 모두 복사된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rm&lt;/code&gt; : remove files or directories&lt;ul&gt;
&lt;li&gt;&lt;code&gt;rm -r&lt;/code&gt; : recursive 하게 삭제&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rm -f&lt;/code&gt; : 삭제 여부를 묻는 prompting 없이 삭제한다. 그리고 삭제하는 파일이 없어도 에러로 처리하지 않고 그냥 넘어간다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;또한 directory 만을 위한 명령어도 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;rmdir&lt;/code&gt; : remove empty directories&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mkdir&lt;/code&gt; : make directories&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mkdir -p &amp;lt;path&amp;gt;&lt;/code&gt; : &lt;code&gt;-p&lt;/code&gt; 옵션을 directory 를 생성할 때 parent directory 가 없을 경우 parent directory 들도 같이 생성한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Link 생성&lt;/h1&gt;
&lt;p&gt;Linux 에서는 Symbolic link 와 Hard link 가 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ln&lt;/code&gt; : make links between files&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ln -s &amp;lt;target&amp;gt; &amp;lt;link name&amp;gt;&lt;/code&gt; : Symbolic link 를 생성한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;파일 내용 출력&lt;/h1&gt;
&lt;p&gt;텍스트 파일의 경우 내용을 확인할 수 있는 여러 명령어들이 있다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cat&lt;/code&gt; 은 concatenate and print files 라고 man pages 에 나와있듯이 파일을 출력하고 내용을 추가하기 위해 사용된다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cat &amp;lt;filepath&amp;gt;&lt;/code&gt; 를 실행하면 특정 파일의 냉용을 출력한다. 파일의 내용이 많을 경우 &lt;code&gt;cat &amp;lt;filepath&amp;gt; | less&lt;/code&gt; 또는 &lt;code&gt;cat &amp;lt;filepath&amp;gt; | more&lt;/code&gt; 와 같이 pipe 를 사용하여 파일의 내용을 pager utility 로 확인하면 된다. 그냥 &lt;code&gt;cat&lt;/code&gt; 을 실행하면 Stdin (Standard in) 으로 한줄을 입력받고 바로 Stddout (Standard out) 으로 바로 출력한다. 만약 파일에 내용을 저장하려면 &lt;code&gt;cat &amp;gt; &amp;lt;filepath&amp;gt;&lt;/code&gt; 를 실행하면 된다. 입력을 종료하려면 &lt;code&gt;C-D&lt;/code&gt; (&lt;code&gt;ctrl + D&lt;/code&gt;) 를 입력하여 End-of-file signal 을 전송하여 &lt;code&gt;cat&lt;/code&gt; 을 종료한다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tail&lt;/code&gt; 은 파일의 마지막 부분을 출력하는 명령어이다. &lt;code&gt;tail [-n &amp;lt;number&amp;gt;] &amp;lt;file path&amp;gt;&lt;/code&gt; 와 같이 실행할 수 있다. default 로 마지막 10줄을 출력하며 &lt;code&gt;-n&lt;/code&gt; 옵션을 사용하여 출력할 line 수를 지정할 수 있다. &lt;code&gt;tail -f &amp;lt;file path&amp;gt;&lt;/code&gt; 를 실행하면 파일의 내용이 추가되는 것을 바로 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;head&lt;/code&gt; 는 &lt;code&gt;tail&lt;/code&gt; 과 반대로 파일의 처음 부분을 출력하는 명령이다. &lt;code&gt;head [-n &amp;lt;number&amp;gt;] &amp;lt;file path&amp;gt;&lt;/code&gt; 와 같이 실행할 수 있다. default 로 처음 10줄을 출력하며 &lt;code&gt;-n&lt;/code&gt; 옵션을 사용하여 출력할 line 수를 지정할 수 있다.&lt;/p&gt;
&lt;h1&gt;파일 비교&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;diff&lt;/code&gt; 를 사용하여 두 파일의 내용을 비교할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;diff &amp;lt;file1&amp;gt; &amp;lt;file2&amp;gt;&lt;/code&gt; 와 같이 실행되는데 대부분 &lt;code&gt;diff -uNr &amp;lt;file1&amp;gt; &amp;lt;file1&amp;gt;&lt;/code&gt; 와 같이 옵션을 전달하여 사용된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-u&lt;/code&gt; : diff output format 을 unified format 으로 지정한다. context format 등 다른 format 들도 있지만 보통 &lt;code&gt;-u&lt;/code&gt; 옵션을 사용한다. format에 대한 자세한 내용은 따로 googling 해보자.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-r&lt;/code&gt; : recursive 를 의미한다. 즉, sub-directory 까지 모두 포함하여 실행한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-N&lt;/code&gt; : 새 파일도 포함하여 실행한다. 존재하지 않는 original file 을 empty file 로 취급한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Make and apply patches using diff and patch command&lt;/h1&gt;
&lt;p&gt;패치(patch) 파일은 두 파일들간의 차이들을 출력해 주는 프로그램인 &lt;code&gt;diff&lt;/code&gt; 에 의해 생성된 파일을 의미한다. 주로 쓰이는 때는 어떤 프로그램에서 기능향상이나 문제점을 해결하기 위해 소스파일들을 고치고 나서 고친 부분에 대한 정보만을 기록해 놓고 싶을때 쓰인다. 고친 소스파일 전체보다도 고친 부분에 대한 정보만을 갖고 있으면 저장해야 되는 양이 적고, 어떤 부분을 고쳤는지 파악하기도 쉽다는 장점이 있다. (특히 비공식적인 패치 적용시 프로그램이 버젼업이 되어 소스가 변경되었을때 유용하다.) 패치파일의 확장자는 사용자 임의이긴 하지만 알아보기 쉽도록 주로 &lt;code&gt;.diff&lt;/code&gt; 또는 &lt;code&gt;.patch&lt;/code&gt; 를 사용한다.&lt;/p&gt;
&lt;h2&gt;diff example&lt;/h2&gt;
&lt;p&gt;아래와 같이 &lt;code&gt;hello.c&lt;/code&gt; 라는 file 이 있다.:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt;

&lt;span class="cpf"&gt;int main(void) {&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;hello&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;위에서 'hello' 라는 문구 대신 '안녕하세요'로 바꾸고 싶다고 하자. 먼저 다음과 같이 위의 &lt;code&gt;hello.c&lt;/code&gt; 파일을 &lt;code&gt;hello.c.orig&lt;/code&gt; 라는 파일로 백업해 둔다:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ cp hello.c hello.c.orig
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;그리고 &lt;code&gt;hello.c&lt;/code&gt; 파일을 다음과 같이 고친다:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt;

&lt;span class="cpf"&gt;int main(void) {&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;안녕하세요&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;이 두 파일의 차이점을 패치 파일로 기록해 두기 위해 다음과 같이 &lt;code&gt;diff&lt;/code&gt; 명령을 이용한다.:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ diff -uNr hello.c.orig hello.c &amp;gt; hello-hangul.patch
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;생성된 &lt;code&gt;hello-hangul.patch&lt;/code&gt; 라는 파일은 단순한 텍스트 파일이다. 그 내용을 보기 위해 다음과 같은 명령을 실행해 보자:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ cat hello-hangul.patch
--- hello.c.orig      Sun Jan &lt;span class="m"&gt;16&lt;/span&gt; 16:54:32 2000
+++ hello.c   Sun Jan &lt;span class="m"&gt;16&lt;/span&gt; 16:53:04 2000
@@ -2,6 +2,6 @@

int main&lt;span class="o"&gt;(&lt;/span&gt;void&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
- printf&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;hello\n&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
+ printf&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;안녕하세요\n&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; 0&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;고친 파일의 이름, 고친 부분의 아래 위 세줄의 내용과 고친 부분이 -, + 로 표시되어 있는 것을 알 수 있다. 만약, 수정한 파일이 많다면 &lt;code&gt;diff&lt;/code&gt; 를 file 단위가 아니라 directory 단위로 실행시킬 수 있다:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ diff -uNr &lt;span class="o"&gt;[&lt;/span&gt;from-directory&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;to-directory&lt;span class="o"&gt;]&lt;/span&gt; &amp;gt; directory_patch.diff
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;paatch file 을 만들기 전에 &lt;code&gt;make clean&lt;/code&gt; 등을 이용하여 컴파일 과정의 결과로 생성되는 object file 들이나 기타 불필요한 파일들을 정리하고 실행하자.&lt;/p&gt;
&lt;h2&gt;Apply patch file: Using patch command&lt;/h2&gt;
&lt;p&gt;다음은 패치 파일과 변형되지 않은 원래 프로그램 소스 파일을 가지고 있을 때 패치를 적용하는 방법이다. 일단 패치를 적용하기 위해서는 &lt;code&gt;patch&lt;/code&gt; 라는 명령어를 이용하는데, 그 일반적인 형식은 다음과 같다:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ patch &lt;span class="o"&gt;[&lt;/span&gt;options&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;originalfile &lt;span class="o"&gt;[&lt;/span&gt;patchfile&lt;span class="o"&gt;]]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;일단 패치 파일을 살펴본다. 패치의 맨 윗줄을 보면 다음과 같이 파일에 관한 정보가 있는 부분이 있다:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gd"&gt;--- xchat-1.2.0/src/serverlist.h.orig   Wed Aug 25 14:48:57 1999&lt;/span&gt;
&lt;span class="gi"&gt;+++ xchat-1.2.0/src/serverlist.h        Sun Oct 31 18:06:13 1999&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;변경되지 않은 프로그램의 소스 디렉토리로 이동한다음 다음과 같이 &lt;code&gt;patch&lt;/code&gt; 라는 명령을 이용하여 패치를 한다:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;cd&lt;/span&gt; xchat-1.2.0/
$ patch -p1 &amp;lt; ../xchat-1.2.0-serverlist.patch
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;patch&lt;/code&gt; command 는 입력을 stdin 으로 받을 수 있기 때문에 redirect 를 이용해서 patch file 내용을 전달한다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-p&lt;/code&gt; 옵션은 patch file 의 정보에 있는 path 에서 몇 단계를 제외할 지를 나타낸다. 예를 들어 위에서 처럼 &lt;code&gt;-p1&lt;/code&gt; 옵션을 주면 patch 적용 path 는 xchat-1.2.0 이 제외된 &lt;code&gt;src/serverlist.h&lt;/code&gt; 가 되고, 현재 위치(directory, path) 를 기준으로 &lt;code&gt;src/serverlist.h&lt;/code&gt; 파일에 패치를 적용한다. 만약 그 상위디렉토리에서 패치를 적용하기 원한다면 그냥 다음과 같이 하면 될 것이다:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ patch -p0 &amp;lt; xchat-1.2.0-serverlist.patch
&lt;/pre&gt;&lt;/div&gt;</content><category term="linux"></category><category term="file"></category></entry><entry><title>Linux 에서 사용자 권한 관리</title><link href="https://imjang57.github.io/garret/linux-command-for-permission.html" rel="alternate"></link><published>2017-01-01T00:00:00+09:00</published><updated>2017-05-08T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-01:/garret/linux-command-for-permission.html</id><summary type="html">&lt;p&gt;Linux 에서 사용자 권한 관리에 대한 글&lt;/p&gt;</summary><content type="html">&lt;h1&gt;permissions&lt;/h1&gt;
&lt;p&gt;보통 Linux syste 에는 root 라는 사용자가 있는데, 이는 Linux system 에서 가장 높은 권한을 가진 사용자이며 대부분의 리눅스 배포판(Linux distribution)에서 기본적으로 제공되는 username 이다. 물론 요즘은 Mac 이나 Ubuntu 처럼 root 를 제공하지 않고 관리자 권한을 가진 계정을 제공하기도 한다. 어쨌든 관리자 권한을 갖고 시스템 전체에 접근하고 변경할 수 있도록 설정된 사용자가 존재한다.&lt;/p&gt;
&lt;p&gt;이 외의 일반 사용자들은 제한된 권한으로 시스템을 사용하게 되는데 설정에 따라 어떤 사용자들은 잠시 최상위 권한을 얻을 수 있다. 최상위 권한을 얻을 수 있도록 설정된 사용자는 &lt;code&gt;sudo&lt;/code&gt; 라는 명령어를 통해 이 권한을 얻을 수 있으며, 이 설정은 &lt;code&gt;/etc/sudoers&lt;/code&gt; 라는 파일을 통해서 관리된다.&lt;/p&gt;
&lt;h1&gt;sudo&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;sudo&lt;/code&gt; 는 일반사용자가 루트 권한을 임시적으로 획득하여 특정 명령을 할 수 있도록 하는 명령어이다. substitute user do 를 줄인 단어로, 다른 사용자의 권한으로 명령을 이행하라는 뜻이다&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sudo&lt;/code&gt; 의 man pages 에는 다음과 같이 설명한다:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;sudo — execute a command as another user
sudo allows a permitted user to execute a command as the superuser or another user, as specified by the security policy.
The default security policy is sudoers, which is configured via the file /etc/sudoers&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;일반사용자가 &lt;code&gt;sudo&lt;/code&gt; 명령어를 사용하기 위해서는 &lt;code&gt;/etc/sudoers&lt;/code&gt; 파일이나 &lt;code&gt;/etc/sudoers.d/&amp;lt;filename&amp;gt;&lt;/code&gt; 에 등록되어 있어야 한다.&lt;/p&gt;
&lt;h1&gt;사용자에게 sudo 권한 추가&lt;/h1&gt;
&lt;p&gt;우분투는 기본적으로 root 계정을 사용하지 못하게 하고, root 계정이 필요한 경우 sudo 명령을 통해서 root 가 아닌 계정에서 명령을 실행할 수 있도록 되어있다.&lt;/p&gt;
&lt;p&gt;그런데 아무 계정에서나 &lt;code&gt;sudo&lt;/code&gt; 명령을 실행할 수 있는 것은 아니다. 기본적으로는 admin 이라는 group 에 계정이 속해있어야 가능하다(group 이름이 admin 이 아닐 수도 있지만 어쨌든 관리자들을 위한 group 이 대부분 존재한다).&lt;/p&gt;
&lt;p&gt;이 글에서는 admin 이 아닌 다른 그룹에 계정을 생성했을 때, &lt;code&gt;sudo&lt;/code&gt; 명령어를 사용할 수 있도록 설정하는 법을 적었다.&lt;/p&gt;
&lt;p&gt;관리자 권한은 &lt;code&gt;/etc/sudoers&lt;/code&gt; 파일에서 관리되는데 이 파일은 쓰기 권한이 없다. 이 파일을 수정하기 위해서는 2가지 방법이 있다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;visudo&lt;/code&gt; 명령어를 실행하여 수정하는 방법&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/etc/sudoers&lt;/code&gt; 파일에 임시로 쓰기 권한((&lt;code&gt;chmod +w /etc/sudoers&lt;/code&gt;)을 추가한 다음 수정 후 다시 원래 권한(&lt;code&gt;chmod 440 /etc/sudoers&lt;/code&gt;)으로 되돌리는 방법&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;임의로 권한을 변경하는 것은 위험한 작업이므로 &lt;code&gt;visudo&lt;/code&gt; 를 이용하는 것이 좋다.&lt;/p&gt;
&lt;p&gt;먼저 &lt;code&gt;sudo&lt;/code&gt; 설정 파일(&lt;code&gt;/etc/sudoers&lt;/code&gt;)을 수정하기 위해 아래와 같이 입력한다:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ sudo visudo
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;또는 &lt;code&gt;/etc/sudoers&lt;/code&gt; 파일의 권한을 쓰기를 추가한 다음(chmod +w /etc/sudoers) 작업을 끝낸 후 다시 440 모드(chmod 440 /etc/sudoers)로 바꿔줘도 괜찮다.&lt;/p&gt;
&lt;p&gt;/etc/sudoers 파일에 아래와 같은 내용을 추가한다:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;# 특정 사용자에게 sudo 권한을 허락하는 경우&lt;/span&gt;
&lt;span class="n"&gt;userid&lt;/span&gt; &lt;span class="n"&gt;ALL&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nl"&gt;ALL&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;ALL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;ALL&lt;/span&gt;
&lt;span class="cp"&gt;# 특정 그룹에 sudo 권한을 허락하는 경우&lt;/span&gt;
&lt;span class="nf"&gt;%groupid&lt;/span&gt; &lt;span class="n"&gt;ALL&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ALL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;ALL&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;아래와 같이 입력하면 &lt;code&gt;sudo&lt;/code&gt; 실행 시 패스워드를 생략할 수 있다:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;%groupname&lt;/span&gt; &lt;span class="n"&gt;ALL&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ALL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nl"&gt;NOPASSWD&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;ALL&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;sudo 명령 시 특정 환경변수를 유지하도록 설정하는 법&lt;/h1&gt;
&lt;p&gt;예를 들어, HTTP Proxy 를 사용하는 환경에서 &lt;code&gt;sudo&lt;/code&gt; 를 이용하여 HTTP 요청을 하면 정상적으로 동작하지 않는 경우가 있다:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ sudo curl http://www.host.com
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;이는 &lt;code&gt;http_proxy&lt;/code&gt; 라는 환경변수가 sudo shell environment 에 없기 때문이다. 아래와 같이 명령을 입력하면 &lt;code&gt;sudo&lt;/code&gt; 로 실행되는 환경에서는 &lt;code&gt;http_proxy&lt;/code&gt; 가 없음을 알 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ sudo env
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;이를 해결하기 위해서는 &lt;code&gt;/etc/sudoers&lt;/code&gt; 에 특정 환경변수를 유지하도록 설정해주어야 한다.&lt;/p&gt;
&lt;p&gt;아래 명령으로 &lt;code&gt;/etc/sudoers&lt;/code&gt; 파일을 열자:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ sudo visudo
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;그리고 아래와 같은 라인을 추가하자:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Defaults env_keep += &amp;quot;http_proxy https_proxy&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;/etc/sudoers 파일이 잘못되어서 sudo 명령이 되지 않을 때&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;sudo&lt;/code&gt; 권한을 관리하기 위해 &lt;code&gt;/etc/sudoers&lt;/code&gt; 파일을 수정하다보면 실수로 파일이 깨지거나 문법에 맞지 않게 설정할 때도 있다. 이러면 아무리 &lt;code&gt;sudo&lt;/code&gt; 명령을 때려도 &lt;code&gt;/etc/sudoers&lt;/code&gt; 파일 parse error 라면서 아래와 같은 메시지를 던지게 된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;quot;/private/etc/sudoers: syntax error near line 28
sudo: parse error in /private/etc/sudoers near line 28
sudo: no valid shudders sources found, quitting
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;이 경우 root 로 로그인 하여 해당 파일을 수정하면 해결할 수 있다. 하지만, Ubuntu 의 경우 기본적으로 root 의 password 가 설정되어 있지 않기 때문에 별도로 root 를 활성화한 경우가 아니라면 낭패를 보기 쉽다.&lt;/p&gt;
&lt;p&gt;이 때, &lt;code&gt;pkexec&lt;/code&gt; 를 이용하여 &lt;code&gt;/etc/sudoers&lt;/code&gt; 파일을 수정할 수 있다.&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;pkexec&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;pkexec&lt;/code&gt; 의 man pages 에 다음과 같이 설명되어 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;pkexec allows an authorized user to execute PROGRAM as another user. If username is not specified, then the program will be executed as the administrative super user, root.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;즉, &lt;code&gt;pkexec&lt;/code&gt; 를 이용하면 &lt;code&gt;root&lt;/code&gt; 사용자로 실행할 수 있다:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pkexec vi /etc/sudoers
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;위 명령으로 &lt;code&gt;/etc/sudoers&lt;/code&gt; 파일을 수정하면 root 가 비활성화된 Ubuntu에서도 해결가능하다.&lt;/p&gt;</content><category term="linux"></category><category term="file"></category></entry><entry><title>Linux 에서 사용자 관리를 위한 명령어들</title><link href="https://imjang57.github.io/garret/linux-command-for-user-management.html" rel="alternate"></link><published>2017-01-01T00:00:00+09:00</published><updated>2017-05-08T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-01:/garret/linux-command-for-user-management.html</id><summary type="html">&lt;p&gt;Linux 에서 사용자 관리를 위한 명령어들(useradd, userdel, usermod, groupadd, groupdel, passwd, who, w, whoami, last, lastlog)&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Linux 에서 사용자 관리를 위한 명령어들&lt;/h1&gt;
&lt;p&gt;Linux 에서 사용자 추가, 사용자 정보 변경, 사용자 삭제, 그룹 추가, 그룹 삭제, 로그인한 사용자 정보 확인, 로그인 내역 확인 등을 위한 명령어들을 정리한 글이다.&lt;/p&gt;
&lt;h1&gt;Login message&lt;/h1&gt;
&lt;p&gt;각 명령어들에 대해 알아보기 전에 리눅스에 로그인 하면 여러 메시지들이 출력되는 시스템들이 있다. 시스템마다 내용이 다르게 출력되는데 이는 아래의 2가지 파일을 이용해서 만든 것이다. 참고용으로 알고 가자.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/etc/motd&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/etc/issue&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;참고로, motd 는 message of the day 를 의미한다.&lt;/p&gt;
&lt;h1&gt;Add new user&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;useradd&lt;/code&gt; 와 &lt;code&gt;adduser&lt;/code&gt; 2개의 명령어가 존재하는데 같은 거다. &lt;code&gt;adduser&lt;/code&gt; 는 사실 &lt;code&gt;useradd&lt;/code&gt; 의 symbolic link 이기 때문에 같은 명령어이다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;useradd&lt;/code&gt; 는 새로운 사용자를 추가하는 명령이다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;useradd&lt;/code&gt; 는 실행될 때 &lt;code&gt;/etc/default/useradd&lt;/code&gt; 파일과 &lt;code&gt;/etc/login.defs&lt;/code&gt; 파일을 참고하여 실행되기 때문에 두 파일의 내용에 따라 결과가 다르게 나타날 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/etc/default/useradd&lt;/code&gt; 파일:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# useradd defaults file
GROUP=100
HOME=/home
INACTIVE=-1
EXPIRE=
SHELL=/bin/bash
SKEL=/etc/skel
CREATE_MAIL_SPOOL=yes
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;예를 들면 &lt;code&gt;/etc/default/useradd&lt;/code&gt; 파일에 &lt;code&gt;SKEL&lt;/code&gt; 의 값으로 새로운 사용자의 Home directory 에 생성될 기본 파일들을 지정할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/etc/login.defs&lt;/code&gt; 파일:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;#
# Please note that the parameters in this configuration file control the
# behavior of the tools from the shadow-utils component. None of these
# tools uses the PAM mechanism, and the utilities that use PAM (such as the
# passwd command) should therefore be configured elsewhere. Refer to
# /etc/pam.d/system-auth for more information.
#

# *REQUIRED*
#   Directory where mailboxes reside, _or_ name of file, relative to the
#   home directory.  If you _do_ define both, MAIL_DIR takes precedence.
#   QMAIL_DIR is for Qmail
#
#QMAIL_DIR  Maildir
MAIL_DIR    /var/spool/mail
#MAIL_FILE  .mail

# Password aging controls:
#
#   PASS_MAX_DAYS   Maximum number of days a password may be used.
#   PASS_MIN_DAYS   Minimum number of days allowed between password changes.
#   PASS_MIN_LEN    Minimum acceptable password length.
#   PASS_WARN_AGE   Number of days warning given before a password expires.
#
PASS_MAX_DAYS   99999
PASS_MIN_DAYS   0
PASS_MIN_LEN    5
PASS_WARN_AGE   7

#
# Min/max values for automatic uid selection in useradd
#
UID_MIN                  1000
UID_MAX                 60000
# System accounts
SYS_UID_MIN               201
SYS_UID_MAX               999

#
# Min/max values for automatic gid selection in groupadd
#
GID_MIN                  1000
GID_MAX                 60000
# System accounts
SYS_GID_MIN               201
SYS_GID_MAX               999

#
# If defined, this command is run when removing a user.
# It should remove any at/cron/print jobs etc. owned by
# the user to be removed (passed as the first argument).
#
#USERDEL_CMD    /usr/sbin/userdel_local

#
# If useradd should create home directories for users by default
# On RH systems, we do. This option is overridden with the -m flag on
# useradd command line.
#
CREATE_HOME yes

# The permission mask is initialized to this value. If not specified, 
# the permission mask will be initialized to 022.
UMASK           077

# This enables userdel to remove user groups if no members exist.
#
USERGROUPS_ENAB yes

# Use SHA512 to encrypt password.
ENCRYPT_METHOD SHA512
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;/etc/login.defs&lt;/code&gt; 파일에도 여러 가지 값들이 있는데 &lt;code&gt;CREATE_HOME&lt;/code&gt; 값에 따라 &lt;code&gt;useradd&lt;/code&gt; 가 사용자 Home directory 를 생성할지 여부를 결정하게 된다. 만약 이 값이 &lt;code&gt;yes&lt;/code&gt; 면 자동으로 생성하고 &lt;code&gt;no&lt;/code&gt; 면 자동으로 생성하지 않도록 되어 &lt;code&gt;useradd -d &amp;lt;home path&amp;gt; &amp;lt;username&amp;gt; &amp;amp;&amp;amp; mkdir &amp;lt;home path&amp;gt;&lt;/code&gt; 와 같이 &lt;code&gt;-d&lt;/code&gt; 옵션을 주어 home directory 를 설정하고 home directory 를 직접 생성해주어야 한다.&lt;/p&gt;
&lt;h1&gt;Delete user&lt;/h1&gt;
&lt;p&gt;사용자를 삭제하려면 &lt;code&gt;userdel&lt;/code&gt; 명령을 사용하면 된다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;userdel &amp;lt;username&amp;gt;&lt;/code&gt; 을 실행하면 사용자를 삭제한다. 하지만 사용자의 home directory 는 삭제하지 않는다. home directory 도 같이 삭제하려면 &lt;code&gt;userdel -r &amp;lt;username&amp;gt;&lt;/code&gt; 과 같이 &lt;code&gt;-r&lt;/code&gt; 옵션을 전달하여 실행한다.&lt;/p&gt;
&lt;h1&gt;Change user account&lt;/h1&gt;
&lt;p&gt;사용자 정보를 변경하는 명령어는 &lt;code&gt;usermod&lt;/code&gt; 이다.&lt;/p&gt;
&lt;p&gt;사용자의 home directory 를 변경하려면 &lt;code&gt;usermod -d &amp;lt;path&amp;gt; &amp;lt;user&amp;gt;&lt;/code&gt; 를 실행한다.&lt;/p&gt;
&lt;p&gt;사용자의 group 을 변경하려면 &lt;code&gt;usermod -G &amp;lt;groupname&amp;gt;&lt;/code&gt; 을 실행한다. groupname 은 &lt;code&gt;,&lt;/code&gt; 로 구분되는 여러 group 들이 올 수 있다.&lt;/p&gt;
&lt;p&gt;만약 사용자의 group 을 기존 group 에 추가하려 하면 &lt;code&gt;usermod -aG &amp;lt;groupname&amp;gt;&lt;/code&gt; 을 실행한다.&lt;/p&gt;
&lt;p&gt;사용자의 prior group (initial login group) 을 변경하려면 &lt;code&gt;usermod -g &amp;lt;groupname&amp;gt;&lt;/code&gt; 을 실행한다. &lt;code&gt;-g&lt;/code&gt; 옵션을 사용하면 home directory 이하의 모든 파일들의 group 도 같이 변경된다. home directory 외부에 있는 파일들을 직접 변경해주어야 한다.&lt;/p&gt;
&lt;h1&gt;Change user password&lt;/h1&gt;
&lt;p&gt;사용자의 login password 를 변경하려면 &lt;code&gt;passwd&lt;/code&gt; 명령을 사용한다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;passwd &amp;lt;username&amp;gt;&lt;/code&gt; 을 실행하면 된다.&lt;/p&gt;
&lt;h1&gt;Group&lt;/h1&gt;
&lt;p&gt;새로운 group 을 추가하려면 &lt;code&gt;groupadd&lt;/code&gt; 명령어를 사용한다. &lt;code&gt;groupadd &amp;lt;groupname&amp;gt;&lt;/code&gt; 을 하면 새로운 group 이 생성된다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;groups&lt;/code&gt; 명령어를 사용하면 사용자의 group 목록을 알 수 있다. 그냥 &lt;code&gt;groups&lt;/code&gt; 를 실행하면 현재 로그인된 사용자의 group 목록을 확인할 수 있으며, 특정 사용자의 group 목록을 확인하려면 &lt;code&gt;groups &amp;lt;username&amp;gt;&lt;/code&gt; 을 실행한다.&lt;/p&gt;
&lt;p&gt;group 을 삭제하려면 &lt;code&gt;groupdel&lt;/code&gt; 명령을 사용한다.&lt;/p&gt;
&lt;h1&gt;Show user informations&lt;/h1&gt;
&lt;p&gt;사용자 정보와 관련된 여러 내용을 확인하는 명령어들이 있다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;whoami&lt;/code&gt;, &lt;code&gt;who am i&lt;/code&gt; 2가지 명령들은 다 같은 명령들인데 현재 로그인 중인 사용자를 보여준다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lastlog&lt;/code&gt; 는 각 사용자들 또는 특정 사용자가 최근에 언제 어디에서 로그인했는지 정보를 알려준다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;last&lt;/code&gt; 는 특정 사용자가 로그인 한 history 를 보여준다. &lt;code&gt;/var/log/wtmp&lt;/code&gt; 파일의 내용을 보여주는 명령이다. &lt;code&gt;/var/log/wtmp&lt;/code&gt; 파일은 Text 가 아니라 binary 이기 때문에 last 명령으로만 확인할 수 있다. &lt;code&gt;last [username]&lt;/code&gt; 과 같이 실행할 수 있는데, 만약 &lt;code&gt;last reboot&lt;/code&gt; 를 실행하면 시스템이 리부트된 내역을 보여준다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;who&lt;/code&gt;, 는 현재 누가 로그인한 상태인지를 보여준다. &lt;code&gt;who -H&lt;/code&gt; 와 같이 &lt;code&gt;-H&lt;/code&gt; 옵션을 주면 결과에 헤더도 붙일 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;w&lt;/code&gt; 는 현재 누가 로그인한 상태이고 어떤 작업을 하고 있는지를 보여준다. Terminal Type, FROM (remote host 의 IP address 또는 domain name), LOGIN@ (접속 시간), IDLE (최종 명령 후 대기 시간), WHAT (현재 사용 중인 Shell 이나 작업 등) 등을 출력한다.&lt;/p&gt;
&lt;h1&gt;Related files&lt;/h1&gt;
&lt;p&gt;Linux 에서 사용자 정보와 관련된 여러가지 파일들이 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/etc/passwd&lt;/code&gt; : User account information&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/etc/shadow&lt;/code&gt; : Secure user account information&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/etc/group&lt;/code&gt; : Group account information&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/etc/gshadow&lt;/code&gt; : Secure group account information&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/etc/login.defs&lt;/code&gt; : Shadow password suite configuration&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/etc/skel&lt;/code&gt; : Directory containing default files.&lt;/li&gt;
&lt;/ul&gt;</content><category term="linux"></category><category term="user"></category></entry></feed>