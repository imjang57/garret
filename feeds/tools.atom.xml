<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>garret - tools</title><link href="https://imjang57.github.io/garret/" rel="alternate"></link><link href="https://imjang57.github.io/garret/feeds/tools.atom.xml" rel="self"></link><id>https://imjang57.github.io/garret/</id><updated>2017-12-16T00:00:00+09:00</updated><entry><title>Git Submodule</title><link href="https://imjang57.github.io/garret/git-submodule.html" rel="alternate"></link><published>2017-12-16T00:00:00+09:00</published><updated>2017-12-16T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-12-16:/garret/git-submodule.html</id><summary type="html">&lt;p&gt;Git Submodule 사용법&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Git submodule&lt;/h1&gt;
&lt;p&gt;Git 서브모듈(Git submodule)은  Git 저장소(Git Repository)에 다른 Git 저장소를 포함시키기 위한 도구이다. 이렇게 다른 저장소를 저장소 내부에 추가하여도 각 저장소는 독립적으로 관리된다. 보통 서브모듈을 포함하는 저장소를 슈퍼프로젝트(Super-project)라고 한다.&lt;/p&gt;
&lt;h2&gt;Add submodule&lt;/h2&gt;
&lt;p&gt;서브모듈을 추가하려면 저장소에서 다음과 같이 실행하면 된다. 예를 들어 서브모듈로 추가하려는 저장소의 이름을 &lt;code&gt;yourtheme&lt;/code&gt; 라고 하자.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ git submodule add https://github.com/imjang57/yourtheme theme/yourtheme
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;theme/yourtheme&lt;/code&gt;에 서브모듈 저장소가 생성된다. 슈퍼프로젝트에서 &lt;code&gt;git status&lt;/code&gt; 명령을 실행하면 &lt;code&gt;.gitmodules&lt;/code&gt; 파일과 &lt;code&gt;theme/yourtheme&lt;/code&gt; 파일이 새로 생성된 것을 확인할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ git status
&lt;span class="c1"&gt;# On branch master&lt;/span&gt;
&lt;span class="c1"&gt;# Changes to be committed:&lt;/span&gt;
&lt;span class="c1"&gt;#   (use &amp;quot;git reset HEAD &amp;lt;file&amp;gt;...&amp;quot; to unstage)&lt;/span&gt;
&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;span class="c1"&gt;#      new file:   .gitmodules&lt;/span&gt;
&lt;span class="c1"&gt;#      new file:   theme/yourtheme&lt;/span&gt;
&lt;span class="c1"&gt;#&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;.gitmodules&lt;/code&gt; 파일의 내용은 다음과 같다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;[submodule &amp;quot;theme/yourtheme&amp;quot;]&lt;/span&gt;
    &lt;span class="na"&gt;path&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;theme/yourtheme&lt;/span&gt;
&lt;span class="s"&gt;    url = https://github.com/imjang57/yourtheme&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;그리고 &lt;code&gt;theme/yourtheme&lt;/code&gt; 파일을 확인하면 다음과 같이 출력된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ git diff --cached theme/yourtheme
diff --git a/theme/yourtheme b/theme/yourtheme
new file mode 160000
index 0000000..08d709f
--- /dev/null
+++ b/theme/yourtheme
@@ -0,0 +1 @@
+Subproject commit 08d709f78b8c5b0fbeb7821e37fa53e69afcf433
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;git diff&lt;/code&gt; 명령의 결과가 파일의 내용이 아니라 &lt;code&gt;Subproject commit 08d709f78b8c5b0fbeb7821e37fa53e69afcf433&lt;/code&gt; 와 같이 출력되는 것을 확인할 수 있다. 이것은 Git이 &lt;code&gt;theme/yourtheme&lt;/code&gt;를 서브모듈로 인식해서 서브모듈의 어느 커밋(commit)을 참조하고 있는지만 관리하기 때문이다. 또한, file mode 가 &lt;code&gt;160000&lt;/code&gt;으로 나오는 것을 확이할 수 있는데, 이는 일반적인 파일이나 디렉터리가 아니라는 의미이다.&lt;/p&gt;
&lt;p&gt;즉, 실제 작업 디렉터리(Working directory)에는 &lt;code&gt;theme/yourtheme&lt;/code&gt;라는 이름의 디렉터리가 있고, 그 안에 또 하나의 Git 저장소가 있다. 하지만 슈퍼프로젝트의 관점에서는 &lt;code&gt;theme/yourtheme&lt;/code&gt;는 서브모듈이기 때문에 참조하는 값만 관리하는 것이다.&lt;/p&gt;
&lt;p&gt;서브모듈을 추가하면 서브모듈 내에서 해당 프로젝트의 내용을 수정하고 커밋(commit)이나 푸시(push) 할 수도 있다. 즉, 서브모듈도 일반적인 다른 저장소와 똑같이 사용할 수 있다. 그리고 이렇게 서브모둘을 수정하면 수정된 서브모듈의 커밋 해시(commit hash)가 새롭게 슈퍼프로젝트에 저장된다. 따라서 슈퍼프로젝트도 커밋해주어야 이 변경된 참조가 저장된다.&lt;/p&gt;
&lt;h2&gt;서브모듈을 가진 저장소를 클론(clone)하기&lt;/h2&gt;
&lt;p&gt;서브모듈을 사용하는 프로젝트를 Clone하면 해당 서브모듈 디렉토리는 빈 디렉터리다. 이떄는 먼저 &lt;code&gt;git submodule init&lt;/code&gt; 명령으로 서브모듈을 초기화하고, &lt;code&gt;git submodule update&lt;/code&gt; 명령으로 서브모듈 저장소를 가져와야 한다. 이 때 슈퍼프로젝트에 저장된 커밋 해시값을 참고하여 각 서브모듈들을 체크아웃(checkout)한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ git submodule init
Submodule &lt;span class="s1"&gt;&amp;#39;theme/yourtheme&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;https://github.com/imjang57/yourtheme.git&lt;span class="o"&gt;)&lt;/span&gt; registered &lt;span class="k"&gt;for&lt;/span&gt; path &lt;span class="s1"&gt;&amp;#39;theme/yourtheme&amp;#39;&lt;/span&gt;
$ git submodule update
Cloning into &lt;span class="s1"&gt;&amp;#39;/home/imjang57/mysite/themes/yourtheme&amp;#39;&lt;/span&gt;...
Submodule path &lt;span class="s1"&gt;&amp;#39;themes/yourtheme&amp;#39;&lt;/span&gt;: checked out &lt;span class="s1"&gt;&amp;#39;08d709f78b8c5b0fbeb7821e37fa53e69afcf433&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Submodule Update&lt;/h2&gt;
&lt;p&gt;서브모듈을 최신 버전으로 업데이트하려면 서브모듈 디렉터리에서 &lt;code&gt;git fetch&lt;/code&gt; 명령을 실행하고 &lt;code&gt;git merge&lt;/code&gt; 명령으로 머지한다.&lt;/p&gt;
&lt;p&gt;이후 메인 프로젝트(슈퍼프로젝트)에서 &lt;code&gt;git diff --submodule&lt;/code&gt; 명령을 실행하면 업데이트된 서브모듈과 각 서브모듈에 추가된 커밋을 볼 수 있다. 이 상태에서 메인 프로젝트에서 &lt;code&gt;git commit&lt;/code&gt; 명령으로 커밋하면 변경된 서브모듈 내용(커밋 해시)이 메인 프로젝트에 적용된다.&lt;/p&gt;
&lt;p&gt;간단하게 이 작업을 하려면 &lt;code&gt;git submodule update --remote&lt;/code&gt; 명령을 실행한다. 이 명령을 실행하면 Git이 스스로 서브모듈을 Fetch하고 업데이트한다. 이 명령을 기본적으로 &lt;code&gt;master&lt;/code&gt; 브랜치를 체크아웃하고 업데이트를 수행한다. 브랜치를 바꾸려면 &lt;code&gt;.gitmodules&lt;/code&gt; 파일을 다음과 같이 수정한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;[submodule &amp;quot;theme/yourtheme&amp;quot;]&lt;/span&gt;
    &lt;span class="na"&gt;path&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;theme/yourtheme&lt;/span&gt;
&lt;span class="s"&gt;    url = https://github.com/imjang57/yourtheme&lt;/span&gt;
&lt;span class="s"&gt;    branch = stable&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;References&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;https://git-scm.com/book/en/v2/Git-Tools-Submodules&lt;/li&gt;
&lt;li&gt;https://git-scm.com/book/ko/v2/Git-도구-서브모듈&lt;/li&gt;
&lt;/ul&gt;</content><category term="git"></category></entry><entry><title>Vim Plugin</title><link href="https://imjang57.github.io/garret/vim-plugin.html" rel="alternate"></link><published>2017-05-05T00:00:00+09:00</published><updated>2017-05-05T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-05-05:/garret/vim-plugin.html</id><summary type="html">&lt;p&gt;Vim Plugin&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Vim Plugin&lt;/h1&gt;
&lt;p&gt;Vim 은 &lt;em&gt;Vim script&lt;/em&gt; 라는 자체 스크립트 언어를 제공하여 Plugin 을 만들 수 있게 한다. 이 스크립트들은 &lt;code&gt;plugin-name.vim&lt;/code&gt; 과 같이 vim 이라는 확장자(extension) 을 갖는다. &lt;em&gt;Vim script&lt;/em&gt; 는 &lt;a href="http://www.vim.org/scripts/index.php"&gt;Vim script page&lt;/a&gt; 에 많이 업로드되어 있다.&lt;/p&gt;
&lt;p&gt;환경 설정을 위해 사용되는 &lt;code&gt;.vimrc&lt;/code&gt; 파일도 사실은 &lt;em&gt;Vim script&lt;/em&gt; 이다.&lt;/p&gt;
&lt;p&gt;Vim plugin 은 2가지 종류가 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;filetype plugin : 특정 file type 에 대해서 동작하는 plugin. Default 로 &lt;code&gt;$VIMRUNTIME/ftplugin&lt;/code&gt; directory 에서 관리된다.&lt;/li&gt;
&lt;li&gt;global plugin : 모든 file type 에 대해서 동작하는 plugin. Default 로 &lt;code&gt;$VIMRUNTIME/plugin&lt;/code&gt; directory 에서 관리된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;각 plugin 의 위치가 &lt;code&gt;$VIMRUNTIME&lt;/code&gt; 밑에 꼭 있어야 하는 것은 아니다. Vim plugin 을 관리하는 plugin 을 설치하면 각자가 Runtime path 를 관리하여 &lt;code&gt;~/.vim/bundle&lt;/code&gt; 에 각 plugin 디렉터리를 생성하고 그 하위에 &lt;code&gt;ftplugin&lt;/code&gt; 과 &lt;code&gt;plugin&lt;/code&gt; 등 필요한 디렉터리들을 생성해서 사용하기도 한다.&lt;/p&gt;
&lt;h1&gt;Vundle&lt;/h1&gt;
&lt;p&gt;Vim plugin 을 관리하기 위한 여러 plugin 들이 있는데 나는 &lt;a href="https://github.com/VundleVim/Vundle.vim"&gt;Vundle&lt;/a&gt; 을 사용한다.&lt;/p&gt;
&lt;p&gt;자세한 내용은 &lt;a href="https://github.com/VundleVim/Vundle.vim"&gt;Vundle&lt;/a&gt; 에 가면 설치 방법부터 잘 나와있으니 참고하자.&lt;/p&gt;
&lt;p&gt;설치는 매우 쉽다. git clone 하여 &lt;code&gt;~/.vim/bundle/Vundle.vim&lt;/code&gt; 에 설치하고 &lt;code&gt;~/.vimrc&lt;/code&gt; 파일에 Vundle 을 위한 설정과 설치하여 사용할 Plugin 목록을 입력해주기만 하면 된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Vundle 은 인터넷을 통해 각 plugin 들을 받아서 &lt;code&gt;~/.vim/bundle&lt;/code&gt; 에 설치한다.&lt;/p&gt;
&lt;h2&gt;My &lt;code&gt;.vimrc&lt;/code&gt; including Vundle&lt;/h2&gt;
&lt;p&gt;아래 내용은 Vundle 과 Vundle 로 설치한 Plugin 들을 위한 &lt;code&gt;.vimrc&lt;/code&gt; 파일 내용이다. (기본적인 &lt;code&gt;.vimrc&lt;/code&gt; 파일 내용은 &lt;a href="https://imjang57.github.io/garret/vim-configuration.html"&gt;vim configuration&lt;/a&gt; 을 참고하자):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;
&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;Belows are Vundle Plugin configurations
filetype off

&amp;quot; set the runtime path to include Vundle and initialize
set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()
&amp;quot; alternatively, pass a path where Vundle should install plugins
&amp;quot;call vundle#begin(&amp;#39;~/some/path/here&amp;#39;)

&amp;quot; let Vundle manage Vundle, required
Plugin &amp;#39;VundleVim/Vundle.vim&amp;#39;

&amp;quot; The following are examples of different formats supported.
&amp;quot; Keep Plugin commands between vundle#begin/end.
&amp;quot; plugin on GitHub repo
&amp;quot;Plugin &amp;#39;tpope/vim-fugitive&amp;#39;
&amp;quot; plugin from http://vim-scripts.org/vim/scripts.html
&amp;quot;Plugin &amp;#39;L9&amp;#39;
&amp;quot; Git plugin not hosted on GitHub
&amp;quot;Plugin &amp;#39;git://git.wincent.com/command-t.git&amp;#39;
&amp;quot; git repos on your local machine (i.e. when working on your own plugin)
&amp;quot;Plugin &amp;#39;file:///home/gmarik/path/to/plugin&amp;#39;
&amp;quot; The sparkup vim script is in a subdirectory of this repo called vim.
&amp;quot; Pass the path to set the runtimepath properly.
&amp;quot;Plugin &amp;#39;rstacruz/sparkup&amp;#39;, {&amp;#39;rtp&amp;#39;: &amp;#39;vim/&amp;#39;}
&amp;quot; Install L9 and avoid a Naming conflict if you&amp;#39;ve already installed a
&amp;quot; different version somewhere else.
&amp;quot;Plugin &amp;#39;ascenator/L9&amp;#39;, {&amp;#39;name&amp;#39;: &amp;#39;newL9&amp;#39;}

Plugin &amp;#39;The-NERD-tree&amp;#39;
Plugin &amp;#39;AutoComplPop&amp;#39;
Plugin &amp;#39;majutsushi/tagbar&amp;#39;
Plugin &amp;#39;airblade/vim-gitgutter&amp;#39;
Plugin &amp;#39;vim-airline/vim-airline&amp;#39;
Plugin &amp;#39;vim-airline/vim-airline-themes&amp;#39;
Plugin &amp;#39;kien/ctrlp.vim&amp;#39;
Plugin &amp;#39;pathogen.vim&amp;#39;

let g:airline#extensions#tabline#enabled = 1

let NERDTreeWinPost = &amp;quot;left&amp;quot;

nmap &amp;lt;F6&amp;gt; :NERDTreeFind&amp;lt;CR&amp;gt;
nmap &amp;lt;F7&amp;gt; :NERDTree&amp;lt;CR&amp;gt;
nmap &amp;lt;F8&amp;gt; :TagbarToggle&amp;lt;CR&amp;gt;

filetype on

&amp;quot; All of your Plugins must be added before the following line
call vundle#end()            &amp;quot; required
filetype plugin indent on    &amp;quot; required
&amp;quot; To ignore plugin indent changes, instead use:
&amp;quot;filetype plugin on
&amp;quot;
&amp;quot; Brief help
&amp;quot; :PluginList       - lists configured plugins
&amp;quot; :PluginInstall    - installs plugins; append `!` to update or just
&amp;quot; :PluginUpdate
&amp;quot; :PluginSearch foo - searches for foo; append `!` to refresh local cache
&amp;quot; :PluginClean      - confirms removal of unused plugins; append `!` to
&amp;quot;auto-approve removal
&amp;quot;
&amp;quot; see :h vundle for more details or wiki for FAQ
&amp;quot; Put your non-Plugin stuff after this line

let g:ctrlp_custom_ignore = {
    \ &amp;#39;dir&amp;#39;: &amp;#39;\.git$\|vendor$&amp;#39;,
    \ &amp;#39;file&amp;#39;: &amp;#39;\v\.(exe|so|dll)$&amp;#39;
        \ }
&lt;/pre&gt;&lt;/div&gt;</content><category term="vim"></category></entry><entry><title>Vim Basic Regular Expression</title><link href="https://imjang57.github.io/garret/vim-basic-regular-expression.html" rel="alternate"></link><published>2017-05-04T00:00:00+09:00</published><updated>2017-05-07T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-05-04:/garret/vim-basic-regular-expression.html</id><summary type="html">&lt;p&gt;Vim 에서 사용가능한 정규표현식의 기본 사용법에 대한 글이다.&lt;/p&gt;</summary><content type="html">&lt;h1&gt;정규 표현식 (regular expression)&lt;/h1&gt;
&lt;p&gt;정규표현식이란 주로 문자열 내에서 검색이나 조작에 사용되는 표현식으로써 특정한 패턴을 가지고 그 패턴에 부합되는 문자열을 찾아내 원하는 일을 수행 할 수가 있다.&lt;/p&gt;
&lt;p&gt;정규표현식은 vim, sed, grep, emacs, perl 등 프로그램이나 프로그래밍 언어 등에서 문자열을 다루는 용도로 사용되고 있다.&lt;/p&gt;
&lt;p&gt;정규표현식이 쓰이는 모든 프로그램에서 동일한 문법으로 정규표현식을 규정하고 있지는 않는다. 기본적인 내용은 모두 같지만 약간의 표현 형식이 다르다. 즉, 이 글에 작성한 내용은 다른 프로그램이나 언어에서 사용하는 정규표현식과 다를 수 있다.&lt;/p&gt;
&lt;p&gt;Vim 의 &lt;code&gt;:help pattern&lt;/code&gt; 을 참고하자.&lt;/p&gt;
&lt;h1&gt;Basic Vim Regular Expression&lt;/h1&gt;
&lt;p&gt;여기에 나오는 정규표현식은 Vim 뿐만 아니라 Vim 의 전신인 Vi 에서도 사용되는 정규표현식이다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[ ]&lt;/code&gt; 안에는 알파벳이나 숫자가 올 수 있고 이 안에 나열되어 있는 문자 중 한 문자를 가리킨다. 즉 [abc] 는 검색에서 한 문자처럼 취급을 받는다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[abc]&lt;/code&gt; : a, b, c 문자 중 한 문자&lt;/li&gt;
&lt;li&gt;&lt;code&gt;b[abc]ll&lt;/code&gt; : ball, bbll, bcll 중 하나&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;[ ]&lt;/code&gt; 안에는 문자의 범위가 들어 갈 수도 있다. 대소문자를 구분하니 주의해야 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[a-z]&lt;/code&gt; : 소문자 a 부터 z 중 한 문자&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[a-f]&lt;/code&gt; : 소문자 a 부터 f 중 한 문자&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[0-9]&lt;/code&gt; : 숫자 0 부터 9 중 한 문자&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[A-Z0-9]&lt;/code&gt; : 대문자 A 부터 Z 와 숫자 0 부터 9 중 한 문자&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[A-Z][0-9][0-9]&lt;/code&gt; : 첫문자는 무조건 대문자로 시작하고 곧바로 숫자가 2자리 오는 패턴&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;정규표현식에서 &lt;code&gt;.&lt;/code&gt; 은 new line 을 제외한 모든 문자 하나를 가리킨다. 즉 알파벳, 공백과 같은 특수문자, 숫자 모두 &lt;code&gt;.&lt;/code&gt; 로 표현할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;a.d&lt;/code&gt; : &lt;code&gt;aad&lt;/code&gt;, &lt;code&gt;abd&lt;/code&gt;, &lt;code&gt;acd&lt;/code&gt;, &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;aed&lt;/code&gt;, ..., &lt;code&gt;a1d&lt;/code&gt;, &lt;code&gt;a2d&lt;/code&gt;, &lt;code&gt;a3d&lt;/code&gt;, ..., &lt;code&gt;a d&lt;/code&gt;, etc&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;^&lt;/code&gt; 가 &lt;code&gt;[ ]&lt;/code&gt; 안에 들어오면 안에 나열되어 있는 문자를 제외한 다른 모든 문자를 나타낸다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[^a-z]&lt;/code&gt; : 알파벳 소문자를 제외한 모든 문자&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;특수문자는 항상 &lt;code&gt;\&lt;/code&gt; 와 같이 쓰여야 문자 그대로의 의미를 나타낸다. 예를 들어, 공백(Space)는 &lt;code&gt;\&lt;/code&gt; 로 Space 앞에 &lt;code&gt;\&lt;/code&gt; 를 붙여주면 된다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;^&lt;/code&gt; 는 문자열의 가장 처음을 의미한다. Vim 에서 &lt;code&gt;/^The&lt;/code&gt; 로 검색을 하게 되면 줄의 맨 처음에 위치한 The 만 찾게 된다. &lt;code&gt;[ ]&lt;/code&gt; 내에 있던 &lt;code&gt;^&lt;/code&gt; 과 다른 의미이다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$&lt;/code&gt; 는 문자열의 가장 마지막을 의미한다. &lt;code&gt;/today$&lt;/code&gt; 로 검색하면 줄의 마지막에 위치한 today 만 찾게 된다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;*&lt;/code&gt; 는 0번 이상의 반복을 의미한다. 만약 단순히 &lt;code&gt;[a-z]*&lt;/code&gt; 라고 검색하게 되면 전체 문서가 선택된다. &lt;code&gt;*&lt;/code&gt; 는 0번 이상을 뜻하기 때문에 모든 문자들이 이 조건을 만족하게 된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;a*&lt;/code&gt; : null string, a, aa, aaa, aaaa, etc&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ab*&lt;/code&gt; : b 라는 문자가 없을 수도 있고 한번 이상 올 수도 있다. &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;ab&lt;/code&gt;, &lt;code&gt;abb&lt;/code&gt;, &lt;code&gt;abbb&lt;/code&gt;, &lt;code&gt;abbbb&lt;/code&gt;, etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Extended Vim Regular Expression&lt;/h1&gt;
&lt;p&gt;기존의 Vi 정규표현식만으로는 표현할 수 있는 패턴에 한계가 있어서 Vim 에서는 몇가지 패턴이 추가되었다. 사실 이 추가된 내용도 다른 대부분의 프로그램이나 언어에서 지원하는 정규표현식이다. 다만, 이 추가적인 정규표현식을 Vim 에서 사용하려면 정규표현식 문법을 위한 각 문자 앞에 &lt;code&gt;\&lt;/code&gt; 을 붙여야 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;+&lt;/code&gt; : 1번 이상&lt;/li&gt;
&lt;li&gt;&lt;code&gt;?&lt;/code&gt; : 0번 혹은 1번&lt;/li&gt;
&lt;li&gt;&lt;code&gt;( )&lt;/code&gt; : 여러 문자들을 group 으로 만듬&lt;/li&gt;
&lt;li&gt;&lt;code&gt;|&lt;/code&gt; : 논리연산자 or 와 같은 역할&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt; &amp;gt;&lt;/code&gt; : 문자열의 범위를 한정&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{n,m}&lt;/code&gt; : n번 이상 m 번 이하 반복 (matching 되는 가능한 긴 길이의 문자열을 나타냄)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{n}&lt;/code&gt; : n번 반복&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{n,}&lt;/code&gt; : n번 이상 반복 (matching 되는 가능한 긴 길이의 문자열을 나타냄)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{,m}&lt;/code&gt; : m번 이하 반복 (matching 되는 가능한 긴 길이의 문자열을 나타냄)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{}&lt;/code&gt; : 0번 이상 반복 (&lt;code&gt;*&lt;/code&gt; 와 같음)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{-n, m}&lt;/code&gt; : n번 이상 m 번 이하 반복 (matching 되는 가능한 짧은 길이의 문자열을 나타냄)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{-n}&lt;/code&gt; : n번 반복&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{-n,}&lt;/code&gt; : n번 이상 반복 (matching 되는 가능한 짧은 길이의 문자열을 나타냄)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{-,m}&lt;/code&gt; : m번 이하 반복 (matching 되는 가능한 짧은 길이의 문자열을 나타냄)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{-}&lt;/code&gt; : 0번 이상 반복&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;예를 들면 아래와 같이 사용할 수 있다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ab\+&lt;/code&gt; : 반드시 b 라는 문자가 한번 이상 와야 한다. &lt;code&gt;ab&lt;/code&gt;, &lt;code&gt;abb&lt;/code&gt;, &lt;code&gt;abbb&lt;/code&gt;, &lt;code&gt;abbbb&lt;/code&gt;, etc.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ab\?&lt;/code&gt; : a 뒤에 b가 올 수도 오지 않을 수 도 있다. &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;ab&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\(abc\)*&lt;/code&gt; : abc 문자열이 0번 이상 반복된다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\(abc\)\+&lt;/code&gt; : abc 문자열이 1번 이상 반복된다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DEB\|GIT&lt;/code&gt; : DEB 또는 GIT 을 찾는다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GIT\(HUB\|TER\)&lt;/code&gt; : GIT 으로 시작되고 HUB 또는 TER 가 이어지는 문자열을 검색한다. 즉, GITHUB, GITTER 가 검색된다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\&amp;lt;abc\&amp;gt;&lt;/code&gt; : 정확하게 abc 인 것만 찾는다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\&amp;lt;GIT\(HUB\|TER\)\&amp;gt;&lt;/code&gt; : 정확하게 GITHUB, GITTER 인 것만 검색한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;S\{2,4}&lt;/code&gt; : S 가 2번 이상 4번 이하 반복되는 문자열을 검색한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A.\{}A&lt;/code&gt; : ASSSSASSSSASSSASSSSSA 라는 문자열이 있으면 문자열 전체가 패턴 매치되는 하나의 결과가 된다. &lt;code&gt;A.*A&lt;/code&gt; 와 같다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A.\{-}A&lt;/code&gt; : ASSSSASSSSASSSASSSSSA 라는 문자열이 있으면 처음 ASSSSA 는 패턴 매치되는 하나의 결과, 그 다음 SSSS 는 매치 되지 않는 문자열, 그 다음 ASSSA 는 패턴 매치되는 하나의 결과, 그 다음 SSSSSA 는 매치 되지 않는 문자열이 된다. 즉, 매치되는 최소 길이의 문자열을 찾는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Replace&lt;/h1&gt;
&lt;p&gt;Vim 은 검색과 동시에 치환도 가능하다 : &lt;code&gt;:&amp;lt;시작줄 번호&amp;gt;,&amp;lt;끝 번호&amp;gt; s/검색어/바꿀단어/옵션&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:1,10 s/The/the/gc&lt;/code&gt; : 1번째 줄에서 10번째 줄 사이에 있는 "The" 라는 단어를 "the"로 치환&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;g&lt;/code&gt; 라는 옵션은 모든 검색어에 대해 변경을 실시하게 해준다. 만약 &lt;code&gt;g&lt;/code&gt; 옵션이 없을 경우 한 줄에 2 개 이상의 The 가 있을 경우 첫 번째 &lt;code&gt;The&lt;/code&gt; 만 &lt;code&gt;the&lt;/code&gt; 로 변경을 하게 된다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;c&lt;/code&gt; 라는 옵션은 치환이 발생할 때마다 정말 치환할 것인지를 묻는 prompt 를 출력한다.&lt;/p&gt;
&lt;p&gt;이외에 줄 번호를 가리키는 특별한 문자가 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.&lt;/code&gt; : 현재 커서가 놓여 있는 줄의 번호 &lt;/li&gt;
&lt;li&gt;&lt;code&gt;$&lt;/code&gt; : 마지막 줄&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:.,$ s/The/the/g&lt;/code&gt; : 현재에서 마지막 줄까지 모든 &lt;code&gt;The&lt;/code&gt; 를 &lt;code&gt;the&lt;/code&gt; 로 치환&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:1,$ s/\&amp;lt;be\&amp;gt;/BE/g&lt;/code&gt; : 모든 줄에서 다른 단어에 포함되지 않은 &lt;code&gt;be&lt;/code&gt; 라는 단어를 검색하여 대문자 &lt;code&gt;BE&lt;/code&gt; 로 변경&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;또는 아래와 같이 한번에 전체 문서에 대해서 치환을 수행할 수도 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:%s/The/the/g&lt;/code&gt; : 현재에서 마지막 줄까지 모든 &lt;code&gt;The&lt;/code&gt; 를 &lt;code&gt;the&lt;/code&gt; 로 치환. &lt;code&gt;:1,$ s/The/the/g&lt;/code&gt; 와 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;정규표현식과 변수&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;( )&lt;/code&gt; 는 문자열을 하나의 단위로 보게 하는 역할을 하였다. 하지만 치환에 사용 될 경우 변수 역할도 하게 된다.&lt;/p&gt;
&lt;p&gt;정규표현식 &lt;code&gt;([a-z]+) ([0-9]+)&lt;/code&gt; 를 만족하는 문자열 &lt;code&gt;abcd 100&lt;/code&gt; 가 있을 때, 정규표현식에서는 각 &lt;code&gt;( )&lt;/code&gt; 을 하나의 단위로 묶으면서 &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt; 와 같은 변수에 대응을 시킨다. 즉, 첫 번째 &lt;code&gt;( )&lt;/code&gt; 는 &lt;code&gt;1&lt;/code&gt; 이라는 변수에, 두 번째 &lt;code&gt;( )&lt;/code&gt; 는 &lt;code&gt;2&lt;/code&gt; 라는 변수에 저장된다.&lt;/p&gt;
&lt;p&gt;정규표현식의 변수와 Vim 의 치환을 사용하여 앞 뒤 순서를 바꿀 수 있다 : &lt;code&gt;:1,$ s/\([a-z]\+\)\( \+\)\([0-9]\+\)/321/g&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;s/.../.../g&lt;/code&gt; 와 같은 치환 형식에서 찾을 문자열 부분은 세 개의 &lt;code&gt;( )&lt;/code&gt; 로 이루어져 있어서 각각 변수 &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt; 에 저장된다. 그리고 치환할 문자열 부분에서 &lt;code&gt;321&lt;/code&gt; 과 같이 반대 순서로 변수를 나열하여 각 문자열들의 순서를 변경할 수 있게 된다.&lt;/p&gt;</content><category term="vim"></category></entry><entry><title>Vim Configuration</title><link href="https://imjang57.github.io/garret/vim-configuration.html" rel="alternate"></link><published>2017-05-04T00:00:00+09:00</published><updated>2017-05-05T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-05-04:/garret/vim-configuration.html</id><summary type="html">&lt;p&gt;Vim 설정&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Vim Configuration&lt;/h1&gt;
&lt;p&gt;Vim 은 실행 중에 여러 설정들을 필요에따라 바꿔서 사용할 수 있다. 그리고 설정 파일을 생성하여 원하는 설정을 적용할 수도 있다.&lt;/p&gt;
&lt;p&gt;Vim 설정 파일은 보통 &lt;code&gt;.vimrc&lt;/code&gt; 라는 이름으로 생성되는데, 사용자의 Home 밑에 &lt;code&gt;~/.vimrc&lt;/code&gt; 로 생성하면 Vim 이 자동으로 이 파일을 찾아서 파일이 있으면 파일의 내용을 확인하여 설정을 적용한다.&lt;/p&gt;
&lt;h2&gt;Key mapping&lt;/h2&gt;
&lt;p&gt;Vim 에서 Key mapping 할 때 &lt;code&gt;map&lt;/code&gt; 또는 &lt;code&gt;noremap&lt;/code&gt; 을 사용하게 된다.&lt;/p&gt;
&lt;p&gt;Vim 에서 &lt;code&gt;:map j gg&lt;/code&gt; 를 실행하면 &lt;code&gt;j&lt;/code&gt; 가 &lt;code&gt;gg&lt;/code&gt; 로 mapping 되어서 &lt;em&gt;Normal mode&lt;/em&gt; 에서 &lt;code&gt;j&lt;/code&gt; 를 입력하면 &lt;code&gt;gg&lt;/code&gt; 가 실행된다.&lt;/p&gt;
&lt;p&gt;만약 &lt;code&gt;:map j gg&lt;/code&gt;, &lt;code&gt;:map Q j&lt;/code&gt; 를 실행하면 &lt;code&gt;j&lt;/code&gt; 를 눌러도, &lt;code&gt;Q&lt;/code&gt; 를 눌러도 &lt;code&gt;gg&lt;/code&gt; 가 실행된다. &lt;code&gt;Q&lt;/code&gt; 가 &lt;code&gt;j&lt;/code&gt; 로 mapping 되고, 다시 &lt;code&gt;j&lt;/code&gt; 가 &lt;code&gt;gg&lt;/code&gt; 로 mapping 되는 것이다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;:map j gg&lt;/code&gt;, &lt;code&gt;:map Q j&lt;/code&gt;, &lt;code&gt;:map gg Q&lt;/code&gt; 와 같이 무한으로 재귀적으로 참조하게 되면 오류가 발생한다. &lt;code&gt;map&lt;/code&gt; 은 recursive key mapping 을 하기 때문이다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;:map&lt;/code&gt; 과 반대로 &lt;code&gt;:noremap&lt;/code&gt; 은 non-recursive key mapping 이다. &lt;code&gt;:map j gg&lt;/code&gt;, &lt;code&gt;:map Q j&lt;/code&gt;, &lt;code&gt;:map gg Q&lt;/code&gt; 를 해도 오류가 발생하지 않는다. &lt;code&gt;Q&lt;/code&gt; 를 누르면 &lt;code&gt;j&lt;/code&gt; 를 누른 것과 같다. 한 번 key mapping 하여 변환되면 끝이다.&lt;/p&gt;
&lt;p&gt;Vim 은 또한 각 mode 별로 key mapping 을 설정할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;nmap&lt;/code&gt; : display normal mode maps&lt;/li&gt;
&lt;li&gt;&lt;code&gt;imap&lt;/code&gt; : display insert mode maps&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vmap&lt;/code&gt; : display visual and select mode maps&lt;/li&gt;
&lt;li&gt;&lt;code&gt;smap&lt;/code&gt; : display select mode maps&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xmap&lt;/code&gt; : display visual mode maps&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cmap&lt;/code&gt; : display command-line mode maps&lt;/li&gt;
&lt;li&gt;&lt;code&gt;omap&lt;/code&gt; : display operator pending mode maps&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;예를 들어, &lt;code&gt;:nnoremap g gg&lt;/code&gt; 를 실행하면 &lt;em&gt;Normal mode&lt;/em&gt; 에서 &lt;code&gt;g&lt;/code&gt; 를 누르면 &lt;code&gt;gg&lt;/code&gt; 로 non-recursive mapping 을 한다.&lt;/p&gt;
&lt;p&gt;key mapping 을 할 때 특수 기능 키에 대해 mapping 을 하려면 아래 내용을 참고하여 mapping 하자.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;BS&amp;gt;&lt;/code&gt; : Backspace&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Tab&amp;gt;&lt;/code&gt; : Tab&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;CR&amp;gt;&lt;/code&gt; : Enter&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Enter&amp;gt;&lt;/code&gt; : Enter&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Return&amp;gt;&lt;/code&gt; : Enter&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Esc&amp;gt;&lt;/code&gt; : Escape&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Space&amp;gt;&lt;/code&gt; : Space&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Up&amp;gt;&lt;/code&gt; : Up arrow&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Down&amp;gt;&lt;/code&gt; : Down arrow&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Left&amp;gt;&lt;/code&gt; : Left arrow&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Right&amp;gt;&lt;/code&gt; : Right arrow&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;F1&amp;gt;&lt;/code&gt; - &lt;code&gt;&amp;lt;F12&amp;gt;&lt;/code&gt; : Function keys 1 to 12&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#1&lt;/code&gt;, &lt;code&gt;#2&lt;/code&gt; .. &lt;code&gt;#9&lt;/code&gt;, &lt;code&gt;#0&lt;/code&gt; : Function keys F1 to F9, F10&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Insert&amp;gt;&lt;/code&gt; : Insert&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Del&amp;gt;&lt;/code&gt; : Delete&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Home&amp;gt;&lt;/code&gt; : Home&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;End&amp;gt;&lt;/code&gt; : End&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;PageUp&amp;gt;&lt;/code&gt; : Page-Up&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;PageDown&amp;gt;&lt;/code&gt; : Page-Down&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;만약 &lt;code&gt;:imap ,&amp;lt;Space&amp;gt; &amp;lt;Space&amp;gt;&amp;lt;Space&amp;gt;&amp;lt;Space&amp;gt;&amp;lt;Space&amp;gt;&lt;/code&gt; 와 같이 key mapping 을 하면, &lt;code&gt;,&amp;lt;Space&amp;gt;&lt;/code&gt; 를 입력할 때마다 4개의 Space 가 입력된다.&lt;/p&gt;
&lt;p&gt;key mapping 에 대한 자세한 내용은 &lt;code&gt;:help key-mapping&lt;/code&gt; 또는 &lt;a href="http://vim.wikia.com/wiki/Mapping_keys_in_Vim_-_Tutorial_%28Part_1%29"&gt;Mapping keys in Vim - Tutorial (Part 1)&lt;/a&gt; 을 참고하자.&lt;/p&gt;
&lt;h2&gt;&lt;leader&gt; key&lt;/h2&gt;
&lt;p&gt;Vim 에는 leader key 가 있다. Default 로 &lt;code&gt;\&lt;/code&gt; 가 leader key 로 되어 있는데, 설정에서 이 leader key 를 이용하여 많은 작업들에 대한 단축키를 생성할 수 있다.&lt;/p&gt;
&lt;p&gt;예를 들어, &lt;code&gt;:map &amp;lt;leader&amp;gt;A g&lt;/code&gt; 를 실행하면  &lt;code&gt;\A&lt;/code&gt; 를 입력했을 때 &lt;code&gt;g&lt;/code&gt; 를 실행한 것과 같은 결과를 얻을 수 있게 된다. 이때 leader key 를 누른 후 1초 내에 다음 key 를 입력해야 한다.&lt;/p&gt;
&lt;p&gt;leader key 를 &lt;code&gt;,&lt;/code&gt; 로 변경하려면 &lt;code&gt;:let mapleader=","&lt;/code&gt; 를 실행한다.&lt;/p&gt;
&lt;h1&gt;My &lt;code&gt;.vimrc&lt;/code&gt; file&lt;/h1&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="c"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;Belows are basic vim configurations&lt;/span&gt;
&lt;span class="c"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;Refer `:help quickref` (quickref.txt)&lt;/span&gt;
&lt;span class="nb"&gt;syntax&lt;/span&gt; &lt;span class="k"&gt;on&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="k"&gt;nu&lt;/span&gt;                   &lt;span class="c"&gt;&amp;quot;line numbers&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;tabstop&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="m"&gt;4&lt;/span&gt;            &lt;span class="c"&gt;&amp;quot;tab stop&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;softtabstop&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="m"&gt;4&lt;/span&gt;        &lt;span class="c"&gt;&amp;quot;soft tabstop&lt;/span&gt;
&lt;span class="c"&gt;&amp;quot;set expandtab            &amp;quot;soft tab: fill tab with blank characters(space)&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;shiftwidth&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="m"&gt;4&lt;/span&gt;         &lt;span class="c"&gt;&amp;quot;tab stop for &amp;#39;&amp;gt;&amp;#39; command&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;autoindent&lt;/span&gt;           &lt;span class="c"&gt;&amp;quot;Auto indentation&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;cindent&lt;/span&gt;              &lt;span class="c"&gt;&amp;quot;The C programming language indentation&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;smartindent&lt;/span&gt;          &lt;span class="c"&gt;&amp;quot;smart autoindenting for C programs&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="k"&gt;history&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="m"&gt;100&lt;/span&gt;          &lt;span class="c"&gt;&amp;quot;remember work history&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;hlsearch&lt;/span&gt;             &lt;span class="c"&gt;&amp;quot;hilighting search word&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;showmatch&lt;/span&gt;            &lt;span class="c"&gt;&amp;quot;hilighting matched parentheses : (),{}&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;ruler&lt;/span&gt;                &lt;span class="c"&gt;&amp;quot;show current cursor&amp;#39;s location at lower right side&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;showmode&lt;/span&gt;             &lt;span class="c"&gt;&amp;quot;To be able to see what mode you are in.&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;laststatus&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;         &lt;span class="c"&gt;&amp;quot;always show status bar&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;nobackup&lt;/span&gt;             &lt;span class="c"&gt;&amp;quot;don&amp;#39;t create backup file&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;relativenumber&lt;/span&gt;
&lt;span class="c"&gt;&amp;quot;&amp;quot;set backup               &amp;quot;create backup file&lt;/span&gt;
&lt;span class="c"&gt;&amp;quot;set backupdir=~/vim/backup &amp;quot;set directory where backup file is saved&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;nocompatible&lt;/span&gt;         &lt;span class="c"&gt;&amp;quot;be improved, required&lt;/span&gt;
&lt;span class="k"&gt;colorscheme&lt;/span&gt; desert
&lt;span class="c"&gt;&amp;quot;colorscheme evening&lt;/span&gt;


&lt;span class="c"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="c"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;belows are settings for gvim running on high resolution&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;guifont&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;Consolas:h11:cANSI
&lt;span class="c"&gt;&amp;quot;set guifontwide=Dotumche:h11:cDEFAULT&lt;/span&gt;


&lt;span class="c"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="c"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;belows are encoding configurations&lt;/span&gt;
&lt;span class="c"&gt;&amp;quot;auto detected file encoding list which is used when vim opens file&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;fencs&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;utf&lt;span class="m"&gt;-8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;euc&lt;span class="p"&gt;-&lt;/span&gt;kr&lt;span class="p"&gt;,&lt;/span&gt;cp949&lt;span class="p"&gt;,&lt;/span&gt;cp932&lt;span class="p"&gt;,&lt;/span&gt;euc&lt;span class="p"&gt;-&lt;/span&gt;jp&lt;span class="p"&gt;,&lt;/span&gt;shift&lt;span class="p"&gt;-&lt;/span&gt;jis&lt;span class="p"&gt;,&lt;/span&gt;big5&lt;span class="p"&gt;,&lt;/span&gt;latin1&lt;span class="p"&gt;,&lt;/span&gt;ucs&lt;span class="m"&gt;-2&lt;/span&gt;le
&lt;span class="c"&gt;&amp;quot;Use command :set fileencoding=utf-8 when you change current file&amp;#39;s encoding&lt;/span&gt;


&lt;span class="c"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="c"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;belows are key mappings&lt;/span&gt;
&lt;span class="nb"&gt;nnoremap&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;leader&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;&lt;span class="k"&gt;q&lt;/span&gt; :&lt;span class="k"&gt;bp&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nb"&gt;nnoremap&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;leader&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;&lt;span class="k"&gt;w&lt;/span&gt; :&lt;span class="k"&gt;bn&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nb"&gt;nnoremap&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;silent&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;Leader&lt;span class="p"&gt;&amp;gt;+&lt;/span&gt; :exe &lt;span class="s2"&gt;&amp;quot;resize &amp;quot;&lt;/span&gt; . &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;winheight&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; * &lt;span class="m"&gt;3&lt;/span&gt;/&lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nb"&gt;nnoremap&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;silent&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;Leader&lt;span class="p"&gt;&amp;gt;-&lt;/span&gt; :exe &lt;span class="s2"&gt;&amp;quot;resize &amp;quot;&lt;/span&gt; . &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;winheight&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; * &lt;span class="m"&gt;2&lt;/span&gt;/&lt;span class="m"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Vim 일반 설정 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;set nocompatible&lt;/code&gt; : vi 호환성을 위한 기능을 사용하지 않는다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;syntax on&lt;/code&gt; : syntax highlighing 을 사용한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set nu&lt;/code&gt; : 왼쪽에 line number 를 보여준다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set tabstop=4&lt;/code&gt; : tab size 를 4로 지정한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set softtabstop=4&lt;/code&gt; : tab size 를 4로 지정한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set shiftwidth=4&lt;/code&gt; : tab size 를 4로 지정한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set expandtab&lt;/code&gt; : tag 을 space 로 사용하도록 한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set relativenumber&lt;/code&gt; : line number 를 현재 위치한 line 에서 상대적인 값으로 보여준다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set hlsearch&lt;/code&gt; : &lt;code&gt;/&lt;/code&gt; 로 검색할 때 검색된 문자열에 highlight 를 해준다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set ignorecase&lt;/code&gt; : &lt;code&gt;/&lt;/code&gt; 로 검색할 때 대소문자를 구분하지 않는다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set autoindent&lt;/code&gt; : 새로운 line 을 입력할 때 자동으로 indent 를 적용한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set cindent&lt;/code&gt; : 새로운 line 을 입력할 때 C style 의 indent 를 적용한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set smartindent&lt;/code&gt; : &lt;/li&gt;
&lt;li&gt;&lt;code&gt;set showmode&lt;/code&gt; : 현재 어떤 mode 인지를 status bar 에 보여준다.(NORMAL, INSERT, VISUAL, etc)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set nobackup&lt;/code&gt; : 파일을 열어서 buffer 를 생성할 때 backup 파일을 만들지 않는다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set ruler&lt;/code&gt; : 현재 cursor 의 위치를 하단에 있는 status bar 의 오른쪽에 보여준다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set history=100&lt;/code&gt; : 100 개의 work history 를 저장한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set showmatch&lt;/code&gt; : &lt;code&gt;(&lt;/code&gt; 와 &lt;code&gt;)&lt;/code&gt;, &lt;code&gt;{&lt;/code&gt; 와 &lt;code&gt;}&lt;/code&gt; 등 matched parentheses 에 hlghlight 적용한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set colorscheme evening&lt;/code&gt; : evening color theme 를 사용한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set fences=utf-8,euc-kr,cp949,latin1&lt;/code&gt; : vim 이 파일을 열 때 자동으로 인식할 file encoding 목록을 지정한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Vim key 설정 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;let mapleader = ","&lt;/code&gt; : leader key 를 '\' 에서 ',' 로 변경한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nnoremap &amp;lt;leader&amp;gt;q :bp&amp;lt;CR&amp;gt;&lt;/code&gt; : &lt;code&gt;&amp;lt;leader key&amp;gt; + q&lt;/code&gt; 를 누르면 previous buffer 로 이동한다. &lt;code&gt;:bp&lt;/code&gt; 명령과 같은 일을 한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nnoremap &amp;lt;leader&amp;gt;w :bn&amp;lt;CR&amp;gt;&lt;/code&gt; : &lt;code&gt;&amp;lt;leader key&amp;gt; + w&lt;/code&gt; 를 누르면 next buffer 로 이동한다. &lt;code&gt;:bn&lt;/code&gt; 명령과 같은 일을 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;References&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://jaeheeship.github.io/console/2013/11/15/vimrc-configuration.html"&gt;vim 설정파일 알아보기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://vim.wikia.com/wiki/Mapping_keys_in_Vim_-_Tutorial_%28Part_1%29"&gt;Mapping keys in Vim - Tutorial (Part 1)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="vim"></category></entry><entry><title>Vim Basics</title><link href="https://imjang57.github.io/garret/vim-basics.html" rel="alternate"></link><published>2017-05-03T00:00:00+09:00</published><updated>2017-05-04T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-05-03:/garret/vim-basics.html</id><summary type="html">&lt;p&gt;Vim 기본 사용법&lt;/p&gt;</summary><content type="html">&lt;h1&gt;VIM (VI Improved)&lt;/h1&gt;
&lt;p&gt;이 문서는 Vim 의 가장 기본적인 사용법을 정리한 문서이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Web page : http://www.vim.org&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CLI(Command Line Interface) 기반의 Text editor 이다. Linux, Mac, Windows 모두 지원한다. 처음 사용법이 익숙해지기가 어렵지만 한번 익히면 마우스 없이 대부분의 작업들을 빠르게 수행할 수 있다. 리눅스 서버는 대부분 CLI 환경만 제공되기 때문에 리눅스 서버 관리자라면 거의 필수로 익혀야 하는 Text editor 이다.&lt;/p&gt;
&lt;p&gt;Vimscript 라는 것을 작성하여 플러그인을 만들 수 있다. 사용법을 손에 익히고 여러 플러그인을 설치하면 왠만한 IDE 뺨치는 기능을 사용할 수 있다.&lt;/p&gt;
&lt;h1&gt;Vim modes&lt;/h1&gt;
&lt;p&gt;Vim 은 여러가지 모드를 제공한다. 대표적으로 사용되는 모드는 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Normal mode&lt;/em&gt; : where you can execute commands. This is default mode in which Vim starts up.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Insert mode&lt;/em&gt; : where you are simply writing text.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Visual mode&lt;/em&gt; : where you visually select a bunch of text so that you can run a command or operation only on that part of the text.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Vim 을 실행하면 가장 먼저 &lt;em&gt;Normal mode&lt;/em&gt; 상태로 실행된다. 다른 모드에서 &lt;code&gt;ESC&lt;/code&gt; 를 입력하면 &lt;em&gt;Normal mode&lt;/em&gt; 로 돌아온다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Normal mode&lt;/em&gt; 에서 &lt;code&gt;:&lt;/code&gt; 를 입력하면 Command 를 입력할 수 있다. 보통 Command 를 실행할 때 2가지 방법으로 하게 되는데 하나는 &lt;code&gt;:&lt;/code&gt; 를 입력한 후 Command 를 직접 입력하는 것이고, 다른 하나는 단축키를 사용하는 것이다. 2가지 모두 많이 사용되는 방법이다.&lt;/p&gt;
&lt;p&gt;커서 이동, put, yank, delete, search, replace, 기타 등등 대부분의 작업은 &lt;em&gt;Normal mode&lt;/em&gt; 에서 실행된다.&lt;/p&gt;
&lt;h1&gt;Help page&lt;/h1&gt;
&lt;p&gt;Vim 은 기본적으로 built-in help documentation 을 내장하고 있어서 작업 도중에 수시로 help documentation 을 참고할 수 있다.&lt;/p&gt;
&lt;p&gt;Normal mode 에서 &lt;code&gt;:help&lt;/code&gt; command 를 실행하면 확인할 수 있다. 자주 보게 되는 help 내용은 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:help [keyword]&lt;/code&gt; : shows documentation [for keyword]&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:help abbreviation&lt;/code&gt; : help for abbreviations&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:help quickref&lt;/code&gt; : Quick Reference&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:help user-manual&lt;/code&gt; : User Manuals&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;만약 플러그인을 설치할 때 플러그인이 help 를 제공하면 해당 플러그인의 help 문서도 확인가능하다.&lt;/p&gt;
&lt;h1&gt;Switching between modes&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Normal mode&lt;/em&gt; --(&lt;code&gt;i&lt;/code&gt;, &lt;code&gt;I&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;o&lt;/code&gt;, &lt;code&gt;O&lt;/code&gt;, &lt;code&gt;r&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt;)--&amp;gt; Insert mode&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Normal mode&lt;/em&gt; --(&lt;code&gt;v&lt;/code&gt;, &lt;code&gt;V&lt;/code&gt;)--&amp;gt; Visual mode&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Insert mode&lt;/em&gt; --(&lt;code&gt;ESC&lt;/code&gt;)--&amp;gt; Normal mode&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Visual mode&lt;/em&gt; --(&lt;code&gt;ESC&lt;/code&gt;)--&amp;gt; Normal mode&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Move cursor&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;move left / up / right / down : &lt;code&gt;h&lt;/code&gt; / &lt;code&gt;j&lt;/code&gt; / &lt;code&gt;k&lt;/code&gt; / &lt;code&gt;l&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;move left / up / right / down 3 times repeatedly : &lt;code&gt;3h&lt;/code&gt; / &lt;code&gt;3j&lt;/code&gt; / &lt;code&gt;3k&lt;/code&gt; / &lt;code&gt;3l&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;move the cursor to the next word : &lt;code&gt;w&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;move the cursor to the previous word : &lt;code&gt;b&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;go to specific line number : &lt;code&gt;&amp;lt;line-number&amp;gt;G&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;go to head of line : &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;go to tail of line : &lt;code&gt;$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;page up / down : &lt;code&gt;ctrl + b&lt;/code&gt; / &lt;code&gt;ctrl + f&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;page up / down half : &lt;code&gt;ctrl + d&lt;/code&gt; / &lt;code&gt;ctrl + u&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;jump to start of file : &lt;code&gt;gg&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;jump to end of file : &lt;code&gt;G&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;jump to top / bottom / middle of window : &lt;code&gt;H&lt;/code&gt; / &lt;code&gt;L&lt;/code&gt; / &lt;code&gt;M&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;move to previous / next sentence : &lt;code&gt;(&lt;/code&gt; / &lt;code&gt;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;move to previous / next paragraph : &lt;code&gt;{&lt;/code&gt; / &lt;code&gt;}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Editing&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;insert before the curosr : &lt;code&gt;i&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;insert at the beginning of the line : &lt;code&gt;I&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;insert (append) after the cursor : &lt;code&gt;a&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;insert (append) at the End of the line : &lt;code&gt;A&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;append (open) a new line below the current line : &lt;code&gt;o&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;append (open) a new line above the current line : &lt;code&gt;O&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;replace a single character : &lt;code&gt;r&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;replace from current cursor : &lt;code&gt;R&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;join line below to the current one : &lt;code&gt;J&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;exit &lt;em&gt;Insert mode&lt;/em&gt; (swith to &lt;em&gt;Normal mode&lt;/em&gt;) : &lt;code&gt;ESC&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Open and Close file&lt;/h1&gt;
&lt;p&gt;Vim 에서 파일을 열면 &lt;em&gt;buffer&lt;/em&gt; 라는 것을 생성하여 파일의 내용을 메모리에 올린 후 작업을 수행하게 된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Open file (buffer) : &lt;code&gt;:e &amp;lt;path&amp;gt;&lt;/code&gt;, &lt;code&gt;:edit &amp;lt;path&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Save file (buffer) : &lt;code&gt;:w&lt;/code&gt;, &lt;code&gt;:write&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Save file (buffer) as : &lt;code&gt;:saveas &amp;lt;path&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Close file (buffer) : &lt;code&gt;:bd&lt;/code&gt;, &lt;code&gt;:bw&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Quit Vim : &lt;code&gt;:q&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Print Working Directory : &lt;code&gt;:pwd&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Print path of current file : &lt;code&gt;:echo @%&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Print absolute path of current file : &lt;code&gt;echo expand('%:p')&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Use Mark&lt;/h1&gt;
&lt;p&gt;Vim 에서 &lt;em&gt;buffer&lt;/em&gt; 의 특정 위치를 alphabet(a-zA-Z) 으로 마킹할 수 있다. 자세한 내용은 &lt;code&gt;:help mark&lt;/code&gt; 와 &lt;code&gt;:help mark-motions&lt;/code&gt; help page 를 참고하자.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mark current location as a : &lt;code&gt;ma&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;goto mark a : &lt;code&gt;'a&lt;/code&gt; (cursor located on first non-blank character), `a (cursor located on marked character)&lt;/li&gt;
&lt;li&gt;list of marks : &lt;code&gt;:marks&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Abbreviation&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;set abbreviation foo with foooo : &lt;code&gt;:ab foo foooo&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;unset abbreviation foo : &lt;code&gt;:unab foo&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;위의 예의 경우, &lt;em&gt;Insert mode&lt;/em&gt;  에서 foo 와 &lt;SPACEBAR|ENTER&gt; 를 입력하면 foooo 가 입력된다.&lt;/p&gt;
&lt;h1&gt;Cut (Delete), Copy (Yank) and Paste (Put)&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;cut (delete) word : &lt;code&gt;dw&lt;/code&gt; (start from cursor), &lt;code&gt;daw&lt;/code&gt; (whole word)&lt;/li&gt;
&lt;li&gt;cut (delete) current line : &lt;code&gt;dd&lt;/code&gt;, &lt;code&gt;:d&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;cut (delete) 4 lines : &lt;code&gt;4dd&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;cut (delete) to the end of the line : &lt;code&gt;d$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;cut (delete) from cursor to end of current line : &lt;code&gt;D&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;cut (delete) one character of cursor : &lt;code&gt;x&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;cut (delete) one character before cursor : &lt;code&gt;X&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;cut (delete) 3 character of cursor : &lt;code&gt;3x&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;cut (delete) 3 character before cursor : &lt;code&gt;3X&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;cut (delete) lines from 4 to 10 inclusive : &lt;code&gt;:4,10d&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;copy (yank) word : &lt;code&gt;yw&lt;/code&gt; (start from cursor), &lt;code&gt;yaw&lt;/code&gt; (whole word)&lt;/li&gt;
&lt;li&gt;copy (yank) current line : &lt;code&gt;yy&lt;/code&gt;, &lt;code&gt;Y&lt;/code&gt;, &lt;code&gt;:y&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;copy (yank) 4 lines : &lt;code&gt;4yy&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;copy (yank) lines from 4 to 10 inclusive : &lt;code&gt;:4,10y&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;paste (put) at after current : &lt;code&gt;p&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;paste (put) at before current : &lt;code&gt;P&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;cut (delete) from current line to end of text : &lt;code&gt;dG&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;cut (delete) from current line to start of text : &lt;code&gt;dgg&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Undo and Redo&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;undo : &lt;code&gt;u&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;redo : &lt;code&gt;ctrl + r&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Select&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;swith to visual mode to select texts : &lt;code&gt;v&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;swith to visual mode to select line by line : &lt;code&gt;V&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;swith to visual mode to select vertical : &lt;code&gt;Ctrl + v&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can select texts in visual mode using vi move keys such as &lt;code&gt;h&lt;/code&gt;, &lt;code&gt;j&lt;/code&gt;, &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;l&lt;/code&gt;, &lt;code&gt;G&lt;/code&gt;, &lt;code&gt;gg&lt;/code&gt;, &lt;code&gt;w&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;H&lt;/code&gt;, &lt;code&gt;L&lt;/code&gt;, &lt;code&gt;M&lt;/code&gt;, etc. After selection, you can use &lt;code&gt;d&lt;/code&gt; for cut, &lt;code&gt;y&lt;/code&gt; for copy, etc.&lt;/p&gt;
&lt;h1&gt;Search&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;search text : &lt;code&gt;/searchtext&lt;/code&gt; in &lt;em&gt;Normal mode&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you want to search text &lt;em&gt;Hotkeys&lt;/em&gt;, input &lt;code&gt;/Hotkeys&lt;/code&gt;. Searching text is case-sensitive. If you want to ignore case, input &lt;code&gt;:set ignorecase&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;After run &lt;code&gt;/searchtext&lt;/code&gt; command, you can move to next and previous occurrence by &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Vim provide incremental search. This is helpful when you know only a part of the phrase. After &lt;code&gt;:set incsearch&lt;/code&gt;, vim will start searching by everytime you type.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;searchtext&lt;/code&gt; can be regular expression. For example:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;delete lines which are matched to pattern : &lt;code&gt;:g/pattern/d&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;delete empty lines : &lt;code&gt;:g/^$/d&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;delete lines which are include hello : &lt;code&gt;:g/hello/d&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Macro&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;record macro as a : &lt;code&gt;qa&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;stop recording macro : &lt;code&gt;q&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;run macro a : &lt;code&gt;@a&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;rerun last run macro : &lt;code&gt;@@&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;References&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://vim.rtorr.com/"&gt;Vim Cheat Sheet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/rtorr/vim-cheat-sheet"&gt;Vim Cheat Sheet Github&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="vim"></category></entry><entry><title>Vim Basics More</title><link href="https://imjang57.github.io/garret/vim-basics-more.html" rel="alternate"></link><published>2017-05-03T00:00:00+09:00</published><updated>2017-05-04T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-05-03:/garret/vim-basics-more.html</id><summary type="html">&lt;p&gt;Vim 기본 사용법에 대해 더 알면 좋은 내용들에 대한 글이다.&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Vim Basics More&lt;/h1&gt;
&lt;p&gt;Vim 에 대해 추가적으로 알면 좋은 내용들에 대해 정리한 글이다.&lt;/p&gt;
&lt;h1&gt;&lt;em&gt;buffer&lt;/em&gt;, &lt;em&gt;window&lt;/em&gt;, &lt;em&gt;tab&lt;/em&gt;&lt;/h1&gt;
&lt;p&gt;Vim 에서 &lt;em&gt;buffer&lt;/em&gt;  는 열려 있는 파일(file which is opened)를 뜻한다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;window&lt;/em&gt; 는 Vim 이 어떤 것을 출력하기 위한 component 로 &lt;em&gt;buffer&lt;/em&gt; 를 출력하는 방법이다. 사실 Vim 의 &lt;em&gt;buffer&lt;/em&gt; 는 text 만 출력할 수 있는 것이 아니다. Vim 화면을 가로나 세로로 분할하면 이 &lt;em&gt;windows&lt;/em&gt; 가 새로 만들어 지고 각 &lt;em&gt;window&lt;/em&gt; 에 &lt;em&gt;buffer&lt;/em&gt; 가 출력된다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;tab&lt;/em&gt; 은 Vim 의 Layout 이다. 여러 &lt;em&gt;windows&lt;/em&gt; 들의 집합이다. 대부분의 Text editor 나 Internet browser 에서 사용하는 tab 과는 개념이 다르다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A buffer is the in-memory text of a file.&lt;/li&gt;
&lt;li&gt;A window is a viewport on a buffer.&lt;/li&gt;
&lt;li&gt;A tab page is a collection of windows.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;대충 간략하게 정리하면 파일은 &lt;em&gt;buffer&lt;/em&gt; 에 로드되고, &lt;em&gt;buffer&lt;/em&gt; 는 &lt;em&gt;window&lt;/em&gt; 에 의해 출력되고, &lt;em&gt;window&lt;/em&gt; 는 &lt;em&gt;tab&lt;/em&gt; 에 의해 layout 이 결정된다.&lt;/p&gt;
&lt;h2&gt;Vim &lt;em&gt;buffer&lt;/em&gt; management&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;list of current buffers : &lt;code&gt;:ls&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;open new file (buffer) : &lt;code&gt;:e &amp;lt;path&amp;gt;&lt;/code&gt;, &lt;code&gt;:edit &amp;lt;path&amp;gt;&lt;/code&gt; (with enhanced tab completion (put set wildmenu in your .vimrc))&lt;/li&gt;
&lt;li&gt;save file (buffer) : &lt;code&gt;:w&lt;/code&gt;, &lt;code&gt;:write&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;close file (buffer) : &lt;code&gt;:bd&lt;/code&gt;, &lt;code&gt;:bw&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;switch between all open files (buffers) : &lt;code&gt;:b&amp;lt;buffer number&amp;gt;&lt;/code&gt; (&lt;code&gt;:b#&lt;/code&gt; chooses the last visited file)&lt;/li&gt;
&lt;li&gt;previous buffer : &lt;code&gt;:bp&lt;/code&gt;, &lt;code&gt;:bprevious&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;next buffer : &lt;code&gt;:bn&lt;/code&gt;, &lt;code&gt;:bnext&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;delete buffer : &lt;code&gt;:bd [buffer numbers...]&lt;/code&gt;, &lt;code&gt;:bw&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Close all buffer : &lt;code&gt;:%bd&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Close buffer from buffer number 1 to 1000 : &lt;code&gt;:1,1000bd&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;:ls&lt;/code&gt; 를 실행하면 Vim 의 하단에 다음과 같이 현재 열려진 &lt;em&gt;buffer&lt;/em&gt; 들을 보여준다. 아래 화면에서 &lt;em&gt;buffer&lt;/em&gt; 를 선택하여 이동할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;1 %a   &amp;quot;./checkin.pl&amp;quot;            line 1
2 #    &amp;quot;./grabakamailogs.pl&amp;quot;     line 1
3      &amp;quot;./grabwmlogs.pl&amp;quot;         line 0
  etc.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;%&lt;/code&gt; 는 현재 편집 중인 &lt;em&gt;buffer&lt;/em&gt; (current buffer) 를 참조한다. &lt;code&gt;#&lt;/code&gt; 는 직전에 편집하던 &lt;em&gt;buffer&lt;/em&gt; (alternative buffer) 를 참조한다. &lt;code&gt;ctrl + shift + 6&lt;/code&gt; 를 실행하면 두 &lt;em&gt;buffer&lt;/em&gt; 사이를 switch 한다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;e &amp;lt;path&amp;gt;&lt;/code&gt; 를 실행하면 새로운 &lt;em&gt;buffer&lt;/em&gt; 를 만들고 전달 받은 파일의 내용을 로드한다. &lt;code&gt;:e foo.txt bar.txt&lt;/code&gt;, &lt;code&gt;e /foo/bar/*.txt&lt;/code&gt; 와 같이 한 번에 여러 &lt;em&gt;buffer&lt;/em&gt; 를 생성하지는 못한다. 만약, 여러 파일을 한 번에 열고 싶으면 처음에 Vim 을 실행할 때 &lt;code&gt;Vim file1.txt file2.txt&lt;/code&gt; 와 같이 실행하면 된다. 아니면 &lt;code&gt;arga [paths...]&lt;/code&gt; 를 실행하면 여러 파일들로 새로운 &lt;em&gt;buffer&lt;/em&gt; 를 생성하고 대신 새로운 &lt;em&gt;buffer&lt;/em&gt; 로 switch 를 하지는 않는다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;:arga foo.txt bar.txt
:argadd /foo/bar/*.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Install &lt;em&gt;BufOnly&lt;/em&gt; plugin&lt;/h2&gt;
&lt;p&gt;Vim 으로 &lt;em&gt;buffer&lt;/em&gt; 를 사용하다보면 불편할 때가 있는데, 예를 들면 지금 편집중인 &lt;em&gt;buffer&lt;/em&gt; 를 빼고 나머지 &lt;em&gt;buffer&lt;/em&gt; 들을 모두 닫고 싶을 때이다. &lt;code&gt;:ls&lt;/code&gt; 로 현재 생성되어 있는 &lt;em&gt;buffer&lt;/em&gt; 를 확인하고 &lt;code&gt;bd &amp;lt;buffer number&amp;gt;&lt;/code&gt; 로 일일이 하나씩 &lt;em&gt;buffer&lt;/em&gt; 를 삭제해야 한다. 그래서 나는 &lt;em&gt;BufOnly&lt;/em&gt; 라는 plugin 을 설치해서 사용한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Download &lt;code&gt;BufOnly.vim&lt;/code&gt; Vimscript at &lt;a href="http://www.vim.org/scripts/script.php?script_id=1071"&gt;BufOnly page&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Goto &lt;code&gt;$VIMRUNTIME&lt;/code&gt; : &lt;code&gt;:echo $VIMRUNTIME&lt;/code&gt;, &lt;code&gt;:!explorer $VIMRUNTIME&lt;/code&gt; in Vim.&lt;/li&gt;
&lt;li&gt;Copy downloaded &lt;code&gt;BufOnly.vim&lt;/code&gt; to &lt;code&gt;$VIMRUNTIME&lt;/code&gt; directory or &lt;code&gt;~/.vim/plugin/BufOnly.vim&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Restart Vim&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;참고로 &lt;code&gt;$VIMRUNTIME&lt;/code&gt; 은 Vim 실행 후 &lt;em&gt;Normal mode&lt;/em&gt; 에서 &lt;code&gt;:echo $VIMRUNTIME&lt;/code&gt; 으로 확인할 수 있으며 Vim 이 실행되는 root path 이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;close buffers : &lt;code&gt;:BufOnly [buffer number]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Vim &lt;em&gt;window&lt;/em&gt; management&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;split window horizontal : &lt;code&gt;:sp [path]&lt;/code&gt;, &lt;code&gt;:split [path]&lt;/code&gt;, &lt;code&gt;Ctrl + w, s&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;split window vertical : &lt;code&gt;vs [path]&lt;/code&gt;, &lt;code&gt;:vertical split [path]&lt;/code&gt;, &lt;code&gt;Ctrl + w, v&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;resize all windows same : &lt;code&gt;Ctrl - w, =&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;resize horizontal : &lt;code&gt;:resize 60&lt;/code&gt;, &lt;code&gt;:res 60&lt;/code&gt;, &lt;code&gt;:resize +5&lt;/code&gt;, &lt;code&gt;:res +5&lt;/code&gt;, &lt;code&gt;:resize -5&lt;/code&gt;, &lt;code&gt;:res -5&lt;/code&gt;, &lt;code&gt;ctrl + w, +&lt;/code&gt;, &lt;code&gt;ctrl + w, -&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;resize vertical :  &lt;code&gt;:vertical resize 60&lt;/code&gt;, &lt;code&gt;:vertical res 60&lt;/code&gt;, &lt;code&gt;:vertical resize +5&lt;/code&gt;, &lt;code&gt;:vertical res +5&lt;/code&gt;, &lt;code&gt;:vertical resize -5&lt;/code&gt;, &lt;code&gt;:vertical res -5&lt;/code&gt;, &lt;code&gt;ctrl + w, &amp;gt;&lt;/code&gt;, &lt;code&gt;ctrl + w, &amp;lt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;switch between splitscreens : &lt;code&gt;ctrl + w, arrow key&lt;/code&gt;, &lt;code&gt;ctrl + w, &amp;lt;h|j|k|l&amp;gt;&lt;/code&gt;, &lt;code&gt;ctrl + w, n&lt;/code&gt;, &lt;code&gt;ctrl + w, p&lt;/code&gt;, &lt;code&gt;ctrl + w, w&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;close the current window : &lt;code&gt;ctrl + w, c&lt;/code&gt;, &lt;code&gt;:q&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;close all windows except the current one : &lt;code&gt;ctrl + w, o&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To resize in different steps, you can create maps that will adjust the window size differently. For example to increase the window size by a factor of 1.5 and decrease the window size by 0.67, you can map this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;nnoremap &amp;lt;silent&amp;gt; &amp;lt;Leader&amp;gt;+ :exe &amp;quot;resize &amp;quot; . (winheight(0) * 3/2)&amp;lt;CR&amp;gt;
nnoremap &amp;lt;silent&amp;gt; &amp;lt;Leader&amp;gt;- :exe &amp;quot;resize &amp;quot; . (winheight(0) * 2/3)&amp;lt;CR&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Vim &lt;em&gt;tab&lt;/em&gt; management&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;add new tab : &lt;code&gt;:tabe &amp;lt;path&amp;gt;&lt;/code&gt;, &lt;code&gt;:tabedit &amp;lt;path&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;add buffer to tab : &lt;code&gt;:&amp;lt;tab number&amp;gt;tabe &amp;lt;path&amp;gt;&lt;/code&gt;, &lt;code&gt;:&amp;lt;tab number&amp;gt;tabedit &amp;lt;path&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;close tab : &lt;code&gt;:tabc&lt;/code&gt;, &lt;code&gt;:tabclose&lt;/code&gt;, &lt;code&gt;:&amp;lt;tab number&amp;gt;tabc&lt;/code&gt;, &lt;code&gt;:&amp;lt;tab number&amp;gt;tabclose&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;switch between tabs : &lt;code&gt;:tabn&lt;/code&gt;, &lt;code&gt;:tabnext&lt;/code&gt;, &lt;code&gt;:tabp&lt;/code&gt;, &lt;code&gt;:tabprevious&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;switch to next tab by number : &lt;code&gt;gt&lt;/code&gt;, &lt;code&gt;&amp;lt;number&amp;gt;gt&lt;/code&gt;, &lt;code&gt;ctrl + PageDown&lt;/code&gt;, &lt;code&gt;&amp;lt;number&amp;gt;ctrl + PageDown&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;switch to previous tab by number : &lt;code&gt;gT&lt;/code&gt;, &lt;code&gt;&amp;lt;number&amp;gt;gT&lt;/code&gt;, &lt;code&gt;ctrl + PageUp&lt;/code&gt;, &lt;code&gt;&amp;lt;number&amp;gt;ctrl + PageUp&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;go to tab : &lt;code&gt;:tabmove &amp;lt;tab number&amp;gt;&lt;/code&gt;, &lt;code&gt;:tabm &amp;lt;tab number&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you map &lt;code&gt;:tabn&lt;/code&gt; and &lt;code&gt;:tabp&lt;/code&gt; to your &lt;code&gt;F7&lt;/code&gt; and &lt;code&gt;F8&lt;/code&gt; keys you can easily switch between files.&lt;/p&gt;
&lt;h1&gt;Selection&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;- select : &lt;code&gt;v, [h|j|k|l|g|G|...]&lt;/code&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;- select vertical : &lt;code&gt;ctrl + v, [h|j|k|l|g|G|...]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1&gt;Indentation&lt;/h1&gt;
&lt;p&gt;In command mode,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;indent current line by shiftwidth spaces : &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;:&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;de-indent current line by shiftwidth spaces : &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;:&amp;lt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;re-indent current line : &lt;code&gt;==&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;indent 5 lines : &lt;code&gt;5&amp;gt;&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;de-indent 5 lines : &lt;code&gt;5&amp;lt;&amp;lt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;re-indent 5 lines : &lt;code&gt;5==&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;indent lines 4 to 8, inclusive : &lt;code&gt;:4,8&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;indent selected lines : Select lines and use &lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;increase indent of a curly-braces block : put cursor on one of the curly braces and use &lt;code&gt;&amp;gt;, %&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;decrease indent of a curly-braces block : put cursor on one of the curly braces and use &lt;code&gt;&amp;lt;, %&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;re-indent a curly-braces block : put cursor on one of the curly braces and use &lt;code&gt;=, %&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Paste text, aligning indentation with surroundings : &lt;code&gt;]p&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;re-indent entire buffer : &lt;code&gt;gg=G&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In insert mode,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;insert indent at start of line : &lt;code&gt;ctrl + t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;remove indent at start of line : &lt;code&gt;ctrl + d&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;vim settings in &lt;code&gt;.vimrc&lt;/code&gt; file for indentation:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;set expandtab       &amp;quot;Use softtabstop spaces instead of tab characters for indentation
set shiftwidth=4    &amp;quot;Indent by 4 spaces when using &amp;gt;&amp;gt;, &amp;lt;&amp;lt;, == etc.
set softtabstop=4   &amp;quot;Indent by 4 spaces when pressing &amp;lt;TAB&amp;gt;

set autoindent      &amp;quot;Keep indentation from previous line
set smartindent     &amp;quot;Automatically inserts indentation in some cases
set cindent         &amp;quot;Like smartindent, but stricter and more customisable
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Vim has intelligent indentation based on filetype. Try adding this to your &lt;code&gt;.vimrc&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="k"&gt;has&lt;/span&gt; (&lt;span class="s"&gt;&amp;quot;autocmd&amp;quot;&lt;/span&gt;)
    &amp;quot; &lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;detection&lt;/span&gt;. &lt;span class="n"&gt;Indent&lt;/span&gt; &lt;span class="n"&gt;based&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt; &lt;span class="n"&gt;filetype&lt;/span&gt;. &lt;span class="n"&gt;Recommended&lt;/span&gt;.
    &lt;span class="n"&gt;filetype&lt;/span&gt; &lt;span class="n"&gt;plugin&lt;/span&gt; &lt;span class="n"&gt;indent&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt;
&lt;span class="n"&gt;endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Folding&lt;/h1&gt;
&lt;p&gt;여러 line 들을 folding 하면 필요 없는 부분들을 숨겨서 긴 source code 등을 보는데 더 수월할 때가 많다.&lt;/p&gt;
&lt;p&gt;folding 을 하는 가장 기본적인 방법은 원하는 line 들을 선택한 후 &lt;code&gt;z, f&lt;/code&gt;, &lt;code&gt;:fold&lt;/code&gt;, &lt;code&gt;:fo&lt;/code&gt; 를 실행하는 것이다.&lt;/p&gt;
&lt;p&gt;unfolding 은 folding 된 line 에서 &lt;code&gt;z, o&lt;/code&gt;, &lt;code&gt;:foldopen&lt;/code&gt;, &lt;code&gt;:foldo&lt;/code&gt; 중 하나를 실행하면 된다.&lt;/p&gt;
&lt;p&gt;자세한 내용은 &lt;code&gt;:help fold&lt;/code&gt; 를 참고하자.&lt;/p&gt;
&lt;h1&gt;Get the name of the current file&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Register &lt;code&gt;%&lt;/code&gt; contains the name of the current file&lt;/li&gt;
&lt;li&gt;Register &lt;code&gt;#&lt;/code&gt; contains the name of the alternate file.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;현재 작업 중인 buffer 의 file name 을 확인하려면 register &lt;code&gt;%&lt;/code&gt; 를 확인하면 된다 : &lt;code&gt;:echo @%&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;기타 file path 를 확인하기 위한 command :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:echo expand('%:t')&lt;/code&gt; : &lt;code&gt;my.txt&lt;/code&gt;, name of file ('tail')&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:echo expand('%:p')&lt;/code&gt; : &lt;code&gt;/abc/def/my.txt&lt;/code&gt;, full path&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:echo expand('%:p:h')&lt;/code&gt; : &lt;code&gt;/abc/def&lt;/code&gt;, directory containing file ('head')&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:echo expand('%:p:h:t')&lt;/code&gt; : &lt;code&gt;dev&lt;/code&gt;, First get the full path with &lt;code&gt;:p&lt;/code&gt; (&lt;code&gt;/abc/def/my.txt&lt;/code&gt;), then get the head of that with &lt;code&gt;:h&lt;/code&gt; (&lt;code&gt;/abc/def&lt;/code&gt;), then get the tail of that with &lt;code&gt;:t&lt;/code&gt; (&lt;code&gt;def&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:echo expand('%:r')&lt;/code&gt; : &lt;code&gt;my&lt;/code&gt;, name of file less one extension ('root')&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:echo expand('%:e')&lt;/code&gt; : &lt;code&gt;txt&lt;/code&gt; name of file's extension ('extension')&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For more info run &lt;code&gt;:help expand&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;If all that is wanted is to display the name of the current file, type &lt;code&gt;Ctrl-G&lt;/code&gt; (or press &lt;code&gt;1 then Ctrl-G&lt;/code&gt; for the full path).&lt;/p&gt;
&lt;p&gt;When using &lt;code&gt;@%&lt;/code&gt;, the name is displayed relative to the current directory.&lt;/p&gt;</content><category term="vim"></category></entry><entry><title>JVM Process monitoring with JDK tools</title><link href="https://imjang57.github.io/garret/jvm-process-monitoring-with-jdk-tools.html" rel="alternate"></link><published>2017-01-18T00:00:00+09:00</published><updated>2017-01-18T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-18:/garret/jvm-process-monitoring-with-jdk-tools.html</id><summary type="html">&lt;p&gt;JDK Tools 을 사용하여 JVM Process 를 모니터링하는 방법에 대한 소개&lt;/p&gt;</summary><content type="html">&lt;h1&gt;JVM Process monitoring&lt;/h1&gt;
&lt;p&gt;요즘 일 때문에 오랜만에 자바를 사용하고 있고, 스칼라에 관심이 생겨 공부해보고 있다. 그런데 둘다 &lt;em&gt;JVM&lt;/em&gt; 기반 언어다 보니 JVM 에 대해 알아야 겠다는 생각이 들었다. (사실 일하다가 JVM 모니터링 할 일이 생긴 김에 간단하게 정리한다.) 어쨌든 둘 다 JVM 에서 동작하는 녀석들이라 JVM 모니터링에 대해 간단하게 남겨보고자 한다.&lt;/p&gt;
&lt;p&gt;자바든 스칼라든 실행되면 JVM 프로세스이다. 자바나 스칼라로 쓰여진 코드는 Java Bytecode 로 컴파일되고, JVM 은 이 Bytecode 를 실행한다. 그러므로 컴파일 된 이후에는 자바로 작성했든 스칼라로 작성했든 JVM 입장에서는 그냥 똑같은 Bytecode 이다. 그러니 같은 방법(JVM Process monitoring)으로 모니터링할 수 있다.&lt;/p&gt;
&lt;h1&gt;JVM Monitoring tools&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;JDK (Java Development Kit)&lt;/em&gt; 를 설치하면 기본적으로 자바 코드를 컴파일하기 위한 &lt;code&gt;javac&lt;/code&gt;, 컴파일된 bytecode 를 실행하는 &lt;code&gt;java&lt;/code&gt; 를 제공한다. 그리고 개발자들을 위한 다양한 도구들을 기본적으로 제공한다. 모니터링을 위해서 아래 도구들을 사용가능하다.(물론 아래 도구들 외에 더 많다.)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;jps&lt;/code&gt; : JVM Process Status&lt;/li&gt;
&lt;li&gt;&lt;code&gt;jstat&lt;/code&gt; : JVM Statistics&lt;/li&gt;
&lt;li&gt;&lt;code&gt;jhat&lt;/code&gt; : Java Heap Analysis Tool&lt;/li&gt;
&lt;li&gt;&lt;code&gt;jstack&lt;/code&gt; : Java thread Stack traces&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;VisualVM&lt;/em&gt; 과 같은 GUI 도구도 있지만 어쨌든 기본은 CLI 도구들이고, GUI 도구들도 CLI 도구들을 이용하는 형태이다.&lt;/p&gt;
&lt;h1&gt;JVM Monitoring&lt;/h1&gt;
&lt;p&gt;JVM 프로세스를 모니터링하려면 당연히 JVM 프로세스가 있어야 한다. 테스트 프로그램은 임시로 tomcat 을 사용하였다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;yum install -y tomcat&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;passwd tomcat&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/etc/passwd&lt;/code&gt; 파일에서 tomcat 계정의 login shell 을 bash 로 지정&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sudo service tomcat start&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;tomcat 계정으로 전환(&lt;code&gt;su - tomcat&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;jps : JVM Process Status&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;jps&lt;/code&gt; 를 실행하면 JVM Process 목록과 PID 를 확인할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ jps
&lt;span class="m"&gt;17285&lt;/span&gt; Bootstrap
&lt;span class="m"&gt;17322&lt;/span&gt; Jps
$ jps -m
&lt;span class="m"&gt;17285&lt;/span&gt; Bootstrap start
&lt;span class="m"&gt;17398&lt;/span&gt; Jps -m
$ jps -ml
&lt;span class="m"&gt;17285&lt;/span&gt; org.apache.catalina.startup.Bootstrap start
&lt;span class="m"&gt;17413&lt;/span&gt; sun.tools.jps.Jps -ml
$
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;jstat: JVM Statistics&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;jps&lt;/code&gt; 에서 확인한 PID 로 &lt;code&gt;jstat&lt;/code&gt; 를 실행할 수 있다. 위에서 tomcat 을 실행하는 Bootstrap 의 PID 가 17285 이므로 이를 이용하여 &lt;code&gt;jstat&lt;/code&gt; 을 실행하였다. 그리고 1000 밀리초 단위로 통계치를 수집하도록 하였다. 결과는 퍼센트(%)로 출력된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ jstat -gcutil &lt;span class="m"&gt;17285&lt;/span&gt; 1000
  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT   
  0.00  98.44  60.41   5.27  96.61  89.46      &lt;span class="m"&gt;1&lt;/span&gt;    0.005     &lt;span class="m"&gt;0&lt;/span&gt;    0.000    0.005
  0.00  98.44  60.41   5.27  96.61  89.46      &lt;span class="m"&gt;1&lt;/span&gt;    0.005     &lt;span class="m"&gt;0&lt;/span&gt;    0.000    0.005
  0.00  98.44  60.41   5.27  96.61  89.46      &lt;span class="m"&gt;1&lt;/span&gt;    0.005     &lt;span class="m"&gt;0&lt;/span&gt;    0.000    0.005
  0.00  98.44  60.41   5.27  96.61  89.46      &lt;span class="m"&gt;1&lt;/span&gt;    0.005     &lt;span class="m"&gt;0&lt;/span&gt;    0.000    0.005
  0.00  98.44  60.41   5.27  96.61  89.46      &lt;span class="m"&gt;1&lt;/span&gt;    0.005     &lt;span class="m"&gt;0&lt;/span&gt;    0.000    0.005
$
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;위에서처럼 &lt;code&gt;-gcutil&lt;/code&gt; 옵션을 사용하면 Java Heap 현황을 확인할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;GCT&lt;/em&gt; : Garbage Collection Time (seconds, 누적)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;FGCT&lt;/em&gt; : Full GCT (seconds, 누적)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;FGC&lt;/em&gt; : Full Garbage Collection 발생 회수&lt;/li&gt;
&lt;li&gt;&lt;em&gt;M&lt;/em&gt; : Metaspace 영역의 사용률&lt;/li&gt;
&lt;li&gt;&lt;em&gt;S0&lt;/em&gt; : Survivor 0 영역의 사용률&lt;/li&gt;
&lt;li&gt;&lt;em&gt;S1&lt;/em&gt; : Survivor 1 영역의 사용률&lt;/li&gt;
&lt;li&gt;&lt;em&gt;E&lt;/em&gt; : Eden 영역의 사용률&lt;/li&gt;
&lt;li&gt;&lt;em&gt;O&lt;/em&gt; : Old 영역의 사용률&lt;/li&gt;
&lt;li&gt;&lt;em&gt;CCS&lt;/em&gt; : Compressed Class Space (part of metaspace)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;YGC&lt;/em&gt; : Young GC 발생 회수&lt;/li&gt;
&lt;li&gt;&lt;em&gt;YGCT&lt;/em&gt; : Young GC Time (seconds, 누적)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;FGCT 열의 값이 계속 증가하면 문제가 있는 것이다.&lt;/p&gt;
&lt;p&gt;M 열은 Metadata 를 위한 힙 영역이다. 이 영역은 자바8부터 M(Metaspace)로 표시되기 시작했고 이전 버전까지는 P(Permgen, Permanent Generation) 영역이라고 불리었다. 클래스의 Metadata, JVM 내부 객체 등이 저장되는 중요한 곳이다. 매우 무조건 자바 프로그램의 경우 이 영역에서 &lt;code&gt;java.lang.OutOfMemoryError&lt;/code&gt; 를 만날 수도 있다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-gcutil&lt;/code&gt; 대신 &lt;code&gt;-gccause&lt;/code&gt; 옵션을 사용하면 &lt;code&gt;-gcutil&lt;/code&gt; 의 결과에 GC 의 원인까지 확인할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ jstat -gccause &lt;span class="m"&gt;17285&lt;/span&gt; 1000
  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT    LGCC                 GCC                 
  0.00  98.44  61.41   5.27  96.61  89.46      &lt;span class="m"&gt;1&lt;/span&gt;    0.005     &lt;span class="m"&gt;0&lt;/span&gt;    0.000    0.005 Allocation Failure   No GC               
  0.00  98.44  61.41   5.27  96.61  89.46      &lt;span class="m"&gt;1&lt;/span&gt;    0.005     &lt;span class="m"&gt;0&lt;/span&gt;    0.000    0.005 Allocation Failure   No GC               
  0.00  98.44  61.41   5.27  96.61  89.46      &lt;span class="m"&gt;1&lt;/span&gt;    0.005     &lt;span class="m"&gt;0&lt;/span&gt;    0.000    0.005 Allocation Failure   No GC               
$
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;&lt;em&gt;LGCC&lt;/em&gt; : 지난 GC의 발생 이유&lt;/li&gt;
&lt;li&gt;&lt;em&gt;GCC&lt;/em&gt; : 현재 GC의 발생 이유&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;jstack: Java thread Stack traces&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;jstack&lt;/code&gt; 을 이용하면 현재 Java 프로세스의 stack dump 를 얻을 수 있다. &lt;code&gt;jstack&lt;/code&gt; 을 이용하면 현재 실행 중인 여러 thread 들의 stack 을 확인할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ jstack 17285
2016-12-26 10:32:20
Full thread dump OpenJDK 64-Bit Server VM &lt;span class="o"&gt;(&lt;/span&gt;25.111-b15 mixed mode&lt;span class="o"&gt;)&lt;/span&gt;:
&lt;span class="s2"&gt;&amp;quot;Attach Listener&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#17 daemon prio=9 os_prio=0 tid=0x00007f48d0001000 nid=0x458b waiting on condition [0x0000000000000000]&lt;/span&gt;
   java.lang.Thread.State: RUNNABLE
&lt;span class="s2"&gt;&amp;quot;ajp-bio-8009-AsyncTimeout&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#15 daemon prio=5 os_prio=0 tid=0x00007f491049c800 nid=0x43a9 waiting on condition [0x00007f48f8ba4000]&lt;/span&gt;
   java.lang.Thread.State: TIMED_WAITING &lt;span class="o"&gt;(&lt;/span&gt;sleeping&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.Thread.sleep&lt;span class="o"&gt;(&lt;/span&gt;Native Method&lt;span class="o"&gt;)&lt;/span&gt;
 at org.apache.tomcat.util.net.JIoEndpoint&lt;span class="nv"&gt;$AsyncTimeout&lt;/span&gt;.run&lt;span class="o"&gt;(&lt;/span&gt;JIoEndpoint.java:152&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.Thread.run&lt;span class="o"&gt;(&lt;/span&gt;Thread.java:745&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;ajp-bio-8009-Acceptor-0&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#14 daemon prio=5 os_prio=0 tid=0x00007f491049a000 nid=0x43a8 runnable [0x00007f48f8ca5000]&lt;/span&gt;
   java.lang.Thread.State: RUNNABLE
 at java.net.PlainSocketImpl.socketAccept&lt;span class="o"&gt;(&lt;/span&gt;Native Method&lt;span class="o"&gt;)&lt;/span&gt;
 at java.net.AbstractPlainSocketImpl.accept&lt;span class="o"&gt;(&lt;/span&gt;AbstractPlainSocketImpl.java:409&lt;span class="o"&gt;)&lt;/span&gt;
 at java.net.ServerSocket.implAccept&lt;span class="o"&gt;(&lt;/span&gt;ServerSocket.java:545&lt;span class="o"&gt;)&lt;/span&gt;
 at java.net.ServerSocket.accept&lt;span class="o"&gt;(&lt;/span&gt;ServerSocket.java:513&lt;span class="o"&gt;)&lt;/span&gt;
 at org.apache.tomcat.util.net.DefaultServerSocketFactory.acceptSocket&lt;span class="o"&gt;(&lt;/span&gt;DefaultServerSocketFactory.java:60&lt;span class="o"&gt;)&lt;/span&gt;
 at org.apache.tomcat.util.net.JIoEndpoint&lt;span class="nv"&gt;$Acceptor&lt;/span&gt;.run&lt;span class="o"&gt;(&lt;/span&gt;JIoEndpoint.java:222&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.Thread.run&lt;span class="o"&gt;(&lt;/span&gt;Thread.java:745&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;ContainerBackgroundProcessor[StandardEngine[Catalina]]&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#13 daemon prio=5 os_prio=0 tid=0x00007f4910497000 nid=0x43a7 waiting on condition [0x00007f48f8da6000]&lt;/span&gt;
   java.lang.Thread.State: TIMED_WAITING &lt;span class="o"&gt;(&lt;/span&gt;sleeping&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.Thread.sleep&lt;span class="o"&gt;(&lt;/span&gt;Native Method&lt;span class="o"&gt;)&lt;/span&gt;
 at org.apache.catalina.core.ContainerBase&lt;span class="nv"&gt;$ContainerBackgroundProcessor&lt;/span&gt;.run&lt;span class="o"&gt;(&lt;/span&gt;ContainerBase.java:1510&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.Thread.run&lt;span class="o"&gt;(&lt;/span&gt;Thread.java:745&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;GC Daemon&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#11 daemon prio=2 os_prio=0 tid=0x00007f491040c800 nid=0x43a5 in Object.wait() [0x00007f48fa637000]&lt;/span&gt;
   java.lang.Thread.State: TIMED_WAITING &lt;span class="o"&gt;(&lt;/span&gt;on object monitor&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.Object.wait&lt;span class="o"&gt;(&lt;/span&gt;Native Method&lt;span class="o"&gt;)&lt;/span&gt;
 - waiting on &amp;lt;0x00000000ecfdd7d0&amp;gt; &lt;span class="o"&gt;(&lt;/span&gt;a sun.misc.GC&lt;span class="nv"&gt;$LatencyLock&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
 at sun.misc.GC&lt;span class="nv"&gt;$Daemon&lt;/span&gt;.run&lt;span class="o"&gt;(&lt;/span&gt;GC.java:117&lt;span class="o"&gt;)&lt;/span&gt;
 - locked &amp;lt;0x00000000ecfdd7d0&amp;gt; &lt;span class="o"&gt;(&lt;/span&gt;a sun.misc.GC&lt;span class="nv"&gt;$LatencyLock&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;Service Thread&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#8 daemon prio=9 os_prio=0 tid=0x00007f49100e1000 nid=0x43a3 runnable [0x0000000000000000]&lt;/span&gt;
   java.lang.Thread.State: RUNNABLE
&lt;span class="s2"&gt;&amp;quot;C1 CompilerThread2&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#7 daemon prio=9 os_prio=0 tid=0x00007f49100ce000 nid=0x43a2 waiting on condition [0x0000000000000000]&lt;/span&gt;
   java.lang.Thread.State: RUNNABLE
&lt;span class="s2"&gt;&amp;quot;C2 CompilerThread1&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#6 daemon prio=9 os_prio=0 tid=0x00007f49100cc800 nid=0x43a1 waiting on condition [0x0000000000000000]&lt;/span&gt;
   java.lang.Thread.State: RUNNABLE
&lt;span class="s2"&gt;&amp;quot;C2 CompilerThread0&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#5 daemon prio=9 os_prio=0 tid=0x00007f49100bf000 nid=0x43a0 waiting on condition [0x0000000000000000]&lt;/span&gt;
   java.lang.Thread.State: RUNNABLE
&lt;span class="s2"&gt;&amp;quot;Signal Dispatcher&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#4 daemon prio=9 os_prio=0 tid=0x00007f49100bc800 nid=0x439f runnable [0x0000000000000000]&lt;/span&gt;
   java.lang.Thread.State: RUNNABLE
&lt;span class="s2"&gt;&amp;quot;Finalizer&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#3 daemon prio=8 os_prio=0 tid=0x00007f4910093000 nid=0x439e in Object.wait() [0x00007f48fb5f4000]&lt;/span&gt;
   java.lang.Thread.State: WAITING &lt;span class="o"&gt;(&lt;/span&gt;on object monitor&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.Object.wait&lt;span class="o"&gt;(&lt;/span&gt;Native Method&lt;span class="o"&gt;)&lt;/span&gt;
 - waiting on &amp;lt;0x00000000edd08988&amp;gt; &lt;span class="o"&gt;(&lt;/span&gt;a java.lang.ref.ReferenceQueue&lt;span class="nv"&gt;$Lock&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.ref.ReferenceQueue.remove&lt;span class="o"&gt;(&lt;/span&gt;ReferenceQueue.java:143&lt;span class="o"&gt;)&lt;/span&gt;
 - locked &amp;lt;0x00000000edd08988&amp;gt; &lt;span class="o"&gt;(&lt;/span&gt;a java.lang.ref.ReferenceQueue&lt;span class="nv"&gt;$Lock&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.ref.ReferenceQueue.remove&lt;span class="o"&gt;(&lt;/span&gt;ReferenceQueue.java:164&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.ref.Finalizer&lt;span class="nv"&gt;$FinalizerThread&lt;/span&gt;.run&lt;span class="o"&gt;(&lt;/span&gt;Finalizer.java:209&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;Reference Handler&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#2 daemon prio=10 os_prio=0 tid=0x00007f491008e800 nid=0x439d in Object.wait() [0x00007f48fb6f5000]&lt;/span&gt;
   java.lang.Thread.State: WAITING &lt;span class="o"&gt;(&lt;/span&gt;on object monitor&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.Object.wait&lt;span class="o"&gt;(&lt;/span&gt;Native Method&lt;span class="o"&gt;)&lt;/span&gt;
 - waiting on &amp;lt;0x00000000edd00970&amp;gt; &lt;span class="o"&gt;(&lt;/span&gt;a java.lang.ref.Reference&lt;span class="nv"&gt;$Lock&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.Object.wait&lt;span class="o"&gt;(&lt;/span&gt;Object.java:502&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.ref.Reference.tryHandlePending&lt;span class="o"&gt;(&lt;/span&gt;Reference.java:191&lt;span class="o"&gt;)&lt;/span&gt;
 - locked &amp;lt;0x00000000edd00970&amp;gt; &lt;span class="o"&gt;(&lt;/span&gt;a java.lang.ref.Reference&lt;span class="nv"&gt;$Lock&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.ref.Reference&lt;span class="nv"&gt;$ReferenceHandler&lt;/span&gt;.run&lt;span class="o"&gt;(&lt;/span&gt;Reference.java:153&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;main&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#1 prio=5 os_prio=0 tid=0x00007f4910009000 nid=0x4397 runnable [0x00007f4919dbd000]&lt;/span&gt;
   java.lang.Thread.State: RUNNABLE
 at java.net.PlainSocketImpl.socketAccept&lt;span class="o"&gt;(&lt;/span&gt;Native Method&lt;span class="o"&gt;)&lt;/span&gt;
 at java.net.AbstractPlainSocketImpl.accept&lt;span class="o"&gt;(&lt;/span&gt;AbstractPlainSocketImpl.java:409&lt;span class="o"&gt;)&lt;/span&gt;
 at java.net.ServerSocket.implAccept&lt;span class="o"&gt;(&lt;/span&gt;ServerSocket.java:545&lt;span class="o"&gt;)&lt;/span&gt;
 at java.net.ServerSocket.accept&lt;span class="o"&gt;(&lt;/span&gt;ServerSocket.java:513&lt;span class="o"&gt;)&lt;/span&gt;
 at org.apache.catalina.core.StandardServer.await&lt;span class="o"&gt;(&lt;/span&gt;StandardServer.java:470&lt;span class="o"&gt;)&lt;/span&gt;
 at org.apache.catalina.startup.Catalina.await&lt;span class="o"&gt;(&lt;/span&gt;Catalina.java:781&lt;span class="o"&gt;)&lt;/span&gt;
 at org.apache.catalina.startup.Catalina.start&lt;span class="o"&gt;(&lt;/span&gt;Catalina.java:727&lt;span class="o"&gt;)&lt;/span&gt;
 at sun.reflect.NativeMethodAccessorImpl.invoke0&lt;span class="o"&gt;(&lt;/span&gt;Native Method&lt;span class="o"&gt;)&lt;/span&gt;
 at sun.reflect.NativeMethodAccessorImpl.invoke&lt;span class="o"&gt;(&lt;/span&gt;NativeMethodAccessorImpl.java:62&lt;span class="o"&gt;)&lt;/span&gt;
 at sun.reflect.DelegatingMethodAccessorImpl.invoke&lt;span class="o"&gt;(&lt;/span&gt;DelegatingMethodAccessorImpl.java:43&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.reflect.Method.invoke&lt;span class="o"&gt;(&lt;/span&gt;Method.java:498&lt;span class="o"&gt;)&lt;/span&gt;
 at org.apache.catalina.startup.Bootstrap.start&lt;span class="o"&gt;(&lt;/span&gt;Bootstrap.java:294&lt;span class="o"&gt;)&lt;/span&gt;
 at org.apache.catalina.startup.Bootstrap.main&lt;span class="o"&gt;(&lt;/span&gt;Bootstrap.java:428&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;VM Thread&amp;quot;&lt;/span&gt; &lt;span class="nv"&gt;os_prio&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="nv"&gt;tid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00007f4910084800 &lt;span class="nv"&gt;nid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x439c runnable
&lt;span class="s2"&gt;&amp;quot;GC task thread#0 (ParallelGC)&amp;quot;&lt;/span&gt; &lt;span class="nv"&gt;os_prio&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="nv"&gt;tid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00007f491001e000 &lt;span class="nv"&gt;nid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x4398 runnable
&lt;span class="s2"&gt;&amp;quot;GC task thread#1 (ParallelGC)&amp;quot;&lt;/span&gt; &lt;span class="nv"&gt;os_prio&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="nv"&gt;tid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00007f491001f800 &lt;span class="nv"&gt;nid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x4399 runnable
&lt;span class="s2"&gt;&amp;quot;GC task thread#2 (ParallelGC)&amp;quot;&lt;/span&gt; &lt;span class="nv"&gt;os_prio&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="nv"&gt;tid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00007f4910021800 &lt;span class="nv"&gt;nid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x439a runnable
&lt;span class="s2"&gt;&amp;quot;GC task thread#3 (ParallelGC)&amp;quot;&lt;/span&gt; &lt;span class="nv"&gt;os_prio&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="nv"&gt;tid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00007f4910023800 &lt;span class="nv"&gt;nid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x439b runnable
&lt;span class="s2"&gt;&amp;quot;VM Periodic Task Thread&amp;quot;&lt;/span&gt; &lt;span class="nv"&gt;os_prio&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="nv"&gt;tid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00007f49100ef800 &lt;span class="nv"&gt;nid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x43a4 waiting on condition
JNI global references: 44
$
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;References&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.wolfe.id.au/2011/10/16/monitoring-the-openjdk-from-the-cli/"&gt;Monitoring the OpenJDK from the CLI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://d2.naver.com/helloworld/6043"&gt;Garbage Collection 모니터링 방법&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="java"></category><category term="jvm"></category><category term="monitoring"></category><category term="jps"></category><category term="stat"></category><category term="stack"></category></entry><entry><title>SSH Brute force 막기</title><link href="https://imjang57.github.io/garret/defence-ssh-brute-force.html" rel="alternate"></link><published>2017-01-12T00:00:00+09:00</published><updated>2017-01-12T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-12:/garret/defence-ssh-brute-force.html</id><summary type="html">&lt;p&gt;SSH Brute force 공격 시도를 막는 설정&lt;/p&gt;</summary><content type="html">&lt;h1&gt;ssh brute force 막기&lt;/h1&gt;
&lt;p&gt;AWS EC2 를 사용하고 있었는데 갑자기 인스턴스가 엄청나게 느려졌다. 확인해보니 SSH 연결 시도가 엄청나게 쌓이고 있었다. 인터넷에서 Source 주소를 입력해서 찾아보니 중국이라고 나오는데 그거는 뭐 알 수 없는 거고.. 어쨌든 Security Group 을 22번 포트에 대해 그냥 다 열어놨더니 이런 일이 발생했나보다. 그래도 진짜 공격 받아보긴 처음이네 ㅎㅎ..&lt;/p&gt;
&lt;p&gt;어쨌뜬 그래서 이 글에 brute force 방식으로 SSH 비밀번호를 해킹하려는 시도를 차단하기 위한 설정을 남긴다. (물론 AWS 인스턴스는 Security Group 을 내 주소로만 SSH 허용하도록 바꿔서 문제없지만 나중에 필요하게 될지 모르니....)&lt;/p&gt;
&lt;p&gt;brute force 공격이 들어오면 매번 로그인 시도때마다 SSH 서버의 Resource 가 소모되기 때문에 보안성이 좋은 비밀번호나 키를 사용하더라도 이를 방지해주는 것이 좋다.&lt;/p&gt;
&lt;p&gt;ssh port 로 20초간 5회 이상 접속을 시도하면 10분간 접속을 차단하는 iptables rule 을 만들어 보자.&lt;/p&gt;
&lt;p&gt;blacklist 와 ssh chain 생성:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# iptables -N blacklist
# iptables -N ssh
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;INPUT chain 에서 state module 로 ssh port 에 접속이 시작되면 ssh chain 으로 보낸다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# iptables -A INPUT -m state --state NEW -p tcp --dport ssh -j ssh
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;blacklist chain 에서는 recent module 로 "blacklist" 라는 목록에 접속 주소를 기록하고 접속을 거부한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# iptables -A blacklist -m recent --set --name blacklist
# iptables -A blacklist -j REJECT
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;ssh chain 은 다음과 같다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# iptables -A ssh -m recent --update --seconds 600 --hitcount 1 --name blacklist -j REJECT
# iptables -A ssh -m recent --set --name ssh
# iptables -A ssh -m recent --update --seconds 20 --hitcount 5 --name ssh -j blacklist
# iptables -A ssh -j ACCEPT
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;이 ssh chain 은 다음과 같이 동작한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;접속 주소가 이미 blacklist 에 들어 있고 지난 10분간 1회 이상 접속이 있었으면 접속을 거부한다.&lt;/li&gt;
&lt;li&gt;접속 주소를 "ssh" 목록이 기록한다.&lt;/li&gt;
&lt;li&gt;접속 주소가 이미 "ssh" 목록에 있으면, 지난 20초간 5회 이상 접속이 있었으면 blacklist chain 으로 보낸다.&lt;/li&gt;
&lt;li&gt;위의 3개가 다 통과하면 ssh 접속을 허락한다.&lt;/li&gt;
&lt;/ol&gt;</content><category term="ssh"></category><category term="iptables"></category><category term="brute force"></category></entry><entry><title>SSH Host-key identification</title><link href="https://imjang57.github.io/garret/ssh-host-key-identification.html" rel="alternate"></link><published>2017-01-10T00:00:00+09:00</published><updated>2017-01-11T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-10:/garret/ssh-host-key-identification.html</id><summary type="html">&lt;p&gt;This is about SSH Host-key identification.&lt;/p&gt;</summary><content type="html">&lt;h1&gt;SSH host key&lt;/h1&gt;
&lt;p&gt;가끔 SSH Client 로 Remote 에 있는 SSH Server 에 접속할 때 아래와 같은 에러를 볼 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;imjang57@myserver:~$ ssh administrator@192.168.0.5
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!              @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now &lt;span class="o"&gt;(&lt;/span&gt;man-in-the-middle
attack&lt;span class="o"&gt;)&lt;/span&gt;!
It is also possible that a host key has just been changed.
The fingerprint &lt;span class="k"&gt;for&lt;/span&gt; the ECDSA key sent by the remote host is
bf:e3:d3:21:c4:3c:60:cd:d9:2b:bb:a4:d1:6e:1f:df.
Please contact your system administrator.
Add correct host key in /home/imjang57/.ssh/known_hosts to get rid of
this message.
Offending ECDSA key in /home/imjang57/.ssh/known_hosts:8
  remove with: ssh-keygen -f &lt;span class="s2"&gt;&amp;quot;/home/imjang57/.ssh/known_hosts&amp;quot;&lt;/span&gt; -R
192.168.0.5
ECDSA host key &lt;span class="k"&gt;for&lt;/span&gt; 192.168.0.5 has changed and you have
requested strict checking.
Host key verification failed.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;em&gt;Host Key&lt;/em&gt; 가 달라서 발생하는 문제다. 자세히 말하면, 클라이언트 측에 등록된 SSH 서버의 호스트 키가 현재 접속 시도하면서 새롭게 받은 호스크 키와 달라서 발생한 문제이다.&lt;/p&gt;
&lt;p&gt;SSH 서버에서 호스트 키를 새롭게 생성했거나, 클라이언트 측에서 SSH 서버의 호스트 키를 수동으로 입력했는데 잘못입력했거나, 서버를 재설치했거나, 기타 등등의 이유로 기존에 저장된 호스트 키와 연결시도하면서 새롭게 받은 호스트 키가 다를 수 있다.&lt;/p&gt;
&lt;p&gt;이는 SSH 연결을 시도하는 서버가 정말 내가 연결하려는 서버가 맞는지를 체크할 수 있는 기능이다. HTTPS 를 사용할 때 신뢰할 수 있는 사이트인지 확인하는 것과 비슷한 이유로 제공되는 기능이다.&lt;/p&gt;
&lt;h2&gt;해결 방법&lt;/h2&gt;
&lt;p&gt;해결하는 방법은 여러개가 있다.&lt;/p&gt;
&lt;h3&gt;known_host 삭제하여 해결&lt;/h3&gt;
&lt;p&gt;보통 사용자의 홈 디렉터리에 .ssh 라는 디렉터리가 있고, 여기에 사용자를 위한 SSH 설정이나 사용자 인증을 위한 키 파일이 저장된다. 그리고 &lt;user_home&gt;/.ssh 디렉터리 밑에 known_hosts 라는 파일이 있는데 여기에 SSH 서버의 호스트 키들이 저장되어 있다. 여기서 에러가 나는 SSH 서버의 호스트 키를 삭제하면 다시 연결할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ssh-keygen -f &lt;span class="s2"&gt;&amp;quot;/home/imjang57/.ssh/known_hosts&amp;quot;&lt;/span&gt; -R 192.168.0.5
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;위 명령으로 저장된 서버의 호스트 키를 삭제한 후 SSH 서버에 다시 접속하면 아래와 같이 호스트 키를 등록하냐고 물어보는 메시지가 나타난다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;imjang57@myserver:~$ ssh administrator@192.168.0.5
The authenticity of host &lt;span class="s1"&gt;&amp;#39;192.168.0.5&amp;#39;&lt;/span&gt; can&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;t be established.
ECDSA key fingerprint is
bf:e3:d3:21:c4:3c:60:cd:d9:2b:bb:a4:d1:6e:1f:df.
Are you sure you want to &lt;span class="k"&gt;continue&lt;/span&gt; connecting &lt;span class="o"&gt;(&lt;/span&gt;yes/no&lt;span class="o"&gt;)&lt;/span&gt;?
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;yes 를 입력하면 호스트 키를 &lt;user_home&gt;/.ssh/known_hosts 파일에 저장하고 SSH 접속하게 된다.&lt;/p&gt;
&lt;p&gt;만약 명령어 치는게 귀찮으면 그냥 known_hosts 파일 삭제하면 된다.&lt;/p&gt;
&lt;h3&gt;StrictHostKeyChecking 설정을 off 하여 해결&lt;/h3&gt;
&lt;p&gt;리눅스에서 ssh 설정은 보통 &lt;code&gt;/etc/ssh&lt;/code&gt; 디렉터리에 있다. &lt;code&gt;ssh_config&lt;/code&gt; 파일은 클라이언트 설정 파일, &lt;code&gt;sshd_config&lt;/code&gt; 는 서버(데몬) 설정 파일이다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ssh_config&lt;/code&gt; 파일에서 아래 내용을 찾아서 호스트 키 검사를 하지 않도록 설정하면 된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;StrictHostKeyChecking no
&lt;span class="nv"&gt;UserKnownHostsFile&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/dev/null
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;호스트 키 새로 생성하는 방법&lt;/h2&gt;
&lt;p&gt;서버를 운영하는 입장에서 서버를 추가할 때 기존 서버의 이미지를 사용해서 새로운 서버를 구성할 수 있다. 이 때 호스트 키를 새롭게 생성해야 한다.&lt;/p&gt;
&lt;p&gt;호스트 키는 보통 &lt;code&gt;/etc/ssh&lt;/code&gt; 에 저장되어 있다. &lt;em&gt;RSA&lt;/em&gt;, &lt;em&gt;DSA&lt;/em&gt;, &lt;em&gt;ECDSA&lt;/em&gt; 세 가지 종류의 키 파일들이 보통 생성되어 있다.&lt;/p&gt;
&lt;p&gt;새로 호스트 키를 생성하기 위해 아래 명령을 실행해서 세 가지 종류의 호스트 키 파일들을 생성하면 된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo ssh-keygen -f /etc/ssh/ssh_host_rsa_key -N &lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt; -t rsa
sudo ssh-keygen -f /etc/ssh/ssh_host_dsa_key -N &lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt; -t dsa
sudo ssh-keygen -f /etc/ssh/ssh_host_ecdsa_key -N &lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt; -t ecdsa -b 521
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;기존에 파일들이 있으면 overwrite 할 거냐고 묻는데 당연히 &lt;code&gt;y&lt;/code&gt; 를 입력하자.&lt;/p&gt;</content><category term="ssh"></category></entry><entry><title>Git Basics</title><link href="https://imjang57.github.io/garret/git-basics.html" rel="alternate"></link><published>2017-01-05T00:00:00+09:00</published><updated>2017-01-05T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-05:/garret/git-basics.html</id><summary type="html">&lt;p&gt;Git 기본 사용법&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Git Basic&lt;/h1&gt;
&lt;p&gt;이 글은 Git 에 대해 기본적인 내용은 알고 있다고 생각하고 정리 목적으로 작성된 글이니 Git 을 아예 모르면 &lt;a href="http://git-scm.com/book/"&gt;Git Book&lt;/a&gt; 을 먼저 숙지하자.&lt;/p&gt;
&lt;p&gt;아래 내용들에 알면 Git 을 잘 사용하기 위한 개념들은 다 알고 있다고 봐도 된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;VCS (Version Control System), DVCS (Distributed Version Control System)&lt;/li&gt;
&lt;li&gt;Working tree, Staging Area (Index), Local Repository, Remote Repository, Bare Repository&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;git help&lt;/code&gt; 명령을 실행하면 사용 가능한 subcommand 들을 확인할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ git &lt;span class="nb"&gt;help&lt;/span&gt;
usage: git &lt;span class="o"&gt;[&lt;/span&gt;--version&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;--help&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;-C &amp;lt;path&amp;gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;-c &lt;span class="nv"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;value&lt;span class="o"&gt;]&lt;/span&gt;
           &lt;span class="o"&gt;[&lt;/span&gt;--exec-path&lt;span class="o"&gt;[=&lt;/span&gt;&amp;lt;path&amp;gt;&lt;span class="o"&gt;]]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;--html-path&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;--man-path&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;--info-path&lt;span class="o"&gt;]&lt;/span&gt;
           &lt;span class="o"&gt;[&lt;/span&gt;-p &lt;span class="p"&gt;|&lt;/span&gt; --paginate &lt;span class="p"&gt;|&lt;/span&gt; --no-pager&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;--no-replace-objects&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;--bare&lt;span class="o"&gt;]&lt;/span&gt;
           &lt;span class="o"&gt;[&lt;/span&gt;--git-dir&lt;span class="o"&gt;=&lt;/span&gt;&amp;lt;path&amp;gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;--work-tree&lt;span class="o"&gt;=&lt;/span&gt;&amp;lt;path&amp;gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;--namespace&lt;span class="o"&gt;=&lt;/span&gt;&amp;lt;name&amp;gt;&lt;span class="o"&gt;]&lt;/span&gt;
           &amp;lt;command&amp;gt; &lt;span class="o"&gt;[&lt;/span&gt;&amp;lt;args&amp;gt;&lt;span class="o"&gt;]&lt;/span&gt;

These are common Git commands used in various situations:

start a working area &lt;span class="o"&gt;(&lt;/span&gt;see also: git &lt;span class="nb"&gt;help&lt;/span&gt; tutorial&lt;span class="o"&gt;)&lt;/span&gt;
   clone      Clone a repository into a new directory
   init       Create an empty Git repository or reinitialize an existing one

work on the current change &lt;span class="o"&gt;(&lt;/span&gt;see also: git &lt;span class="nb"&gt;help&lt;/span&gt; everyday&lt;span class="o"&gt;)&lt;/span&gt;
   add        Add file contents to the index
   mv         Move or rename a file, a directory, or a symlink
   reset      Reset current HEAD to the specified state
   rm         Remove files from the working tree and from the index

examine the &lt;span class="nb"&gt;history&lt;/span&gt; and state &lt;span class="o"&gt;(&lt;/span&gt;see also: git &lt;span class="nb"&gt;help&lt;/span&gt; revisions&lt;span class="o"&gt;)&lt;/span&gt;
   bisect     Use binary search to find the commit that introduced a bug
   grep       Print lines matching a pattern
   log        Show commit logs
   show       Show various types of objects
   status     Show the working tree status

grow, mark and tweak your common &lt;span class="nb"&gt;history&lt;/span&gt;
   branch     List, create, or delete branches
   checkout   Switch branches or restore working tree files
   commit     Record changes to the repository
   diff       Show changes between commits, commit and working tree, etc
   merge      Join two or more development histories together
   rebase     Reapply commits on top of another base tip
   tag        Create, list, delete or verify a tag object signed with GPG

collaborate &lt;span class="o"&gt;(&lt;/span&gt;see also: git &lt;span class="nb"&gt;help&lt;/span&gt; workflows&lt;span class="o"&gt;)&lt;/span&gt;
   fetch      Download objects and refs from another repository
   pull       Fetch from and integrate with another repository or a &lt;span class="nb"&gt;local&lt;/span&gt; branch
   push       Update remote refs along with associated objects

&lt;span class="s1"&gt;&amp;#39;git help -a&amp;#39;&lt;/span&gt; and &lt;span class="s1"&gt;&amp;#39;git help -g&amp;#39;&lt;/span&gt; list available subcommands and some
concept guides. See &lt;span class="s1"&gt;&amp;#39;git help &amp;lt;command&amp;gt;&amp;#39;&lt;/span&gt; or &lt;span class="s1"&gt;&amp;#39;git help &amp;lt;concept&amp;gt;&amp;#39;&lt;/span&gt;
to &lt;span class="nb"&gt;read&lt;/span&gt; about a specific subcommand or concept.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;git help commit&lt;/code&gt; 이나 &lt;code&gt;git commit --help&lt;/code&gt; 와 같이 subcommand 자체에 대한 help 도 확인할 수 있으니 필요할 때마다 help 를 활용하자.&lt;/p&gt;
&lt;h1&gt;Git configuration&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;Git&lt;/em&gt; 설정을 적용하는 방법은 2가지가 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git config&lt;/code&gt; command 를 사용하는 방법&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.gitconfig&lt;/code&gt; 파일에 추가하는 방법&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;git config&lt;/code&gt; 명령을 사용하면 git 프로그램이 자동으로 &lt;code&gt;.gitconfig&lt;/code&gt; 파일에 해당 설정을 추가하는 것이기 때문에 결과는 같다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git config&lt;/code&gt; command:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git config --global user.name &lt;span class="s2"&gt;&amp;quot;imjang57&amp;quot;&lt;/span&gt;
git config --global user.email &lt;span class="s2"&gt;&amp;quot;imjang57@gmail.com&amp;quot;&lt;/span&gt;
git config --global color.ui auto
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;git config file (&lt;code&gt;~/.gitconfig&lt;/code&gt;):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;[user]&lt;/span&gt;
    &lt;span class="na"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;imjang57&lt;/span&gt;
&lt;span class="s"&gt;    email = imjang57@gmail.com&lt;/span&gt;
&lt;span class="k"&gt;[color]&lt;/span&gt;
    &lt;span class="na"&gt;ui&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;auto&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;위에서 &lt;code&gt;git config --global&lt;/code&gt; 과 같이 global option 을 전달했기 때문에 &lt;code&gt;~/.gitconfig&lt;/code&gt; 파일에 설정이 저장되었다. 만약 특정 Git repository 에만 설정을 적용하고 싶으면 해당 Local git repository 의 working directory 로 가서 &lt;code&gt;git config --local&lt;/code&gt; 과 같이 local option 을 사용하면 된다. 그러면 &lt;code&gt;&amp;lt;PROJECT_HOME&amp;gt;/.git/config&lt;/code&gt; 에 설정이 저장된다.&lt;/p&gt;
&lt;p&gt;현재의 git 설정들을 확인하고 싶다면 &lt;code&gt;git config --list&lt;/code&gt; 와 같이 실행한다. 만약 범위를 좁히고 싶다면 &lt;code&gt;git config --list --system&lt;/code&gt;, &lt;code&gt;git config --list --global&lt;/code&gt;, &lt;code&gt;git config --list --local&lt;/code&gt; 와 같이 실행할 수도 있다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;아래 설정은 git 이 실행할 텍스트 에디터 명령을 지정한다. commit message 작성 등을 위해 사용된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git config --global core.editor &amp;quot;\&amp;quot;C:\Windows\notepad.exe\&amp;quot;&amp;quot;
git config --global core.editor &amp;quot;nano&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr&gt;
&lt;p&gt;아래 설정은 proxy 를 설정한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git config --global http.proxy http://&amp;lt;username&amp;gt;:&amp;lt;password&amp;gt;@&amp;lt;host&amp;gt;:&amp;lt;port&amp;gt;
git config --global https.proxy http://&amp;lt;username&amp;gt;:&amp;lt;password&amp;gt;@&amp;lt;host&amp;gt;:&amp;lt;port&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;만약 프록시 서버가 별도의 인증서가 필요하면 다음과 같은 설정으로 인증서 파일을 추가한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git config --global http.sslCAInfo /path/to/mycertification.crt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;아니면 다음과 같이 ssl 인증서에 대한 validation 을 하지 않도록 설정할 수도 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git config http.sslVerify &lt;span class="nb"&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr&gt;
&lt;p&gt;아래 설정은 git 에서 사용하는 scheme 을 강제로 변환하기 위해 사용된다. 아래와 같이 설정하면 git scheme 을 https 로 바꿔서 사용하게 된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git config --global url.&lt;span class="s2"&gt;&amp;quot;https://&amp;quot;&lt;/span&gt;.insteadOf git://
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Git basic usage&lt;/h1&gt;
&lt;h2&gt;Git Local Repository 생성&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;새로운 git repository 생성 : &lt;code&gt;git init&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;명령어를 실행한 경로에 &lt;code&gt;.git&lt;/code&gt; 이라는 디렉터리가 생성되어 repository 관리 정보가 저장된다. &lt;code&gt;git init&lt;/code&gt; 명령을 실행한 디렉터리의 내용을 &lt;em&gt;Working Tree&lt;/em&gt; 라고 한다. working tree 의 변경 내용이 있을 때 &lt;code&gt;git add&lt;/code&gt;, &lt;code&gt;git rm&lt;/code&gt; 등을 실행하면 &lt;em&gt;Index&lt;/em&gt; 가 생성된다. &lt;code&gt;git commit&lt;/code&gt; 을 실행하면 local branch 에 변경 내용이 적용된다. &lt;code&gt;git push&lt;/code&gt; 를 실행하면 remote repository 에 변경된 내용을 추가한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Remote Repository 추가 : &lt;code&gt;git remote add &amp;lt;remote repository name&amp;gt; &amp;lt;Remote Repository URL&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;git init&lt;/code&gt; 후에 &lt;code&gt;git remote add&lt;/code&gt; 를 통해 remote repoistory 를 추가할 수 있다. 이후 &lt;code&gt;git fetch&lt;/code&gt; 을 실행하면 remote repository 의 정보를 읽어서 local repository 에 동기화한다. 그런데 &lt;code&gt;git fetch&lt;/code&gt;는 working tree 에 이 정보들을 적용하지는 않는다. 단지 local repository (&lt;code&gt;.git&lt;/code&gt; directory) 에만 정보를 저장한다. &lt;code&gt;git remote add origin ssh://user@host:22/repos/project&lt;/code&gt; 로 remote repository 를 등록했으면 &lt;code&gt;git merge origin/master&lt;/code&gt; 를 실행해서 merge 해야만 working tree 에 최신 정보가 적용된다. 만약 이 과정이 귀찮으면 그냥 &lt;code&gt;git pull&lt;/code&gt; 을 실행하면 된다. &lt;code&gt;git pull&lt;/code&gt; 은 &lt;code&gt;git fetch&lt;/code&gt; 와 &lt;code&gt;git merge&lt;/code&gt; 를 한꺼번에 실행해준다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Git Local Repository 를 만드는 다른 방법은 Remote Repository 를 복사하는 것이다. &lt;code&gt;git clone &amp;lt;url&amp;gt; [target directory]&lt;/code&gt; 을 실행하면 remote repository 를 복사한다. target directory 를 지정해주지 않으면 remote repository 의 이름으로 target directory 가 생성된다.&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;remote repository 목록 확인 : &lt;code&gt;git remote&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;URL 포함하여 remote repository 목록 확인 : &lt;code&gt;git remote -v&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;remote repository 상세 정보 확인 : &lt;code&gt;git remote show [remote repository name]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;remote repository 를 삭제 : &lt;code&gt;git remote rm &amp;lt;remote repository name&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;remote repository 의 이름 변경 : &lt;code&gt;git remote rename &amp;lt;from_name&amp;gt; &amp;lt;to_name&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2&gt;Bare repository&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;git init&lt;/code&gt; 을 실행할 때 &lt;code&gt;--bare&lt;/code&gt; 옵션을 추가하면 &lt;em&gt;Bare repository&lt;/em&gt; 를 생성한다. &lt;em&gt;Bare repository&lt;/em&gt; 는 저장소 역할만 한다. 즉, &lt;em&gt;Working directory&lt;/em&gt; 가 생성되지 않으며, 읽기 작업만 가능하다. &lt;code&gt;git init --bare &amp;lt;repository name&amp;gt;&lt;/code&gt; 으로 생성된 repository 에는 보통 &lt;code&gt;.git&lt;/code&gt; 디렉터리에 생성되는 파일들이 그대로 생성된다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Bare repository&lt;/em&gt; 는 코드 공유 및 협업을 위한 서버에 생성되는 저장소로 사용되며 각 개발자들은 이 &lt;em&gt;Bare repository&lt;/em&gt; 를 clone 하여 각자의 작업을 진행한다.&lt;/p&gt;
&lt;h2&gt;Managing Modifications in local repository&lt;/h2&gt;
&lt;p&gt;Git 으로 변경사항들을 관리하기 위한 기본적인 명령들을에는 status, add, rm, mv, commit, stash, diff 등이 있다.&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;repository 상태 (현재 branch, 변경 내역 등) 확인 : &lt;code&gt;git status&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;staging area (index) 에 파일 추가 : &lt;code&gt;git add &amp;lt;file&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;새롭게 생성된 Untracked files 나 modificated files 는 &lt;code&gt;git commit&lt;/code&gt; 전에 &lt;code&gt;git add&lt;/code&gt; 로 staging area 에 등록해야 한다. staging area 는 commit 전에 존재하는 임시 영역이다.&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;git repository 에 변경 내용을 기록 : &lt;code&gt;git commit [-m "messages"]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Staging area 에 기록된 파일들을 실제 repository 에 반영하는 작업이다. -m 옵션이 없다면 git 환경설정에서 지정된 editor 가 실행되고 자세한 로그를 작성할 수 있다. 관례적으로 첫 번째 줄에는 로그에 대한 한 줄 요약을 작성하고 두 번째 줄은 공백, 세 번째 줄부터 상세 내용을 작성한다. 아무것도 입력하지 않고 editor 를 종료하면 commit 이 취소된다.&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;working tree 와 staging area 의 차이를 확인 : &lt;code&gt;git diff&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;staging area 와 laest commit 의 차이를 확인 : &lt;code&gt;git diff --staged&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;working tree 와 최신 commit 의 차이를 확인 : &lt;code&gt;git diff HEAD&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;특정 branch 와 master branch 간의 diff 확인 : &lt;code&gt;git diff master..&amp;lt;branch name&amp;gt; [path]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;staging area 의 파일 삭제 : &lt;code&gt;git rm &amp;lt;path/to&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;특정 파일을 staging area 에서 삭제하지만 working tree 에는 보존 : &lt;code&gt;git rm --cached &amp;lt;path/to&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;파일 이동 : &lt;code&gt;git mv &amp;lt;from_file&amp;gt; &amp;lt;to_file&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;현재의 모든 변경 내용을 임시 저장하기 : &lt;code&gt;git stash&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;가장 최근의 임시 저장된 내용을 다시 적용하기 : &lt;code&gt;git stash pop&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;현재 임시 저장된 목록을 출력 : &lt;code&gt;git stash list&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;가장 최근의 임시 저장된 내용을 삭제 : &lt;code&gt;git stash drop&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Igrnoring files&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;.gitigrnore&lt;/code&gt; 파일에 무시할 파일들의 리스트를 추가하면 이후 추가된 파일들은 git add 등으로 변경 내용을 index 에 적용할 때 무시된다. 디렉터리마다 &lt;code&gt;.gitignore&lt;/code&gt; 파일을 생성할 수 있으며 해당 디렉터리부터 하위 디렉터리 들에 대해 파일의 내용이 적용된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;*.[oa]       # ignore files ending in &amp;quot;.o&amp;quot; or &amp;quot;.a&amp;quot;
!lib.a       # do track lib.a, even though you&amp;#39;re ignoring .a files above
*~           # ignore files ending in tilde(&amp;quot;~&amp;quot;)
/TODO        # only ignore the root TODO file, not subdir/TODO
build/       # ignore all files in the build/ directory
doc/*.txt    # ignore doc/notes.txt, but not doc/server/arch.txt
doc/**/*.txt # ignore all &amp;quot;*.txt&amp;quot; files in the doc/ directory
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;.gitignore&lt;/code&gt; 파일의 다른 용도는 empty directory 를 repository 에 저장하기 위해 사용된다. git 은 빈 디렉터리는 저장소에 저장하지 않는다. 이때 빈 디렉터리 안에 임의의 빈 &lt;code&gt;.gitignore&lt;/code&gt; 파일을 생성하여 commit 하면 해당 디렉터리도 저장소에 추가할 수 있다.&lt;/p&gt;
&lt;h2&gt;Viewing the Commit History&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;commit history 확인 : &lt;code&gt;git log [/path/to]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;commit 에서 변경된 내용도 같이 확인 : - &lt;code&gt;git log -p [/path/to]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;마지막 2개의 내용만 확인 : &lt;code&gt;git log -2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;한줄 요약으로 보기 : &lt;code&gt;git log --pretty=oneline&lt;/code&gt;, &lt;code&gt;git log --oneline&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Commit graph 를 같이 확인 : &lt;code&gt;git log --graph&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Commit 에 대한 Reference 정보 추가 : &lt;code&gt;git log --decorate&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;전체 또는 특정 branch 에 대한 Commit 정보 확인 : &lt;code&gt;git log --branch[=&amp;lt;pattern&amp;gt;]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;master branch 에 없고 feature-A branch 에 존재하는 commit 들을 확인 : &lt;code&gt;git log master..feature-A&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;전체 branch 의 commit 들을 commit graph 와 Reference 정보를 추가하여 한줄만 확인하려면 &lt;code&gt;git log --branches --graph --decoraete --oneline&lt;/code&gt; 을 실행하면 된다.&lt;/p&gt;
&lt;p&gt;특정 파일의 version history list 를 확인하려면 &lt;code&gt;git log --follow [file]&lt;/code&gt; 를 실행한다. git 나름대로 rename 한 작업까지 계산해준다.&lt;/p&gt;
&lt;h2&gt;Working with Remote Repository&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;git pull&lt;/code&gt;, &lt;code&gt;git fetch&lt;/code&gt;, &lt;code&gt;git merge&lt;/code&gt;, &lt;code&gt;git push&lt;/code&gt; 를 통해 remote repository 와 동기화할 수 있다.&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;Remote Repository 의 변경 내용들을 Local Repository 로 갱신 : &lt;code&gt;git pull&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;원격 저장소의 변경 내용이 로컬 작업 디렉토리에 받아지고(fetch), 병합(merge)된다. &lt;code&gt;git pull&lt;/code&gt; 은 내부적으로 아래의 두 명령이 연속적으로 실행된 것과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git fetch &amp;lt;remote repository name&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git merge &amp;lt;remote repository name&amp;gt;/master&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;Local Repository 의 commit 들을 Remote Repository 에 전달 : &lt;code&gt;git push [remote repository] [remote branch]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Remote Repository 이름이 origin 이고, origin 의 master branch 로 Local Repository 의 변경 내용을 올리려고 하면 &lt;code&gt;git push origin master&lt;/code&gt; 를 실행한다.&lt;/p&gt;
&lt;h2&gt;Branch and Merge&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;branch 목록 출력 및 현재 작업 중인 branch 확인 : &lt;code&gt;git branch&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Remote Repository 의 branch 들을 모두 포함하여 출력 : &lt;code&gt;git branch -a&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;branch 생성 : &lt;code&gt;git branch &amp;lt;branch name&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;branch 변경 : &lt;code&gt;git checkout &amp;lt;branch name&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;branch 생성 및 변경 : &lt;code&gt;git checkout -b &amp;lt;branch name&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;만약 feature-A 라는 이름의 branch를 생성하고 해당 branch 로 변경하고 싶으면 &lt;code&gt;git checkout -b feature-A&lt;/code&gt; 을 실행한다. 이는 다음 명령어 들을 연속으로 실행한 것과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git branch feature-A&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git checkout feature-A&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이후 master branch 로 돌아오려면 &lt;code&gt;git checkout master&lt;/code&gt; 를 실행한다. 만약 현재 branch 를 사용하기 전의 branch 로 되돌아가려면 &lt;code&gt;git checkout -&lt;/code&gt; 를 실행하면 된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;branch 삭제 : &lt;code&gt;git branch -d &amp;lt;branch name&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;branch 를 merge 하기 : &lt;code&gt;git merge [options] &amp;lt;branch name&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;만약 구현이 완료된 feature-A branch 를 merge 하려면 base branch(보통 master 또는 development)에서 &lt;code&gt;git merge feature-A&lt;/code&gt; 를 실행한다.&lt;/p&gt;
&lt;h2&gt;Resolve conflicts&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;git pull&lt;/code&gt;, &lt;code&gt;git merge&lt;/code&gt; 등을 하다보면 내가 변경하고 commit 한 내용과 다른 사람이 변경하고 commit 한 내용이 서로 충돌하는 경우가 발생한다. 대부분의 경우 git 이 자동으로 바뀐 부분을 알아서 적용해준다. 하지만 만약 서로 다른 사람들이 파일의 같은 부분을 동시에 고쳤을 경우, git 이 해결하지 못하고 충돌이 발생했음을 알려준다.&lt;/p&gt;
&lt;p&gt;이렇게 충돌이 발생하면, git이 알려주는 파일의 충돌 부분을 직접 수정해서 병합이 가능하도록 수정해야 한다. 충돌을 해결했다면, &lt;code&gt;git add [file path]&lt;/code&gt; 를 실행하여 수정된 부분을 다시 index 에 저장하고 commit 한다.&lt;/p&gt;
&lt;p&gt;변경 내용을 병합하기 전에, &lt;code&gt;git diff&lt;/code&gt; 를 사용하여 어떻게 바뀌었는지 비교해보는 것이 좋다.&lt;/p&gt;
&lt;h2&gt;Rebase&lt;/h2&gt;
&lt;p&gt;보통 &lt;code&gt;git merge&lt;/code&gt; 를 실행하면 작업 내용이 특정 parent commit 에서 분기되지 않았으면 &lt;em&gt;fast forward&lt;/em&gt; 방식이라고 해서 그대로 commit 내용을 가져 온 후 HEAD Reference 를 가장 최신의 commit 으로 변경한다.&lt;/p&gt;
&lt;p&gt;하지만 특정 parent commit 에서 작업 내용이 분기된 경우 &lt;code&gt;git merge&lt;/code&gt; 는 Base commit 으로부터 분기된 두 작업 내용을 합쳐서 새로운 commit 을 생성한다. 즉, parent commit 이 2개인 새로운 commit 이 생성되는 것이다. 이 경우 merge 한 내용을 commit history 나 graph 로 확인할 때 복잡해질 수 있다. 때문에 merge 전에 rebase 를 하도록 권장하기도 한다. 단, 이는 각 팀에 따라 다를 수 있다. 어떤 팀은 그냥 merge 를 할 수 있고 어떤 팀은 rebase 를 장려할 수도 있다. 필수는 아니다.&lt;/p&gt;
&lt;p&gt;만약 feature-A branch 에서 기능 개발 완료 후 master 로 merge 전에 rebase 를 하여 commit history 를 정리하고 싶다면 feature-A branch 에서 &lt;code&gt;git rebase master&lt;/code&gt; 를 실행한다. 그 후 master branch 로 전환한 후 &lt;code&gt;git merge feature-A&lt;/code&gt; 를 실행하면 &lt;em&gt;fast forward&lt;/em&gt; 방식으로 merge 된 것과 같이 commit history 가 정리된다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git merge&lt;/code&gt; 와 마찬가지로 &lt;code&gt;git rebase&lt;/code&gt; 도 conflict 가 발생할 수 있다. rebase 중에 conflic file 이 발견되면 rebase 작업은 잠시 멈추게 된다. 그리고 merge 와 마찬가지로 conflict file 을 수정한 후 &lt;code&gt;git add &amp;lt;conflict file&amp;gt;&lt;/code&gt; 을 실행한 뒤 &lt;code&gt;git rebase --continue&lt;/code&gt; 를 실행하면 작업이 이어서 진행된다. 만약 rebase 작업을 취소하고 싶다면 &lt;code&gt;git rebase --abort&lt;/code&gt; 를 실행한다.&lt;/p&gt;
&lt;p&gt;rebase 와 commit cherry-picking 으로 commit 을 관리하면 &lt;em&gt;fast forward&lt;/em&gt; 방식으로 정리된  commit history 를 관리할 수 있다.&lt;/p&gt;
&lt;p&gt;자세한 내용은 &lt;code&gt;git help rebase&lt;/code&gt; 나 공식 문서를 확인하자.&lt;/p&gt;
&lt;h2&gt;Tag&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Tag 목록 확인 : &lt;code&gt;git tag&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Tag 생성 : &lt;code&gt;git tag &amp;lt;tag name&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Tag 삭제 : &lt;code&gt;git tag -d &amp;lt;tag name&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;pattern 으로 tag 목록 확인 : &lt;code&gt;git tag -l 'v1.8.5*'&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;특정 tag의 정보 보기 : &lt;code&gt;git show &amp;lt;tag name&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;이미 지나간 commit 에 대한 tag 를 생성 : git tag -a &lt;tag name&gt; &lt;commit ID&gt;&lt;/li&gt;
&lt;li&gt;remote server 에 tag 정보 push : &lt;code&gt;git push origin [tagname]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;remote server 에 모든 tag 정보를 한꺼번에 전송 : &lt;code&gt;git push origin --tags&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;git tag 에는 2가지 type 이 있다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;lightweight : pointer to a specific commit. 즉, lightweight tag 정보는 오직 commit checksum 만 저장된다.&lt;/li&gt;
&lt;li&gt;annotated tag: stored as full objects in the Git database. They are checksummed; contain the tagger name, e-mail, and date; have a tagging message; and can be signed and verified with GNU Privacy Guard (GPG).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;git tag &amp;lt;tag name&amp;gt;&lt;/code&gt; 으로 Tag 를 생성할 경우 기본적으로 libweight tag 이다. annotated tag 는 &lt;code&gt;-a&lt;/code&gt; 옵션을 사용(&lt;code&gt;git tag -a &amp;lt;tag name&amp;gt; -m '&amp;lt;message&amp;gt;'&lt;/code&gt;)해야 한다. &lt;code&gt;-m&lt;/code&gt; 옵션이 없으면 git 에 editor 를 실행하여 message를 입력할 수 있도록 한다.&lt;/p&gt;
&lt;p&gt;annotated tag 는 추가적인 tag 정보들(tag name, tagger, date, message 등)과 commit 내용을 보여 준다. lightweight tag 는 tag 관련된 추가적인 정보들이 없이 commit 내용만 보여준다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tag 로 checkout : &lt;code&gt;git checkout -b version2 v2.0.0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;git 에는 사실 tag 로 checkout 하는 기능은 없다. 단지 특정 tag 로 branch 를 만드는 것이다. 때문에 이렇게 만들어진 branch 에서 작업하고 commit 하면 master 에 반영이 안되니 주의해야 한다.&lt;/p&gt;
&lt;h1&gt;Advanced&lt;/h1&gt;
&lt;h2&gt;Undo modifications&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Local 의 변경 내용을 HEAD 로 되돌리기: &lt;code&gt;git checkout -- &amp;lt;file path&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;위의 명령은 이미 인덱스에 추가된 변경 내용과 새로 생성한 파일은 그대로 남는다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Staging Area (index) 의 파일을 Unstaged 로 바꾸기: &lt;code&gt;git reset HEAD &amp;lt;file path&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;만약 어떤 파일을 수정한 후 git add 를 실행하여 Staged 상태일 때, 변경 내용들을 취소하고 싶을 경우 아래 명령들을 차례로 실행한다.&lt;/p&gt;
&lt;p&gt;HEAD 는 Git 에서 사용되는 special pointer 이다. HEAD 는 현재 작업 중인 local branch 를 가리킨다. &lt;code&gt;git checkout&lt;/code&gt; 으로 branch 를 변경하면 HEAD 가 변경된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Repository 의 history 중 하나로 복원하기: &lt;code&gt;git reset [options] &amp;lt;commit hash ID&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;history 와 모든 변경 내용들을 삭제하면서 특정 commit 으로 되돌아가기 : &lt;code&gt;git reset --hard [commit]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;git reset --hard&lt;/code&gt; 의 경우 history 를 포함한 모든 변경 내용들을 삭제하여 깔끔하게 이전 내용으로 되돌아갈 수 있다. 하지만 Local Git Repository 가 다른 Remote Repository 와 공유될 경우 문제가 발생할 수도 있다. 이때 사용가능 한 것이 &lt;code&gt;git revert &amp;lt;commit hash ID&amp;gt;&lt;/code&gt; 이다. &lt;code&gt;git revert&lt;/code&gt; 는 history 와 commit 들을 삭제하지 않는다. 내용을 특정 commit 으로 되돌리지만 삭제하지 않고 또하나의 새로운 commit 으로 처리한다.&lt;/p&gt;
&lt;h2&gt;Modify commits&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;commit 수정하기: &lt;code&gt;git commit --amend&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;아래와 같은 경우 commit 내용을 수정해야 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;어떤 파일을 빼먹었을 때&lt;/li&gt;
&lt;li&gt;commit message 를 잘못 적었을 때&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;커밋을 했는데 Stage하는 것을 깜빡하고 빠트린 파일이 있으면 아래와 같이 고칠 수 있다:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git commit -m &amp;#39;initial commit&amp;#39;
git add &amp;lt;forgotten_file_path&amp;gt;
git commit --amend
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;여기서 실행한 명령어 3개는 모두 하나의 commit 으로 기록된다. 두 번째 commit 은 첫 번째 commit 을 덮어쓴다.&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;.git&lt;/code&gt; directory&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;.git&lt;/code&gt; 디렉터리는 local git repository 정보가 저장되는 곳이다. 안에 여러 파일들이 있는데 간단하게 중요한 몇몇 파일만 설명하면 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.git/objects&lt;/code&gt; : 각 Commit Object 들이 Hash 값에 따라 저장됨&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.git/refs&lt;/code&gt; : Commit Hash 를 참조하는 Reference 정보&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.git/refs/heads&lt;/code&gt; : local git repository 의 각 branch 들의 HEAD 가 저장(master branch 의 head 는 &lt;code&gt;.git/refs/heads/master&lt;/code&gt; 에 저장)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.git/HEAD&lt;/code&gt; : 현재 작업 중인 branch 의 HEAD 정보를 나타냄(예 : ref: refs/heads/master)&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Github&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;branch 들 (example: ruby on rails repository 의 4-0-stable branch 와 3-2-stable branch) 사이의 변경 내역 확인하는 방법 : &lt;code&gt;https://github.com/rails/rails/compare/4-0-stable...3-2-stable&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;master branch 의 2015년 1월 1일부터의 변경 내역을 확인하는 방법(변경 내역이 너무 많거나, 기간이 너무 긴 경우에는 최근 변경 내용만 나온다) : &lt;code&gt;https://www.github.com/rails/rails/compare/master@{2015-01-01}...master&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;References&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://git-scm.com/book/en/v2"&gt;Git Book English&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://git-scm.com/book/ko/v2"&gt;Git Book Korean&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://rogerdudler.github.io/git-guide/index.ko.html"&gt;git - 간편 안내서&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="git"></category></entry><entry><title>SSH Timeout Configuration</title><link href="https://imjang57.github.io/garret/ssh-timeout-configuration.html" rel="alternate"></link><published>2017-01-02T00:00:00+09:00</published><updated>2017-01-02T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-02:/garret/ssh-timeout-configuration.html</id><summary type="html">&lt;p&gt;SSH 접속 시 Timeout 설정하는 방법&lt;/p&gt;</summary><content type="html">&lt;h1&gt;SSH Timeout 관련 설정&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;/etc/ssh/sshd_config&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;TCPKeepAlive yes
ClientAliveInterval 30
ClientAliveCountMax 99999
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;restart sshd:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ systemctl restart sshd
&lt;/pre&gt;&lt;/div&gt;</content><category term="ssh"></category><category term="timeout"></category></entry><entry><title>SSH Tunneling</title><link href="https://imjang57.github.io/garret/ssh-tunneling.html" rel="alternate"></link><published>2017-01-02T00:00:00+09:00</published><updated>2017-01-02T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-02:/garret/ssh-tunneling.html</id><summary type="html">&lt;p&gt;SSH Tunneling 사용 방법&lt;/p&gt;</summary><content type="html">&lt;h1&gt;SSH Tunneling&lt;/h1&gt;
&lt;p&gt;SSH(Secure SHell)는 이름에서 알 수 있듯이 보안성이 좋은 프로토콜이다. SSH는 비대칭키를 이용한 인증(Authentication), 대칭키를 이용한 데이터 암호화(Encryption), 네트웍을 통해 전송된 데이터가 변경되지 않았음을 보장하는 무결성(Integrity) 등을 제공한다.&lt;/p&gt;
&lt;p&gt;이외에 SSH는 정말 유용한 기능을 제공하는데 바로 포트 포워딩(Port Forwarding)을 이용한 터널링(Tunneling)이다.&lt;/p&gt;
&lt;p&gt;SSH 클라이언트가 SSH 서버에 연결되면 둘 사이에 연결이 생성되는데 이를 보통 &lt;strong&gt;터널(Tunnel)&lt;/strong&gt; 이라고 한다. 그리고 이 터널은 클라이언트와 서버 사이에서 암호화로 보호되는 통로이다. 보통은 이 터널을 통해서 클라이언트와 서버가 통신하는데, 포트 포워딩이라는 기술을 사용하면 이 터널을 다른 애플리케이션들이 이용하도록 할 수가 있다. 이를 터널링이라고 한다. 터널링을 사용하면 애플리케이션은 별도로 개발할 필요 없이 SSH의 보안 통로를 사용할 수 있게 되는 것이다. 터널링은 TCP만 가능하고 UDP는 불가능하다.&lt;/p&gt;
&lt;p&gt;터널링은 크게 &lt;strong&gt;로컬 포트 포워딩(Local Port Forwarding)&lt;/strong&gt; 과 &lt;strong&gt;리모트 포트 포워딩(Remote Port Forwarding)&lt;/strong&gt; 으로 나누어져 있다. 어디가 요청을 받고 어느 방향으로 전달해주냐에 따라 나누어 진다. 그리고 포트 포워딩을 통한 SSH 터널링은 SSH 연결이 유지되는 동안에만 사용할 수 있다.&lt;/p&gt;
&lt;h1&gt;Local Port Forwarding&lt;/h1&gt;
&lt;p&gt;로컬 포트 포워딩은 SSH 클라이언트가 요청을 받아 SSH 서버를 통해 다른 서버로 요청을 포워딩해주는 것이다. 로컬 포트 포워딩은 다음과 같이 실행하면 사용할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ ssh -L&amp;lt;&lt;span class="nb"&gt;local&lt;/span&gt; port number&amp;gt;:&amp;lt;host&amp;gt;:&amp;lt;remote port number&amp;gt; &amp;lt;user&amp;gt;@&amp;lt;SSH server host&amp;gt;&lt;span class="o"&gt;[&lt;/span&gt;:&amp;lt;SSH server port&amp;gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;&amp;lt;local port number&amp;gt;&lt;/code&gt;는 SSH 클라이언트가 애플리케이션을 위해 포트를 열고 대기(LISTEN)하고 있는 포트 번호이다. &lt;code&gt;&amp;lt;host&amp;gt;&lt;/code&gt;는 애플리케이션이 최종적으로 요청을 전달하려고 하는 서버 주소이다. &lt;code&gt;&amp;lt;remote port number&amp;gt;&lt;/code&gt;는 애플리케이션이 최종적으로 요청을 전달하려고 하는 서버의 포트 번호이다. 그리고 SSH 연결을 위해 &lt;code&gt;&amp;lt;user&amp;gt;@&amp;lt;SSH server host&amp;gt;&lt;/code&gt;를 전달한다.&lt;/p&gt;
&lt;p&gt;예를 들어, SSH를 통해서만 연결이 가능한 분리된 네트웍이 있다고 하자. 하나는 &lt;code&gt;192.168.0.0/24&lt;/code&gt;이고 다른 하나는 &lt;code&gt;192.169.0.0/24&lt;/code&gt;이다. SSH 클라이언트는 &lt;code&gt;192.168.0.5&lt;/code&gt;, 애플리케이션은 &lt;code&gt;192.168.0.10&lt;/code&gt;, SSH 서버는 &lt;code&gt;192.169.0.5:22&lt;/code&gt;, API 서버는 &lt;code&gt;192.169.0.10:10050&lt;/code&gt;일 때 로컬 호스트에서 로컬 포트 포워딩으로 API 서버에 요청을 하려면 다음과 같이 실행하면 된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ ssh -L10010:192.169.0.10:10050 myuser@192.169.0.5
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;그리고 애플리케이션은 &lt;code&gt;192.168.0.5:10010&lt;/code&gt;으로 요청하면 SSH 터널을 통해 API 서버로 요청을 전달할 수 있다. 즉, 애플리케이션 -&amp;gt; SSH 클라이언트 -&amp;gt; SSH 서버 -&amp;gt; API 서버로 전달이 되는 것이다.&lt;/p&gt;
&lt;h1&gt;Remote Port Forwaring&lt;/h1&gt;
&lt;p&gt;리모트 포트 포워딩은 로컬 포트 포워딩과 반대이다. SSH 서버가 요청을 받아 SSH 클라이언트를 통해 다른 서버로 요청을 포워딩해주는 것이다. 리모트 포트 포워딩은 다음과 같이 실행하면 사용할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ ssh -R&amp;lt;remote port number&amp;gt;:&amp;lt;host&amp;gt;:&amp;lt;&lt;span class="nb"&gt;local&lt;/span&gt; port number&amp;gt; &amp;lt;user&amp;gt;@&amp;lt;SSH server host&amp;gt;&lt;span class="o"&gt;[&lt;/span&gt;:&amp;lt;SSH server port&amp;gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;&amp;lt;remote port number&amp;gt;&lt;/code&gt;는 SSH 서버가 애플리케이션을 위해 포트를 열고 대기(LISTEN)하고 있는 포트 번호이다. &lt;code&gt;&amp;lt;host&amp;gt;&lt;/code&gt;는 애플리케이션이 최종적으로 요청을 전달하려고 하는 서버 주소이다. &lt;code&gt;&amp;lt;local port number&amp;gt;&lt;/code&gt;는 애플리케이션이 최종적으로 요청을 전달하려고 하는 서버의 포트 번호이다. 그리고 SSH 연결을 위해 &lt;code&gt;&amp;lt;user&amp;gt;@&amp;lt;SSH server host&amp;gt;&lt;/code&gt;를 전달한다.&lt;/p&gt;
&lt;p&gt;가만히 보면 로컬 포트 포워딩과 순서가 반대인 것을 알 수 있다. 예를 들어, 예를 들어, SSH를 통해서만 연결이 가능한 분리된 네트웍이 있다고 하자. 하나는 &lt;code&gt;192.168.0.0/24&lt;/code&gt;이고 다른 하나는 &lt;code&gt;192.169.0.0/24&lt;/code&gt;이다. SSH 클라이언트는 &lt;code&gt;192.168.0.5&lt;/code&gt;, API 서버는 &lt;code&gt;192.168.0.10&lt;/code&gt;, SSH 서버는 &lt;code&gt;192.169.0.5:22&lt;/code&gt;, 애플리케이션은 &lt;code&gt;192.169.0.10:10050&lt;/code&gt;일 때 로컬 호스트에서 로컬 포트 포워딩으로 API 서버에 요청을 하려면 다음과 같이 실행하면 된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ ssh -R10050:192.168.0.10:10010 myuser@192.169.0.5
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;그리고 애플리케이션은 &lt;code&gt;192.169.0.5:10050&lt;/code&gt;으로 요청하면 SSH 터널을 통해 API 서버로 요청을 전달할 수 있다. 즉, 애플리케이션 -&amp;gt; SSH 서버 -&amp;gt; SSH 클라이언트 -&amp;gt; API 서버로 전달이 되는 것이다.&lt;/p&gt;
&lt;h1&gt;참고사항&lt;/h1&gt;
&lt;p&gt;SSH 터널링을 이용하면 방화벽을 우회할 수 있고, SSH가 제공하는 암호화된 통신을 쉽게 다른 목적으로도 사용할 수 있다. 그러니 SSH 접근 권한과 관련된 정보(로그인 정보, SSH Key 등)를 잘 관리하자.&lt;/p&gt;</content><category term="ssh"></category><category term="tunneling"></category></entry><entry><title>SSH with key</title><link href="https://imjang57.github.io/garret/ssh-with-key.html" rel="alternate"></link><published>2017-01-02T00:00:00+09:00</published><updated>2017-01-02T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-02:/garret/ssh-with-key.html</id><summary type="html">&lt;p&gt;Key 로 SSH 로그인 하기 위한 과정&lt;/p&gt;</summary><content type="html">&lt;h1&gt;SSH with key file&lt;/h1&gt;
&lt;p&gt;SSH를 사용할 때 비밀번호를 일일이 입력하기 귀찮을 때가 있다. 특히 개발용 서버에 수시로 접속할 때... 이 때 키(Key) 파일을 이용한 로그인을 하면 비밀번호를 입력하는 번거로움을 피할 수 있다. 또한, 비밀키(Private Key) 를 잘 관리하여 SSH 접속에 대한 보안을 강화할 수도 있다. 물론 모든 보안이 그렇듯이 얼마나 비밀키를 잘 관리하느냐가 중요하다.&lt;/p&gt;
&lt;p&gt;SSH에서 키를 이용한 로그인을 위해 키파일(Key file)을 생성하고 SSH 서버에 키의 정보를 등록해주어야 한다. 키를 생성할 때 여러 암호화 알고리즘을 사용할 수 있지만 보통 RSA 비대칭키 암호화(RSA asymmetric encryption) 방식을 많이 사용한다. RSA 키파일을 생성하고 이 키를 이용하여 SSH 로그인하기 위해 다음과 같은 과정이 필요하다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;공개키(Public Key) 와 비밀키(Private Key) 를 생성&lt;/li&gt;
&lt;li&gt;로컬 호스트(Local Host), 즉 SSH 클라이언트(SSH Client)에 비밀키를 저장&lt;/li&gt;
&lt;li&gt;원격 호스트(Remote Host), 즉 SSH 서버(SSH Server)에 공개키를 등록&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;SSH 접속이 진행되는 과정을 살펴보면 다음과 같다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;SSH 클라이언트가 SSH 서버 측에 접속 요청&lt;/li&gt;
&lt;li&gt;SSH 서버는 자신의 공개키(위에서 생성한 키가 아니라 원래 SSH 서버가 가지고 있는 키)를 SSH 클라이언트에게 전달&lt;/li&gt;
&lt;li&gt;SSH 클라이언트는 SSH 서버가 전달한 공개키로 자신의 비밀키를 암호화하여 SSH 서버에게 전달&lt;/li&gt;
&lt;li&gt;SSH 서버는 자신이 가진 공개키 목록을 보고 SSH 클라이언트가 전달한 비밀키와 매칭되는 공개키가 있으면 로그인을 승인&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;위에서 언급한 대로 로그인 과정에서는 비대칭키를 사용한다. 하지만 로그인이 성공한 이후에는 대칭키를 만들고, 비대칭키로 생성된 대칭키를 공유하고, 이후 데이터 전송에는 이 대칭키(Symmetric key)를 사용한다. 비대칭키는 연산이 더 오래걸리기 때문이다.&lt;/p&gt;
&lt;h2&gt;Key 생성&lt;/h2&gt;
&lt;p&gt;먼저 Public Key 와 Private Key 를 생성한다. 리눅스에서는 아래와 같은 명령을 실행하면 된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ ssh-keygen -t rsa
Generating public/private rsa key pair.
Enter file in which to save the key &lt;span class="o"&gt;(&lt;/span&gt;/home/axl/.ssh/id_rsa&lt;span class="o"&gt;)&lt;/span&gt;: &amp;lt;&lt;span class="k"&gt;return&lt;/span&gt;&amp;gt;
Enter passphrase &lt;span class="o"&gt;(&lt;/span&gt;empty &lt;span class="k"&gt;for&lt;/span&gt; no passphrase&lt;span class="o"&gt;)&lt;/span&gt;: &amp;lt;Type the passphrase&amp;gt;
Enter same passphrase again: &amp;lt;Type the passphrase&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;ssh-keygen&lt;/code&gt; 을 실행하면 key file 이 저장될 위치와 passphrase 를 차례대로 묻는다. 저장될 위치는 기본값으로 &lt;code&gt;$HOME/.ssh/&lt;/code&gt; 이다. 특별히 변경할 일이 없다면 그대로 엔터를 입력하여 기본값으로 사용하자. &lt;code&gt;passphrase&lt;/code&gt; 는 비밀키를 생성하는데 사용될 문자열로 이 문자열을 암호화하여 키를 생성한다. 자동 로그인을 원한다면 생략해야 한다.&lt;/p&gt;
&lt;p&gt;키가 정상적으로 생성되면 키가 생성된 곳에 아래와 같은 파일들을 볼 수 있다. 참고로 아래 파일들은 SSH 를 사용할 때 보안에 매우 중요한 파일들이다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;drwx------  &lt;span class="m"&gt;2&lt;/span&gt; ubuntu ubuntu &lt;span class="m"&gt;4096&lt;/span&gt; Feb &lt;span class="m"&gt;18&lt;/span&gt; 18:54 .
drwxr-xr-x &lt;span class="m"&gt;16&lt;/span&gt; ubuntu ubuntu &lt;span class="m"&gt;4096&lt;/span&gt; Mar  &lt;span class="m"&gt;1&lt;/span&gt; 06:02 ..
-rw-rw-r--  &lt;span class="m"&gt;1&lt;/span&gt; ubuntu ubuntu  &lt;span class="m"&gt;790&lt;/span&gt; Feb &lt;span class="m"&gt;19&lt;/span&gt; 06:04 authorized_keys
-rw-------  &lt;span class="m"&gt;1&lt;/span&gt; ubuntu ubuntu &lt;span class="m"&gt;1675&lt;/span&gt; Feb &lt;span class="m"&gt;18&lt;/span&gt; 18:51 id_rsa
-rw-r--r--  &lt;span class="m"&gt;1&lt;/span&gt; ubuntu ubuntu  &lt;span class="m"&gt;395&lt;/span&gt; Feb &lt;span class="m"&gt;18&lt;/span&gt; 18:51 id_rsa.pub
-rw-r--r--  &lt;span class="m"&gt;1&lt;/span&gt; ubuntu ubuntu &lt;span class="m"&gt;2216&lt;/span&gt; Feb &lt;span class="m"&gt;19&lt;/span&gt; 18:34 known_hosts
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;authorized_keys&lt;/code&gt; 파일은 없을수도 있다. 보통 SSH 서버 측에서 접속을 허용할 공개키 정보를 저장하는 파일이다. &lt;code&gt;id_rsa&lt;/code&gt; 파일은 비밀키를 저장한 파일이다. 매우 중요하므로 절대로 타인에게 노출되면 안된다. 또한, 함부로 수정되어서는 안되므로 파일 권한을 꼭 600으로 지정해주자. &lt;code&gt;id_rsa.pub&lt;/code&gt; 파일은 공개키를 저장한 파일이다. 접속하려는 원격 호스트의 &lt;code&gt;authorized_keys&lt;/code&gt;에 &lt;code&gt;id_rsa.pub&lt;/code&gt;파일에 저장된 공개키를 추가해야 키를 이용한 로그인을 할 수 있다.&lt;/p&gt;
&lt;h2&gt;Remote Host 에 Public Key 등록&lt;/h2&gt;
&lt;p&gt;이제 &lt;code&gt;id_rsa.pub&lt;/code&gt; 파일을 리모트 서버의 &lt;code&gt;$HOME/.ssh/authorized_keys&lt;/code&gt; 파일에 추가해줘야 한다. SSH Server의 &lt;code&gt;authorized_keys&lt;/code&gt; 의 내용이 SSH Client의 &lt;code&gt;id_rsa.pub&lt;/code&gt; 파일과 같아야 한다.&lt;/p&gt;
&lt;p&gt;아래와 같이 SCP (Secure Copy) 를 이용하여 Public Key 를 Remote Host 에 복사한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;scp &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;HOME&lt;/span&gt;&lt;span class="x"&gt;/.ssh/id_rsa.pub root@server.net:id_rsa.pub&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;그리고 Public Key 를 Remote Host 의 authorized_keys 에 추가한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;cat &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;HOME&lt;/span&gt;&lt;span class="x"&gt;/id_rsa.pub &amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;HOME&lt;/span&gt;&lt;span class="x"&gt;/.ssh/authorized_keys&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;SSH 접속&lt;/h2&gt;
&lt;p&gt;이후에는 비밀번호 없이 바로 SSH 접속이 가능하다.&lt;/p&gt;
&lt;p&gt;만약 Private Key 를 다른 곳에 저장했다면 아래와 같이 &lt;code&gt;-i&lt;/code&gt; 옵션을 사용하여 키를 지정할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ ssh root@server.net -i keyfile
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Remote Host 의 SSHD 설정&lt;/h2&gt;
&lt;p&gt;Key 를 이용한 SSH 로그인을 사용하기 위해서는 Remote Host 의 SSHD 설정에서 RSA 키 인증을 사용하도록 설정해야 한다. 아래와 같은 내용이 있는지 SSHD 설정 파일 (&lt;code&gt;/etc/ssh/sshd_config&lt;/code&gt;) 을 확인한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;RSAAuthentication yes
#DSAAuthentication yes
PubkeyAuthentication yes
AuthorizedKeysFile .ssh/authorized_keys
&lt;/pre&gt;&lt;/div&gt;</content><category term="ssh"></category><category term="key-gen"></category></entry><entry><title>Linux help, man, info, TLDP</title><link href="https://imjang57.github.io/garret/linux-help-man-info-tldp.html" rel="alternate"></link><published>2017-01-01T00:00:00+09:00</published><updated>2017-05-07T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-01:/garret/linux-help-man-info-tldp.html</id><summary type="html">&lt;p&gt;Linux 를 사용함에 있어서 가장 큰 도움이 되고 필수로 알아야 할 도움말이나 문서들에 대해서 간단한게 정리한 글&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Linux &lt;em&gt;help&lt;/em&gt;, &lt;em&gt;man pages&lt;/em&gt;, GNU &lt;em&gt;info&lt;/em&gt;, TLDP&lt;/h1&gt;
&lt;p&gt;Linux 를 사용함에 있어서 가장 큰 도움이 되고 필수로 알아야 할 도움말이나 문서들에 대해서 간단한게 정리한 글이다.&lt;/p&gt;
&lt;p&gt;Linux 를 사용하다보면 Console 등의 CLI (Command-Line Interface) 에서 여러 명령어들을 사용하게 된다. 그런데 매우 많은 명령어들이 있고 각 명령어마다 다양한 옵션과 Argument 를 사용할 수 있기 때문에 이들의 사용법을 모두 외우는 것은 거의 불가능하고 비효율적이다.&lt;/p&gt;
&lt;p&gt;그래서 어떤 명령어에 대해 익히면 이후에는 &lt;code&gt;--help&lt;/code&gt; 옵션, &lt;em&gt;man pages&lt;/em&gt; utility, GNU &lt;em&gt;info&lt;/em&gt; utility 등을 참고하며 사용하게 된다.&lt;/p&gt;
&lt;p&gt;명령어들을 만든 개발자들은 왠만하면 &lt;code&gt;--help&lt;/code&gt; 정도는 최소한 제공하며, Linux 에서 사용되는 대부분의 명령들은 잘 작성된 &lt;code&gt;--help&lt;/code&gt; 와 &lt;em&gt;man pages&lt;/em&gt;  매뉴얼을 제공한다. 사실 이들을 제공하지 않으면 Linux 를 사용하는게 매우 힘들어 진다.&lt;/p&gt;
&lt;p&gt;또한, 자발적인 기여자들이 모여 TLDP()&lt;/p&gt;
&lt;h1&gt;&lt;code&gt;--help&lt;/code&gt; 옵션&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;--help&lt;/code&gt; 옵션을 거의 필수적인 요소이다. 이게 없다면 프로그램을 사용하는 사람은 한 명도 없을 수도 있다. 최소한 사용방법을 알아야 할 것 아닌가.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;man pages&lt;/em&gt; 나 &lt;em&gt;info&lt;/em&gt; 의 경우는 그 자체로 하나의 프로그램이라 (정말 극소수이지만) 어떤 시스템에는 없을 수도 있다. 따라서 &lt;code&gt;--help&lt;/code&gt; 옵션을 개발자가 사용자에게 제공해줄 수 있는 최소한의 문서이다.&lt;/p&gt;
&lt;p&gt;예를 들어, &lt;code&gt;man&lt;/code&gt; 명령은 다음과 같은 &lt;code&gt;--help&lt;/code&gt; 를 출력한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;man --help
man, version 1.6c

usage: man [-adfhktwW] [section] [-M path] [-P pager] [-S list]
    [-m system] [-p string] name ...

  a : find all matching entries
  c : do not use cat file
  d : print gobs of debugging information
  D : as for -d, but also display the pages
  f : same as whatis(1)
  h : print this help message
  k : same as apropos(1)
  K : search for a string in all pages
  t : use troff to format pages for printing
  w : print location of man page(s) that would be displayed
      (if no name given: print directories that would be searched)
  W : as for -w, but display filenames only

  C file   : use `file&amp;#39; as configuration file
  M path   : set search path for manual pages to `path&amp;#39;
  P pager  : use program `pager&amp;#39; to display pages
  S list   : colon separated section list
  m system : search for alternate system&amp;#39;s man pages
  p string : string tells which preprocessors to run
               e - [n]eqn(1)   p - pic(1)    t - tbl(1)
               g - grap(1)     r - refer(1)  v - vgrind(1)
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;&lt;em&gt;man pages&lt;/em&gt;&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;man pages&lt;/em&gt; 는 Unix 와 Linux 에서 대부분 기본 제공되는 도구이다. &lt;em&gt;man pages&lt;/em&gt; 라는 프로그램 이름은 &lt;em&gt;manual pages&lt;/em&gt; 를 의미한다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;man &amp;lt;page name&amp;gt;&lt;/code&gt; 과 같이 실행 할 수 있다. 예를 들어 &lt;code&gt;man man&lt;/code&gt; 을 실행하면 아래와 같이 &lt;code&gt;man&lt;/code&gt; 명령어에 대한 도움말을 볼 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;man(1)                                                                                                                           man(1)



NAME
       man - format and display the on-line manual pages

SYNOPSIS
       man  [-acdfFhkKtwW]  [--path]  [-m system] [-p string] [-C config_file] [-M pathlist] [-P pager] [-B browser] [-H htmlpager] [-S
       section_list] [section] name ...


DESCRIPTION
       man formats and displays the on-line manual pages.  If you specify section, man only looks in that section of the manual.   name
       is normally the name of the manual page, which is typically the name of a command, function, or file.  However, if name contains
       a slash (/) then man interprets it as a file specification, so that you can do man ./foo.5 or even man /cd/foo/bar.1.gz.

       See below for a description of where man looks for the manual page files.


OPTIONS
       -C  config_file
              Specify the configuration file to use; the default is /private/etc/man.conf.  (See man.conf(5).)

       -M  path
              Specify the list of directories to search for man pages.  Separate the directories with colons.  An  empty  list  is  the
              same as not specifying -M at all.  See SEARCH PATH FOR MANUAL PAGES.

       -P  pager
              Specify  which  pager to use.  This option overrides the MANPAGER environment variable, which in turn overrides the PAGER
              variable.  By default, man uses /usr/bin/less -is.

       -B     Specify which browser to use on HTML files.  This option overrides the BROWSER environment variable. By default, man uses
              /usr/bin/less-is,

       -H     Specify a command that renders HTML files as text.  This option overrides the HTMLPAGER environment variable. By default,
              man uses /bin/cat,

       -S  section_list
              List is a colon separated list of manual sections to search.  This option overrides the MANSECT environment variable.

...........
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;man&lt;/code&gt; 을 실행한 결과는 &lt;code&gt;less&lt;/code&gt; 나 &lt;code&gt;more&lt;/code&gt; 같은 pager utility 를 사용하여 출력된다. &lt;code&gt;q&lt;/code&gt; 를 입력하면 종료되고, &lt;code&gt;/&lt;/code&gt; 를 입력하면 문자열 검색을 수행할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;man pages&lt;/em&gt; 는 주제에 따라 여러가지 secton 으로 나누어서 제공된다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 : User commands&lt;/li&gt;
&lt;li&gt;2 : System calls&lt;/li&gt;
&lt;li&gt;3 : Subroutines (Libraries)&lt;/li&gt;
&lt;li&gt;4 : Devices (files in &lt;code&gt;/dev&lt;/code&gt; directory)&lt;/li&gt;
&lt;li&gt;5 : File formats (example : format of &lt;code&gt;/etc/passwd&lt;/code&gt; file)&lt;/li&gt;
&lt;li&gt;6 : Games&lt;/li&gt;
&lt;li&gt;7 : Miscellaneous (Macro, naming rules, etc)&lt;/li&gt;
&lt;li&gt;8 : System administration&lt;/li&gt;
&lt;li&gt;9 : Local&lt;/li&gt;
&lt;li&gt;10 : New&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;man write&lt;/code&gt; 라고 실행하면 &lt;em&gt;write&lt;/em&gt; 라는 사용자 명령어에 대한 내용을 출력하고 &lt;code&gt;man 2 write&lt;/code&gt; 라고 실행하면 &lt;em&gt;write&lt;/em&gt; 라는 linux kernel system call 에 대한 내용을 출력한다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;man passwd&lt;/code&gt; 라고 실행하면 &lt;em&gt;passwd&lt;/em&gt; 라는 사용자 명령어에 대한 내용을 출력하고 &lt;code&gt;man 5 passwd&lt;/code&gt; 라고 실행하면 관련된 파일(&lt;code&gt;/etc/passwd&lt;/code&gt;)들에 대한 내용을 출력한다&lt;/p&gt;
&lt;p&gt;&lt;code&gt;man -k passwd&lt;/code&gt; 를 실행하면 passwd 라는 키워드와 관련있는 매뉴얼들의 목록을 출력한다. &lt;code&gt;-k&lt;/code&gt; 옵션을 키워드를 의미한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ man -k passwd
chkpasswd&lt;span class="o"&gt;(&lt;/span&gt;8&lt;span class="o"&gt;)&lt;/span&gt;             - verifies user password against various systems
firmwarepasswd&lt;span class="o"&gt;(&lt;/span&gt;8&lt;span class="o"&gt;)&lt;/span&gt;        - tool &lt;span class="k"&gt;for&lt;/span&gt; setting and removing firmware passwords on a system
htpasswd&lt;span class="o"&gt;(&lt;/span&gt;1&lt;span class="o"&gt;)&lt;/span&gt;              - Manage user files &lt;span class="k"&gt;for&lt;/span&gt; basic authentication
kpasswd&lt;span class="o"&gt;(&lt;/span&gt;1&lt;span class="o"&gt;)&lt;/span&gt;               - Kerberos &lt;span class="m"&gt;5&lt;/span&gt; password changing program
kpasswdd&lt;span class="o"&gt;(&lt;/span&gt;8&lt;span class="o"&gt;)&lt;/span&gt;              - Kerberos &lt;span class="m"&gt;5&lt;/span&gt; password changing server
ldappasswd&lt;span class="o"&gt;(&lt;/span&gt;1&lt;span class="o"&gt;)&lt;/span&gt;            - change the password of an LDAP entry
passwd&lt;span class="o"&gt;(&lt;/span&gt;1&lt;span class="o"&gt;)&lt;/span&gt;                - modify a user&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;s password
passwd&lt;span class="o"&gt;(&lt;/span&gt;1ssl&lt;span class="o"&gt;)&lt;/span&gt;             - compute password hashes
passwd&lt;span class="o"&gt;(&lt;/span&gt;5&lt;span class="o"&gt;)&lt;/span&gt;, master.passwd&lt;span class="o"&gt;(&lt;/span&gt;5&lt;span class="o"&gt;)&lt;/span&gt; - format of the password file
slapd-passwd&lt;span class="o"&gt;(&lt;/span&gt;5&lt;span class="o"&gt;)&lt;/span&gt;          - /etc/passwd backend to slapd
slappasswd&lt;span class="o"&gt;(&lt;/span&gt;8&lt;span class="o"&gt;)&lt;/span&gt;            - OpenLDAP password utility
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;em&gt;man pages&lt;/em&gt; 가 화면에 출력하기 위한 문서들은 &lt;code&gt;/usr/share/doc&lt;/code&gt; 에 저장되며 최초에는 압축파일 형태로 있다가 최초에 출력될 때 압축 해제된다.&lt;/p&gt;
&lt;p&gt;참고로, &lt;a href="https://linux.die.net/man/"&gt;Linux man pages&lt;/a&gt;와 같이 온라인에서 man pages 를 확인할 수 있는 여러 사이트들도 있다.&lt;/p&gt;
&lt;h1&gt;GNU &lt;em&gt;info&lt;/em&gt;&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;man pages&lt;/em&gt; 는 Unix 에서 시작되어 오랜 시간 사용되고 있는 도구이다. GNU 에서는 조금 더 문서를 잘 표현할 수 있는 잘 정의된 포맷을 제안했고 이를 Redhat 에서 개발 및 배포했는데 이것이 &lt;em&gt;info&lt;/em&gt; 라는 프로그램이다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;info [menu item]&lt;/code&gt; 의 형태로 실행되며 실행된 상태에서 여러 명령들을 입력하여 다양한 작업을 수행할 수 있다. &lt;code&gt;info&lt;/code&gt; 가 실행된 상태에서 &lt;code&gt;?&lt;/code&gt; 를 입력하면 사용 가능한 명령들을 확인할 수 있으며 각 키보드 입력을 위한 표기법은 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;C-key&lt;/code&gt; : &lt;em&gt;CONTROL&lt;/em&gt; + key (example : &lt;code&gt;C-h&lt;/code&gt; 는 &lt;em&gt;CONTROL&lt;/em&gt; + h key 를 의미)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;M-key&lt;/code&gt; : &lt;em&gt;META&lt;/em&gt;(&lt;em&gt;ALT&lt;/em&gt;) + key (example : &lt;code&gt;M-x&lt;/code&gt; 는 &lt;em&gt;META&lt;/em&gt; + x key 를 의미)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;그런데 사실, GNU 에서 만든 프로그램들은 GNU &lt;em&gt;info&lt;/em&gt; 에 더 자세히 문서화가 되고 최신으로 업데이트 되어 있다고는 하지만 대부분의 경우 &lt;em&gt;man pages&lt;/em&gt; 프로그램만으로도 충분했기에 잘 사용하지 않는다. 인터페이스도 익숙하지 않아서 더 사용하지 않는다.&lt;/p&gt;
&lt;h1&gt;TLDP&lt;/h1&gt;
&lt;p&gt;&lt;a href="http://www.tldp.org/"&gt;TLDP (The Linux Documentation Project)&lt;/a&gt;는 자발적으로 참여하는 봉사자들에 의해 진행되는 프로젝트로, 리눅스에 대한 내용을 문서화하기 위한 프로젝트이다. &lt;a href="https://github.com/tLDP/LDP"&gt;Github repository&lt;/a&gt;도 있다.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://ko.wikipedia.org/wiki/%EB%A6%AC%EB%88%85%EC%8A%A4_%EB%AC%B8%EC%84%9C%ED%99%94_%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8"&gt;wikipedia 의 설명&lt;/a&gt;에 다음과 같이 언급되어 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;리눅스 문서화 프로젝트 (The Linux Documentation Project, TLDP)는 전적으로 자발적인 참여로 진행되는 프로젝트로 리눅스 관련 문서를 만드는 데 목표가 있다.
이 프로젝트는 처음엔 리눅스 해커들끼리 각자가 만들어 놓은 문서를 공유하기 위한 목적으로 시작되었다. 따라서 문서의 수준은 직업 시스템 어드민(admin) 등 숙달된 사용자들의 눈높이에 맞춰져 있었다. 그러나 현재에는 초보자들이 따라할 수 있는 강좌도 많이 포함하고 있다.
현재 LDP는 475개 이상의 문서를 제공하고 있다. 이 중 십여개는 일반 책의 분량이고, 이들 대부분은 오라일리 등의 컴퓨터 전문 출판사에 의해 출판되어 책으로 구입할 수 있다. LDP는 또한 사용자가 단계적으로 따라해서 목적을 이룰 수 있는 다수의 HowTo 문서 또한 제공한다. 문서의 목적은 매우 다양해서 특정 모뎀의 설정 같은 매우 구체적인 것일 수도 있고, 네트워크 관리와 같은 광대하고 추상적인 것일 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;또한, 설명에 따르면 TLDP 는 리눅스 관련된 최초에 웹 사이트이다.&lt;/p&gt;
&lt;p&gt;KLDP 에서도 매우 많은 TLDP 문서의 번역을 제공하고 있다. 예를 들면 &lt;a href="https://wiki.kldp.org/Translations/html/SysAdminGuide-KLDP/book1.html"&gt;The Linux System Administrators' Guide 번역&lt;/a&gt;과 같은 것들이 있다. KLDP 의 더 많은 번역 문서들은 &lt;a href="https://wiki.kldp.org/Translations/html/"&gt;여기&lt;/a&gt;에서 확인할 수 있다.&lt;/p&gt;
&lt;h1&gt;기타&lt;/h1&gt;
&lt;p&gt;IT는 매우 많은 분야가 있고 매우 많은 요소들이 결합되어 유기적으로 동작한다. 한 명이 모든 내용을 알기는 불가능하다. 그래서 웹을 통한 지식 공유가 매우 중요하다. 내 분야에서의 기초 지식과 핵심 원리에 집중하고 나머지는 위임하거나 협력해야 한다.&lt;/p&gt;
&lt;p&gt;TLDP 외에도 &lt;a href="https://www.google.com/"&gt;google&lt;/a&gt; 검색을 습관화하고 &lt;a href="http://stackoverflow.com/"&gt;stack overflow&lt;/a&gt; 등을 적극 활용하면 좋다. 단, 잘못된 지식이나 오래된 지식은 거를 수도 있어야 하니 무조건적으로 맹신하는 것은 좋지 않다.&lt;/p&gt;</content><category term="linux"></category><category term="help"></category><category term="man"></category><category term="info"></category></entry><entry><title>특수 문자들의 영어 이름</title><link href="https://imjang57.github.io/garret/name-of-special-characters.html" rel="alternate"></link><published>2016-12-31T00:00:00+09:00</published><updated>2016-12-31T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2016-12-31:/garret/name-of-special-characters.html</id><summary type="html">&lt;p&gt;특수 문자들의 영어 이름&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Special characters name&lt;/h1&gt;
&lt;p&gt;개발자로 살면 다양한 특수문자들을 사용하게 되는데 구글링하거나 다른 사람과 대화할 때 이들의 이름이 기억안나 당황하는 경우가 많다. 그래서 이들의 영어 이름을 메모한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;#39; : single quotation mark, single quote
&amp;quot; : double quotation mark, double quote
* : asterisk, bullet
$ : dollar
- : dash, hyphen, minus sign
_ : underscore
% : percent sign
# : pound sign, number of, hashtag
&amp;amp; : ampersand
: : colon
; : semi-colon
| : vertical bar, pipe
\ : backslash
/ : slash, divide
&amp;lt; : less than sign
&amp;gt; : greater than sign
? : question mark
! : exclamation mark
() : parentheses, bracket
( : open parenthesss
) : close parenthesss
[] : square bracket
{} : curly bracket
+ : plus sign
= : equal sign
. : dot, period
, : comma
^ : caret, modifier letter, circumflex accent
` : grave accent, back tick, back quote
~ : tilde
@ : at symbol
&lt;/pre&gt;&lt;/div&gt;</content><category term="special characters"></category></entry><entry><title>Shell, Bash, Zsh</title><link href="https://imjang57.github.io/garret/shell-introduction-bash-zsh.html" rel="alternate"></link><published>2016-12-31T00:00:00+09:00</published><updated>2016-12-31T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2016-12-31:/garret/shell-introduction-bash-zsh.html</id><summary type="html">&lt;p&gt;내가 사용하는 Shell 에 대한 소개와 설치 과정&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Shell&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;Shell&lt;/em&gt; 은 &lt;em&gt;OS&lt;/em&gt; (&lt;em&gt;Operating System&lt;/em&gt;) 가 제공하는 여러 서비스들을 사용하기 위한 User interface 를 말한다. &lt;em&gt;CLI&lt;/em&gt; (&lt;em&gt;Command-line interface&lt;/em&gt;) 도 &lt;em&gt;Shell&lt;/em&gt; 이고 &lt;em&gt;GUI&lt;/em&gt; (&lt;em&gt;Graphical User Interface&lt;/em&gt;) 도 &lt;em&gt;Shell&lt;/em&gt; 이다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Linux&lt;/em&gt; 와 &lt;em&gt;OS X&lt;/em&gt; 에서는 보통 &lt;em&gt;Bash&lt;/em&gt; 가 Default shell 로 제공된다. 이 외에 &lt;em&gt;csh&lt;/em&gt;, &lt;em&gt;ksh&lt;/em&gt;, &lt;em&gt;zsh&lt;/em&gt; 등 많은 &lt;em&gt;Shell&lt;/em&gt; 들이 있다.&lt;/p&gt;
&lt;p&gt;요즘 가장 많이 사용되는 Linux 와 OS X  에서 Default shell 이고 수 많은 shell script 들이 &lt;em&gt;Bash&lt;/em&gt; 를 기반으로 작성되기 때문에 &lt;em&gt;Bash&lt;/em&gt; 는 필수이다. 여기에 나는 개인적으로 사용되는 환경에서는 &lt;em&gt;Zsh&lt;/em&gt; 을 추가로 설치해서 사용한다.&lt;/p&gt;
&lt;p&gt;이 &lt;em&gt;Shell&lt;/em&gt; 들은 마음에 드는 프롬프트를 만들고, 자주 사용하는 명령들을 alias 하고, 환경변수를 지정해서 사용하는 등 개인 취향에 따라 customizing 할 수 있다. 그래서 이 글에 내가 사용하는 Bash 설정과 Zsh 을 설치하고 설정하기 위한 과정들을 남긴다.&lt;/p&gt;
&lt;h2&gt;Shell 확인 및 변경&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Shell&lt;/em&gt; 확인은 다음과 같이 가능하다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;현재 내가 사용중인 Shell 확인 : &lt;code&gt;echo $SHELL&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;System 에서 사용가능한 Shell 목록 확인 : &lt;code&gt;cat /etc/shells&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;만약 내가 사용 중인 Shell 을 변경하고 싶다면 &lt;code&gt;chsh -s /path/to/other/shell&lt;/code&gt; 를 실행하면 된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ chsh -s /usr/local/bin/zsh
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Shell 의 실행 형태&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Shell&lt;/em&gt; 의 실행 형태는 &lt;em&gt;Interacctive shell&lt;/em&gt; 과 &lt;em&gt;Non-interactive shell&lt;/em&gt; 2가지가 있다. &lt;em&gt;Interactive shell&lt;/em&gt; 은 사용자가 명령을 입력하고 이를 실행하는 형태의 &lt;em&gt;Shell&lt;/em&gt; 이고 &lt;em&gt;Non-interactive shell&lt;/em&gt; 은 Script 를 실행할 때 사용되는 형태이다. 그리고 &lt;em&gt;Interactive shell&lt;/em&gt; 은 &lt;em&gt;Login shell&lt;/em&gt; 과 &lt;em&gt;Non-login Shell&lt;/em&gt; 이 있다. &lt;em&gt;Shell&lt;/em&gt; 은 실행 형태에 따라 사용자가 로그인할 때, 로그아웃할 때 각각 수행되는 스크립트들이 있다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Bash&lt;/em&gt; 의 경우를 예로 살펴보자. &lt;em&gt;Interactive Login Shell&lt;/em&gt; 일 경우 로그인할 때는 &lt;code&gt;/etc/profile&lt;/code&gt; 이 먼저 실행되고 &lt;code&gt;~/.bash_profile&lt;/code&gt;, &lt;code&gt;~/.bash_login&lt;/code&gt;, &lt;code&gt;~/.profile&lt;/code&gt; 들 중 처음 나오는 1개가 실행되다. 로그아웃할 때는 &lt;code&gt;~/.bash_logout&lt;/code&gt; 을 실행한다. &lt;em&gt;Interactive Non-login Shell&lt;/em&gt; 일 경우 &lt;code&gt;~/.bashrc&lt;/code&gt; 가 실행된다. &lt;em&gt;Non-interactive shell&lt;/em&gt; 은 $BASH_ENV (script 를 sh 로 실행한 경우는 $ENV) Environment variable 을 찾아서 이 변수에서 지정하는 파일 내의 명령들을 실행한다. 대부분의 경우 System-wide environment variables 는 &lt;code&gt;/etc/profile&lt;/code&gt; 에 설정하고, 각 사용자가 필요한 내용은 &lt;code&gt;~/.bash_profile&lt;/code&gt; 에서 설정한다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Zsh&lt;/em&gt; 은 &lt;code&gt;/etc/profile&lt;/code&gt; 대신 &lt;code&gt;/etc/zprofile&lt;/code&gt;, &lt;code&gt;~/.bash_profile&lt;/code&gt; 대신 &lt;code&gt;~/.zprofile&lt;/code&gt;, &lt;code&gt;~/.bashrc&lt;/code&gt; 대신 &lt;code&gt;~/.zshrc&lt;/code&gt; 를 사용한다.&lt;/p&gt;
&lt;h2&gt;Prompt&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Interactive Shell&lt;/em&gt; 이 실행된 경우 사용자의 입력을 기다리고 있음을 나타내기 위해 &lt;code&gt;&amp;lt;username@hostname&amp;gt;&lt;/code&gt; 과 같은 내용을 표시하는데 이를 Prompt 라고 한다. 이 프롬프트는 $PS1 환경 변수에 의해 설정된다. 만약 &lt;code&gt;export PS1="\$? &amp;gt; "&lt;/code&gt; 를 실행하면 프롬프트는 &lt;code&gt;0 &amp;gt;&lt;/code&gt; 와 같이 출력된다. 숫자 0은 이전 명령에 대한 리턴값이다.&lt;/p&gt;
&lt;p&gt;나는 bash prompt 를 다음과 같이 설정해서 사용한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# Colorize bash prompt using ANSI escape codes.&lt;/span&gt;
&lt;span class="c1"&gt;#     below print : username@hostname:cwd $&lt;/span&gt;
&lt;span class="nb"&gt;export&lt;/span&gt; &lt;span class="nv"&gt;PS1&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;\[\033[36m\]\u\[\033[m\]@\[\033[32m\]\h:\[\033[33;1m\]\w\[\033[m\]\$ &amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;alias&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;alias&lt;/code&gt; 명령을 사용하면 긴 명령이나 자주 사용하는 명령을 내가 원하는 명령으로 지정할 수 있다. &lt;code&gt;alias ll='ls -GFhil'&lt;/code&gt; 을 실행하면 이후부터 &lt;code&gt;ll&lt;/code&gt; 을 입력했을 때 &lt;code&gt;ls -GFhil&lt;/code&gt; 가 실행된다.&lt;/p&gt;
&lt;p&gt;내가 주로 사용하는 &lt;code&gt;alias&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;alias ll=&amp;#39;ls -GFhil&amp;#39;
alias lt=&amp;#39;ls -altr&amp;#39;
alias vi=&amp;#39;vim&amp;#39;
ssh=&amp;#39;ssh -o StrictHostKeyChecking=no -t&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Bash&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;Bash&lt;/em&gt; 는 최초의 &lt;em&gt;Shell&lt;/em&gt; 인 Bourne shell 을 다시 만든 &lt;em&gt;Shell&lt;/em&gt; 로 Bourne-again Shell 을 줄여서 &lt;em&gt;Bash&lt;/em&gt; 라고 한다. Linux 와 OS X 에는 Default shell 이며 다른 Unix 에서는 Csh 을 쓰는 듯 하다.&lt;/p&gt;
&lt;p&gt;요즘 대부분 개발자들이 사용하는 환경은 Linux, OS X, Windows 라서 &lt;em&gt;Bash&lt;/em&gt; 는 따로 설치해본 적이 없다. Linux 와 OS X 응 Default shell 이고 Windows 는 Bash 안쓰니까.. 그러니까 &lt;em&gt;Bash&lt;/em&gt; 에 대한 얘기는 넘어가자.&lt;/p&gt;
&lt;h1&gt;Zsh&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;Zsh&lt;/em&gt; 은 &lt;em&gt;Bash&lt;/em&gt; 의 확장판 같은 거라고 한다(그렇다고 함..). 사실 &lt;em&gt;Zsh&lt;/em&gt; 을 사용하는 이유는 &lt;em&gt;oh-my-zsh&lt;/em&gt; 때문이다. &lt;em&gt;Zsh&lt;/em&gt; 자체도 (자기들 주장에는) 좋다고 하는데 사실 나는 &lt;em&gt;Bash&lt;/em&gt; 와 비교해서 딱히 뛰어난 걸 잘 못느꼈다. 게다가 대부분의 Shell script 는 &lt;em&gt;Bash&lt;/em&gt; 를 기준으로 하기 때문에 &lt;em&gt;Zsh&lt;/em&gt; 이 아무리 &lt;em&gt;Bash&lt;/em&gt; 와 호환된다 해도 사용할 이유를 느끼지 못했었다. &lt;em&gt;oh-my-zsh&lt;/em&gt; 이 없었으면 아마 사용 안했을 듯 하다.&lt;/p&gt;
&lt;h2&gt;Zsh + oh-my-zsh 설치 및 설정&lt;/h2&gt;
&lt;p&gt;zsh 설치는 &lt;code&gt;yum install zsh&lt;/code&gt;, &lt;code&gt;apt-get install zsh&lt;/code&gt;, &lt;code&gt;brew install zsh&lt;/code&gt; 중 자기 OS 에 맞는 걸로 사용해서 설치하자. zsh 소스를 받아서 컴파일 하여 설치하는 것은 &lt;a href="http://www.zsh.org"&gt;Zsh Homepage&lt;/a&gt; 가서 알아보자.&lt;/p&gt;
&lt;p&gt;이제 oh-my-zsh 을 설치하자. &lt;a href="https://github.com/robbyrussell/oh-my-zsh"&gt;oh-my-zsh github&lt;/a&gt; 에 설명이 잘 나와있으니 자세한 내용은 가서 읽어보자. 나는 curl 을 이용해서 설치했다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ curl -L https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh &lt;span class="p"&gt;|&lt;/span&gt; sh
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;위 명령을 실행하면 git repository 가 ~/.oh-my-zsh 디렉터리에 clone 되고 설치 작업이 수행된다. 그리고 ~/.zshrc 파일이 자동으로 생성된다.&lt;/p&gt;
&lt;p&gt;설치는 이렇게 쉽게 끝났고, oh-my-zsh 은 다양한 theme plugin 을 지원하므로 내가 원하는 theme 를 적용해보자. 나는 &lt;a href="https://gist.github.com/agnoster/3712874"&gt;agnoster&lt;/a&gt; theme 가 마음에 들어서 아래와 같이 ~/.zshrc 파일을 변경하였다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ZSH_THEME=&amp;quot;agnoster&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;변경 후 &lt;code&gt;~/.zshrc&lt;/code&gt; 파일을 다시 적용하면 theme 가 적용된다. 만약 &lt;code&gt;ZSH_THEME="random"&lt;/code&gt; 으로 하면 여러 테마들이 로그인할 때마다 랜덤으로 적용된다.&lt;/p&gt;
&lt;p&gt;agnoster 테마는 Powerline font 를 필요로 한다. 이 폰트는 &lt;a href="https://github.com/powerline/fonts"&gt;Powerline github&lt;/a&gt; 에서 받을 수 있다. 이 저장소를 clone 한 후 &lt;code&gt;install.sh&lt;/code&gt; 파일을 실행하면 알아서 폰트를 설치해준다.&lt;/p&gt;
&lt;p&gt;OS X 의 경우 터미널 앱의 환경설정으로 가서 테마에서 서체를 새로 설치한 &lt;em&gt;Meslo LG M for Powerline&lt;/em&gt; 으로 바꿔주자.&lt;/p&gt;</content><category term="shell"></category><category term="bash"></category><category term="zsh"></category></entry><entry><title>TMUX Introduction</title><link href="https://imjang57.github.io/garret/tmux-introduction.html" rel="alternate"></link><published>2016-12-31T00:00:00+09:00</published><updated>2017-05-05T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2016-12-31:/garret/tmux-introduction.html</id><summary type="html">&lt;p&gt;TMUX 설치 및 사용법에 대한 간단한 소개&lt;/p&gt;</summary><content type="html">&lt;h1&gt;TMUX (Terminal Multiplexer)&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;tmux&lt;/em&gt; 는 terminal session 을 관리하기 위한 tool 이다. 여러 session 을 생성하여 서로 다른 workspace 를 만들 수 있고, session 을 유지시켜서 server 가 완전히 power off 되지않는다면 workspace 를 유지할 수도 있다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;tmux&lt;/em&gt; + &lt;em&gt;vim&lt;/em&gt; + &lt;em&gt;bash&lt;/em&gt; 는 매우 강력한 linux environment 를 제공한다.&lt;/p&gt;
&lt;h2&gt;설치&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;OS X: &lt;code&gt;brew install tmux&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Ubuntu: &lt;code&gt;apt-get install libevent-dev tmux&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;CentOS: &lt;code&gt;yum install libevent-dev tmux&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Linux 에서는 환경에 따라서 libncurses 모듈이 필요할 수 있다&lt;/p&gt;
&lt;h1&gt;tmux basic concepts&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;tmux&lt;/em&gt; 를 이용하기 전에 아래와 같은 개념에 대해 알고 가자.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;session&lt;/em&gt; : &lt;em&gt;tmux&lt;/em&gt; 실행 단위이다. 하나의 workspace 라고 생각할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;window&lt;/em&gt; : &lt;em&gt;session&lt;/em&gt; 내에 생성되는 하나의 terminal&lt;/li&gt;
&lt;li&gt;&lt;em&gt;pane&lt;/em&gt; : terminal 화면을 분할한 단위&lt;/li&gt;
&lt;li&gt;&lt;em&gt;status bar&lt;/em&gt; : 화면 아래부분에 표시되는 &lt;em&gt;session&lt;/em&gt; 의 status bar&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;99% 정도되는 대부분의 command 는 &lt;code&gt;ctrl + b&lt;/code&gt; 를 누른다음 이어서 command key 를 입력하여 실행된다. 예를 들어 command mode 로 직접 명령어를 입력하고 싶을 때는 &lt;code&gt;ctrl + b, :&lt;/code&gt; 와 같이 키를 입력한다. 정확하게는 &lt;code&gt;ctrl + b&lt;/code&gt; 를 누른 후 5초 내에 &lt;code&gt;:&lt;/code&gt; 를 입력한다. 5초 내에 command key 를 입력하면 된다.&lt;/p&gt;
&lt;h2&gt;Session&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;tmux&lt;/em&gt; 를 실행하면 &lt;em&gt;session&lt;/em&gt; 이라는 것이 생성된다. &lt;em&gt;session&lt;/em&gt; 은 실제 작업이 이루어지는 workspace 이며, &lt;em&gt;tmux&lt;/em&gt; 는 이 &lt;em&gt;session&lt;/em&gt; 을 관리하는 tool 이다.&lt;/p&gt;
&lt;h3&gt;create, rename, exit session&lt;/h3&gt;
&lt;p&gt;새로운 session 을 생성:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ tmux
$ tmux new-session -s &amp;lt;session name&amp;gt;
$ tmux new -s &amp;lt;session name&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;session name 을 직접 정하지 않았을 경우 숫자가 기본 session name 이 된다. 변경하고 싶으면 아래와 같은 command 를 입력한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ tmux rename-session -t &amp;lt;target session&amp;gt; &amp;lt;new session name&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;위의 명령에서 &lt;code&gt;tmux&lt;/code&gt; 를 제외한 부분(&lt;code&gt;rename-session&lt;/code&gt; 부터)을 &lt;em&gt;session&lt;/em&gt; 내에서 command mode(&lt;code&gt;ctrl + b, :&lt;/code&gt;) 에서 사용해도 된다.
또는 session 내에서 &lt;code&gt;ctrl + b, $&lt;/code&gt; 를 입력한다. 그러면 status bar 가 아래처럼 나타난다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(rename-session) 0
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;기존의 session name 인 0 을 삭제하고 새로운 session name 을 입력한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(rename-session) testsession
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;생성된 session 을 종료하고 싶으면 session 내에서 &lt;code&gt;exit&lt;/code&gt; 를 실행한다. 또는 &lt;code&gt;ctrl + d&lt;/code&gt; 를 입력한다.&lt;/p&gt;
&lt;p&gt;생성되어 있는 session 을 없애려면 다음을 실행한다:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ tmux kill-session -t &amp;lt;session name&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;attach and detach session&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;session&lt;/em&gt; 을 실행한 후 이를 유지하고 &lt;em&gt;session&lt;/em&gt; 밖으로 나갈 수도 있다. 서버만 내려가지 않는다면 이 &lt;em&gt;session&lt;/em&gt; 을 계속 유지시킬 수 있다. 이렇게 동작하는 것을 &lt;em&gt;session&lt;/em&gt; 을 detach 한다고 하는데 command mode 에서 &lt;code&gt;detach&lt;/code&gt; 를 입력하여 실행할 수 있다. 또는 &lt;code&gt;ctrl + b, d&lt;/code&gt; 를 입력해도 된다.&lt;/p&gt;
&lt;p&gt;이미 생성된 session 의 목록을 확인하려면 아래 명령을 실행한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ tmux list-sessions
testsession: &lt;span class="m"&gt;1&lt;/span&gt; windows &lt;span class="o"&gt;(&lt;/span&gt;created Thu Dec &lt;span class="m"&gt;22&lt;/span&gt; 09:31:45 2016&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;224x41&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;특정 session 에 다시 접속하려면 아래 명령을 실행한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ tmux attach-session -t testsession
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;위 명령을 아래 처럼 짧게 사용할 수도 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ tmux attach -t testsession
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Window&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;window&lt;/em&gt; 는 &lt;em&gt;session&lt;/em&gt; 내에서 나누어지는 공간이다. 일반적으로 인터넷 브라우저나 다른 어플리케이션에서 볼 수 있는 탭과 같은 것이다. &lt;em&gt;session&lt;/em&gt; 이라는 workspace 에 여러 &lt;em&gt;window&lt;/em&gt; 를 생성하여 한번에 여러가지 일들을 동시에 할 수 있게 된다.&lt;/p&gt;
&lt;h3&gt;create, rename, close window&lt;/h3&gt;
&lt;p&gt;최초에 &lt;em&gt;session&lt;/em&gt; 이 생성되면 무조건 1 개의 &lt;em&gt;window&lt;/em&gt; 가 생성된다. 최대 10개까지 생성할 수 있다. 화면 아래에 있는 status bar 에서 현재 &lt;em&gt;window&lt;/em&gt; 는 &lt;code&gt;*&lt;/code&gt; 가 window name 옆에 표시된다.&lt;/p&gt;
&lt;p&gt;현재 &lt;em&gt;session&lt;/em&gt; 에서 새로운 &lt;em&gt;window&lt;/em&gt; 를 생성하려면 &lt;code&gt;ctrl + b, c&lt;/code&gt; 를 입력한다. &lt;em&gt;tmux&lt;/em&gt; 로 새로운 &lt;em&gt;session&lt;/em&gt; 을 생성하면서 동시에 &lt;em&gt;session&lt;/em&gt; 과 &lt;em&gt;window&lt;/em&gt; 의 이름을 지정하려면 &lt;code&gt;tmux new-session -s testsession -n testwindow&lt;/code&gt; 명령으로 &lt;em&gt;tmux&lt;/em&gt; 를 실행하면 된다:&lt;/p&gt;
&lt;p&gt;현재 활성화된(&lt;code&gt;*&lt;/code&gt; 로 표시된) &lt;em&gt;window&lt;/em&gt; 의 name 을 변경하려면 &lt;code&gt;ctrl + b, ,&lt;/code&gt; 을 입력한다.&lt;/p&gt;
&lt;p&gt;현재 활성화된 &lt;em&gt;window&lt;/em&gt; 를 삭제하려면 &lt;code&gt;ctrl + b, &amp;amp;&lt;/code&gt; 를 입력하거나 &lt;code&gt;ctrl + d&lt;/code&gt; 를 입력한다.&lt;/p&gt;
&lt;h3&gt;Move to window&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;window&lt;/em&gt; 사이를 이동하려면 &lt;code&gt;ctrl + b, &amp;lt;window number: 0–9&amp;gt;&lt;/code&gt; 를 입력한다. 또는 &lt;code&gt;ctrl + b, n&lt;/code&gt; 으로 다음 &lt;em&gt;window&lt;/em&gt; 로, &lt;code&gt;ctrl + b, p&lt;/code&gt; 로 이전 &lt;em&gt;window&lt;/em&gt; 로 이동할 수 있다. 바로 직전에 작업하고 있던 &lt;em&gt;window&lt;/em&gt; 로 가려면 &lt;code&gt;ctrl + b, l&lt;/code&gt; 을 사용한다. l 의 의미는 last-window 이다.&lt;/p&gt;
&lt;p&gt;또 다른 &lt;em&gt;window&lt;/em&gt; 를 이동하는 방법은 &lt;code&gt;ctrl + b, w&lt;/code&gt; 를 사용하는 방법이다. 이 키를 입력하면 화면에 현재 &lt;em&gt;session&lt;/em&gt; 내에 열려 있는 &lt;em&gt;window&lt;/em&gt; 들이 list-up 된다. 원하는 &lt;em&gt;window&lt;/em&gt; 를 선택하여 바로 이동할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ctrl + b, f&lt;/code&gt; 를 이용하면 검색을 이용하여 &lt;em&gt;window&lt;/em&gt; 를 이동할 수 있다. 검색 결과가 복수이면 해당 &lt;em&gt;window&lt;/em&gt; 들이 list-up 된다. 원하는 &lt;em&gt;window&lt;/em&gt; 를 선택해서 이동할 수 있다.&lt;/p&gt;
&lt;h3&gt;Exit window&lt;/h3&gt;
&lt;p&gt;현재 &lt;em&gt;window&lt;/em&gt; 를 종료하려면 terminal 에서 &lt;code&gt;exit&lt;/code&gt; command 를 실행한다. 또는 &lt;code&gt;ctrl + d&lt;/code&gt; 를 입력한다. 모든 &lt;em&gt;window&lt;/em&gt; 가 종료되면 &lt;em&gt;session&lt;/em&gt; 도 종료된다.&lt;/p&gt;
&lt;h2&gt;Pane&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;pane&lt;/em&gt; 은 &lt;em&gt;windows&lt;/em&gt; 를 구성하는 화면들이다. &lt;em&gt;windows&lt;/em&gt; 는 1개 또는 여러 개의 pane 들로 구성될 수 있다. 때문에 2개의 &lt;em&gt;pane&lt;/em&gt; 을 만들어서 &lt;em&gt;window&lt;/em&gt; 를 좌우로 나누어 사용할 수도 있다.&lt;/p&gt;
&lt;h3&gt;Split&lt;/h3&gt;
&lt;p&gt;좌우로 window 분할(Split vertical)하려면 &lt;code&gt;ctrl + b, %&lt;/code&gt; 를 입력한다. 또는 command mode 로 &lt;code&gt;split-window -h&lt;/code&gt; 를 입력한다.&lt;/p&gt;
&lt;p&gt;상하로 window 분할(Split horizontal)하려면 &lt;code&gt;ctrl + b, "&lt;/code&gt; 를 입력한다. 또는 command mode 로 &lt;code&gt;split-window -v&lt;/code&gt; 를 입력한다.&lt;/p&gt;
&lt;h3&gt;Move to pane&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ctrl + b, q&lt;/code&gt; 를 입력하면 각 &lt;em&gt;pane&lt;/em&gt; 에 숫자가 잠시 표시된다. 이 때 원하는 pane 의 숫자를 입력하면 해당 &lt;em&gt;pane&lt;/em&gt; 으로 이동한다. 2초 간의 timeout 내에 입력해야 한다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ctrl + b, o&lt;/code&gt; 를 입력하면 정해진 순서에 따라 현재 &lt;em&gt;window&lt;/em&gt; 에 생성된 &lt;em&gt;pane&lt;/em&gt; 들을 차례대로 이동한다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ctrl + b, 방향키(Arrow key)&lt;/code&gt; 를 입력하면 인접한 방향의 &lt;em&gt;pane&lt;/em&gt; 으로 이동한다.&lt;/p&gt;
&lt;h3&gt;Exit pane&lt;/h3&gt;
&lt;p&gt;현재 &lt;em&gt;pane&lt;/em&gt; 을 종료시키려면 terminal 에서 &lt;code&gt;exit&lt;/code&gt; command 를 실행한다. 또는 &lt;code&gt;ctrl + d&lt;/code&gt; 를 입력한다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ctrl + b, x&lt;/code&gt; 를 입력하면 status bar 에 y/n 을 묻는 prompt 가 표시된다. y 를 선택하면 종료된다.&lt;/p&gt;
&lt;p&gt;모든 &lt;em&gt;pane&lt;/em&gt; 들이 종료되면 &lt;em&gt;window&lt;/em&gt; 도 종료된다.&lt;/p&gt;
&lt;h3&gt;Resizing pane&lt;/h3&gt;
&lt;p&gt;command mode 에서 명령을 입력하며 &lt;em&gt;pane&lt;/em&gt; 의 size 를 조절할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;왼쪽으로 10 줄이기 : &lt;code&gt;resize-pane -L 10&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;오른쪽으로 10 늘리기 : &lt;code&gt;resize-pane -R 10&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;아래쪽으로 10 늘리기 : &lt;code&gt;resize-pane -D 10&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;위쪽으로 10 늘리기 : &lt;code&gt;resize-pane -U 10&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Configuration file&lt;/h1&gt;
&lt;p&gt;tmux configuration file 은 &lt;code&gt;~/.tmux.conf&lt;/code&gt; 이다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;setw -g mode-keys vi
set -g status-keys vi

# 0 is too far from `.
set -g base-index 1

# To change prefix
set -g prefix C-a
unbind-key C-b
bind-key C-a send-prefix

bind-key v split-window -h
bind-key s split-window -v

bind-key J resize-pane -D 5
bind-key K resize-pane -U 5
bind-key H resize-pane -L 5
bind-key L resize-pane -R 5

bind-key M-j resize-pane -D
bind-key M-k resize-pane -U
bind-key M-h resize-pane -L
bind-key M-l resize-pane -R

# Vim style pane selection
bind h select-pane -L
bind j select-pane -D 
bind k select-pane -U
bind l select-pane -R

# Use Alt-vim keys without prefix key to switch panes
bind -n M-h select-pane -L
bind -n M-j select-pane -D 
bind -n M-k select-pane -U
bind -n M-l select-pane -R

# Use Alt-arrow keys without prefix key to switch panes
bind -n M-Left select-pane -L
bind -n M-Right select-pane -R
bind -n M-Up select-pane -U
bind -n M-Down select-pane -D

# Shift arrow to switch windows
bind -n S-Left  previous-window
bind -n S-Right next-window

# Reload tmux config
bind r source-file ~/.tmux.conf

# THEME
set -g status-bg black
set -g status-fg white
set -g window-status-current-bg white
set -g window-status-current-fg black
set -g window-status-current-attr bold
set -g status-interval 60
set -g status-left-length 30
set -g status-left &amp;#39;#[fg=green](#S) #(whoami)&amp;#39;
set -g status-right &amp;#39;#[fg=yellow]#(cut -d &amp;quot; &amp;quot; -f 1-3 /proc/loadavg)#[default] #[fg=white]%H:%M#[default]&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Key binding&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;ctrl + b + ?&lt;/code&gt; 을 입력하면 현재의 key binding 리스트를 볼 수 있다.&lt;/p&gt;
&lt;p&gt;사용자가 원하면 &lt;code&gt;~/.tmux.conf&lt;/code&gt; 파일에 key binding 를 설정할 수 있다. 자세한 내용은 tmux manpage 를 참고하자.&lt;/p&gt;
&lt;h1&gt;Copy mode&lt;/h1&gt;
&lt;p&gt;tmux 를 실행하고 있는 환경에서는 scroll bar 가 없다. 이때 &lt;em&gt;Copy mode&lt;/em&gt; 를 사용하면 이전 출력들을 볼 수 있다. 또한 &lt;em&gt;session&lt;/em&gt; 안에서 원하는 text 를 copy / paste 할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ctrl + b, [&lt;/code&gt; 를 입력하면 &lt;em&gt;Copy mode&lt;/em&gt; 로 진입한다. &lt;em&gt;pane&lt;/em&gt; 의 오른쪽 상단에 buffer 에 저장된 총 line 수가 출력된다. &lt;em&gt;Copy mode&lt;/em&gt; 를 종료하고 싶으면 &lt;code&gt;Enter&lt;/code&gt; 를 입력하거나 &lt;code&gt;q&lt;/code&gt; 를 입력한다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Copy mode&lt;/em&gt; 에서 이동은 &lt;code&gt;방향키(Arrow key)&lt;/code&gt;, &lt;code&gt;PageUp&lt;/code&gt;, &lt;code&gt;PageDown&lt;/code&gt; 키들을 사용한다. 만약 vi editor 의 방식으로 이동하고 싶으면 &lt;code&gt;~/.tmux.conf&lt;/code&gt; 파일에 &lt;code&gt;setw -g mode-keys vi&lt;/code&gt; 를 추가한다. 이 설정을 하면 &lt;code&gt;h&lt;/code&gt;, &lt;code&gt;j&lt;/code&gt;, &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;l&lt;/code&gt;, &lt;code&gt;G&lt;/code&gt;, &lt;code&gt;g&lt;/code&gt;, &lt;code&gt;ctrl + f&lt;/code&gt;, &lt;code&gt;ctrl + b&lt;/code&gt; 등 vi editor 에서 cursor 이동에 사용되는 key 들을 사용할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Copy mode&lt;/em&gt; 에서 검색은 &lt;code&gt;?&lt;/code&gt; 와 &lt;code&gt;/&lt;/code&gt; 를 사용한다. &lt;code&gt;?&lt;/code&gt; 또는 &lt;code&gt;/&lt;/code&gt; 를 입력하면 &lt;em&gt;pane&lt;/em&gt; 왼쪽 아래부분에 &lt;code&gt;Search Up:&lt;/code&gt; 이라고 표시된다. 여기에 검색어를 입력한다. &lt;code&gt;?&lt;/code&gt; 를 입력하면 위로 검색, &lt;code&gt;/&lt;/code&gt; 를 입력하면 아래로 검색한다. 다음, 이전 검색은 &lt;code&gt;N&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt; 을 입력한다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Copy mode&lt;/em&gt; 에서 &lt;code&gt;SPACEBAR&lt;/code&gt; 키를 입력하면 &lt;em&gt;Visual mode&lt;/em&gt; 가 되며, Text 를 선택할 수 있게 된다. 선택한 Text 를 복사하고 싶으면 &lt;code&gt;Enter&lt;/code&gt; 키를 입력한다. &lt;em&gt;Copy mode&lt;/em&gt; 에서는 quit 의 의미이지만 &lt;em&gt;Visual mode&lt;/em&gt; 에서는 복사와 함꼐 quit 를 수행한다. 복사한 Text 를 붙여넣고 싶다면 &lt;code&gt;ctrl + b, ]&lt;/code&gt; 를 입력한다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ctrl + b, :&lt;/code&gt; 를 입력하여 command mode 를 실행한 후 &lt;code&gt;list-buffers&lt;/code&gt; 를 실행하면 현재 저장된 모든 buffer 들을 볼 수 있다. &lt;code&gt;choose-buffer&lt;/code&gt; 를 입력하면 모든 buffer 들의 리스트가 출력되고 원하는 buffer 를 선택할 수 있다. &lt;code&gt;show-buffer&lt;/code&gt; 를 입력하면 0번째 buffer 의 내용을 보여준다. 참고로 &lt;code&gt;ctrl + b, ]&lt;/code&gt; 는 무조건 0번째 buffer 를 붙여넣기 한다.&lt;/p&gt;
&lt;h1&gt;Start with script&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;session&lt;/em&gt; 을 만들고, 화면을 분할하고, 특정 directory 를 생성하고, 패키지를 설치하고, 기타 필요한 작업들을 script 로 작성하여 &lt;em&gt;session&lt;/em&gt; 을 생성할 때 한꺼번에 수행되도록 할 수 있다.&lt;/p&gt;
&lt;p&gt;tmux initilizing automation script example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ cat start_with_tmux.sh
&lt;span class="c1"&gt;#!/bin/bash&lt;/span&gt;
&lt;span class="nv"&gt;SESSION&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;tmuxtest
&lt;span class="nv"&gt;PROJECT_HOME&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;~/Projects&amp;quot;&lt;/span&gt;
&lt;span class="nv"&gt;PROJECT_NAME&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;1&lt;/span&gt;&lt;span class="k"&gt;:-&lt;/span&gt;&lt;span class="nv"&gt;node&lt;/span&gt;&lt;span class="p"&gt;-project&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;
&lt;span class="nv"&gt;TMUX&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;tmux&amp;quot;&lt;/span&gt;
&lt;span class="c1"&gt;# Create new session&lt;/span&gt;
&lt;span class="nv"&gt;$TMUX&lt;/span&gt; new-session -d -s &lt;span class="nv"&gt;$SESSION&lt;/span&gt;
&lt;span class="c1"&gt;# Create new windows&lt;/span&gt;
&lt;span class="nv"&gt;$TMUX&lt;/span&gt; new-window -t &lt;span class="nv"&gt;$SESSION&lt;/span&gt;:1 -n withindex
&lt;span class="nv"&gt;$TMUX&lt;/span&gt; new-window -t &lt;span class="nv"&gt;$SESSION&lt;/span&gt; -n withoutindex
&lt;span class="c1"&gt;# Select window&lt;/span&gt;
&lt;span class="nv"&gt;$TMUX&lt;/span&gt; &lt;span class="k"&gt;select&lt;/span&gt;-window -t withindex
&lt;span class="c1"&gt;# Split window&lt;/span&gt;
&lt;span class="nv"&gt;$TMUX&lt;/span&gt; split-window -h
&lt;span class="c1"&gt;# Select pane and run commands&lt;/span&gt;
&lt;span class="nv"&gt;$TMUX&lt;/span&gt; &lt;span class="k"&gt;select&lt;/span&gt;-pane -t 0
&lt;span class="nv"&gt;$TMUX&lt;/span&gt; send-keys &lt;span class="s2"&gt;&amp;quot;mkdir -p &lt;/span&gt;&lt;span class="nv"&gt;$PROJECT_HOME&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; Enter
&lt;span class="nv"&gt;$TMUX&lt;/span&gt; send-keys &lt;span class="s2"&gt;&amp;quot;cd &lt;/span&gt;&lt;span class="nv"&gt;$PROJECT_HOME&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; Enter
&lt;span class="nv"&gt;$TMUX&lt;/span&gt; send-keys &lt;span class="s2"&gt;&amp;quot;echo &amp;#39;date&amp;#39; &amp;gt; test.txt&amp;quot;&lt;/span&gt; Enter
&lt;span class="nv"&gt;$TMUX&lt;/span&gt; split-window -v
&lt;span class="c1"&gt;# C-m means Carriage Return (one of control characters)&lt;/span&gt;
&lt;span class="nv"&gt;$TMUX&lt;/span&gt; send-keys &lt;span class="s2"&gt;&amp;quot;cd &lt;/span&gt;&lt;span class="nv"&gt;$PROJECT_HOME&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; Enter
&lt;span class="nv"&gt;$TMUX&lt;/span&gt; send-keys &lt;span class="s2"&gt;&amp;quot;tail -f test.txt&amp;quot;&lt;/span&gt; C-m
&lt;span class="c1"&gt;# Select pane and run commands&lt;/span&gt;
&lt;span class="nv"&gt;$TMUX&lt;/span&gt; &lt;span class="k"&gt;select&lt;/span&gt;-pane -t 2
&lt;span class="nv"&gt;$TMUX&lt;/span&gt; send-keys &lt;span class="s2"&gt;&amp;quot;ls -ail&amp;quot;&lt;/span&gt; Enter
References
http://tmux.github.io/
https://github.com/tmux/tmux
http://haruair.com/blog/2124
http://nodeqa.com/nodejs_ref/99
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Summary&lt;/h1&gt;
&lt;h2&gt;Sessions&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;start new session : &lt;code&gt;tmux&lt;/code&gt;, &lt;code&gt;tmux new-session -s testsession&lt;/code&gt;, &lt;code&gt;tmux new -s testsession&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;attach session : &lt;code&gt;tmux attach-session -t testsession&lt;/code&gt;, &lt;code&gt;tmux attach -t testsession&lt;/code&gt;, &lt;code&gt;tmux a -t testsession&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;detach current session : &lt;code&gt;ctrl + b, d&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;list sessions : &lt;code&gt;tmux list-sessions&lt;/code&gt;, &lt;code&gt;tmux ls&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;kill session : &lt;code&gt;tmux kill-session -t testsession&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Run tmux commands in tmux session&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;open tmux command prompt : &lt;code&gt;ctrl + b, :&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;list binding keys (shortcuts) : &lt;code&gt;ctrl + b, ?&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Windows&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;create window : &lt;code&gt;ctrl + b, c&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;list windows : &lt;code&gt;ctrl + b, w&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;next window : &lt;code&gt;ctrl + b, n&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;previous window : &lt;code&gt;ctrl + b, p&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;kill window : &lt;code&gt;ctrl + b, &amp;amp;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Panes&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;vertical split : &lt;code&gt;ctrl + b, %&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;horizontal split : &lt;code&gt;ctrl + b, "&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;swap panes : &lt;code&gt;ctrl + b, o&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;show pan numbers : &lt;code&gt;ctrl + b, o&lt;/code&gt; (when the numbers show up, type the key to goto that pane)&lt;/li&gt;
&lt;li&gt;kill pane : &lt;code&gt;ctrl + b, x&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;move the current pane left : &lt;code&gt;ctrl + b, {&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;move the current pane right : &lt;code&gt;ctrl + b, }&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;toggle pane zoom : &lt;code&gt;ctrl + b, z&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Resizing Panes&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Resizes the current pane down : &lt;code&gt;ctrl + b, :&lt;/code&gt; and &lt;code&gt;resize-pane -D&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Resizes the current pane up : &lt;code&gt;ctrl + b, :&lt;/code&gt; and &lt;code&gt;resize-pane -U&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Resizes the current pane left : &lt;code&gt;ctrl + b, :&lt;/code&gt; and &lt;code&gt;resize-pane -L&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Resizes the current pane right : &lt;code&gt;ctrl + b, :&lt;/code&gt; and &lt;code&gt;resize-pane -R&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Resizes the current pane down by 20 cells : &lt;code&gt;ctrl + b, :&lt;/code&gt; and &lt;code&gt;resize-pane -D 20&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Resizes the current pane up by 20 cells : &lt;code&gt;ctrl + b, :&lt;/code&gt; and &lt;code&gt;resize-pane -U 20&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Resizes the current pane left by 20 cells : &lt;code&gt;ctrl + b, :&lt;/code&gt; and &lt;code&gt;resize-pane -L 20&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Resizes the current pane right by 20 cells : &lt;code&gt;ctrl + b, :&lt;/code&gt; and &lt;code&gt;resize-pane -R 20&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Copy mode&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Copy mode on : &lt;code&gt;ctrl + b, [&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;References&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://tmux.github.io"&gt;tmux web&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/tmux/tmux"&gt;tmux github&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="tmux"></category></entry></feed>