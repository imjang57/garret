<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>garret - tools</title><link href="https://imjang57.github.io/garret/" rel="alternate"></link><link href="https://imjang57.github.io/garret/feeds/tools.atom.xml" rel="self"></link><id>https://imjang57.github.io/garret/</id><updated>2017-05-05T00:00:00+09:00</updated><entry><title>Vim Configuration</title><link href="https://imjang57.github.io/garret/vim-configuration.html" rel="alternate"></link><published>2017-05-05T00:00:00+09:00</published><updated>2017-05-05T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-05-05:/garret/vim-configuration.html</id><summary type="html">&lt;p&gt;Vim 설정&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Vim Configuration&lt;/h1&gt;
&lt;p&gt;Vim 은 실행 중에 여러 설정들을 필요에따라 바꿔서 사용할 수 있다. 그리고 설정 파일을 생성하여 원하는 설정을 적용할 수도 있다.&lt;/p&gt;
&lt;p&gt;Vim 설정 파일은 보통 &lt;code&gt;.vimrc&lt;/code&gt; 라는 이름으로 생성되는데, 사용자의 Home 밑에 &lt;code&gt;~/.vimrc&lt;/code&gt; 로 생성하면 Vim 이 자동으로 이 파일을 찾아서 파일이 있으면 파일의 내용을 확인하여 설정을 적용한다.&lt;/p&gt;
&lt;h2&gt;Key mapping&lt;/h2&gt;
&lt;p&gt;Vim 에서 Key mapping 할 때 &lt;code&gt;map&lt;/code&gt; 또는 &lt;code&gt;noremap&lt;/code&gt; 을 사용하게 된다.&lt;/p&gt;
&lt;p&gt;Vim 에서 &lt;code&gt;:map j gg&lt;/code&gt; 를 실행하면 &lt;code&gt;j&lt;/code&gt; 가 &lt;code&gt;gg&lt;/code&gt; 로 mapping 되어서 &lt;em&gt;Normal mode&lt;/em&gt; 에서 &lt;code&gt;j&lt;/code&gt; 를 입력하면 &lt;code&gt;gg&lt;/code&gt; 가 실행된다.&lt;/p&gt;
&lt;p&gt;만약 &lt;code&gt;:map j gg&lt;/code&gt;, &lt;code&gt;:map Q j&lt;/code&gt; 를 실행하면 &lt;code&gt;j&lt;/code&gt; 를 눌러도, &lt;code&gt;Q&lt;/code&gt; 를 눌러도 &lt;code&gt;gg&lt;/code&gt; 가 실행된다. &lt;code&gt;Q&lt;/code&gt; 가 &lt;code&gt;j&lt;/code&gt; 로 mapping 되고, 다시 &lt;code&gt;j&lt;/code&gt; 가 &lt;code&gt;gg&lt;/code&gt; 로 mapping 되는 것이다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;:map j gg&lt;/code&gt;, &lt;code&gt;:map Q j&lt;/code&gt;, &lt;code&gt;:map gg Q&lt;/code&gt; 와 같이 무한으로 재귀적으로 참조하게 되면 오류가 발생한다. &lt;code&gt;map&lt;/code&gt; 은 recursive key mapping 을 하기 때문이다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;:map&lt;/code&gt; 과 반대로 &lt;code&gt;:noremap&lt;/code&gt; 은 non-recursive key mapping 이다. &lt;code&gt;:map j gg&lt;/code&gt;, &lt;code&gt;:map Q j&lt;/code&gt;, &lt;code&gt;:map gg Q&lt;/code&gt; 를 해도 오류가 발생하지 않는다. &lt;code&gt;Q&lt;/code&gt; 를 누르면 &lt;code&gt;j&lt;/code&gt; 를 누른 것과 같다. 한 번 key mapping 하여 변환되면 끝이다.&lt;/p&gt;
&lt;p&gt;Vim 은 또한 각 mode 별로 key mapping 을 설정할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;nmap&lt;/code&gt; : display normal mode maps&lt;/li&gt;
&lt;li&gt;&lt;code&gt;imap&lt;/code&gt; : display insert mode maps&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vmap&lt;/code&gt; : display visual and select mode maps&lt;/li&gt;
&lt;li&gt;&lt;code&gt;smap&lt;/code&gt; : display select mode maps&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xmap&lt;/code&gt; : display visual mode maps&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cmap&lt;/code&gt; : display command-line mode maps&lt;/li&gt;
&lt;li&gt;&lt;code&gt;omap&lt;/code&gt; : display operator pending mode maps&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;예를 들어, &lt;code&gt;:nnoremap g gg&lt;/code&gt; 를 실행하면 &lt;em&gt;Normal mode&lt;/em&gt; 에서 &lt;code&gt;g&lt;/code&gt; 를 누르면 &lt;code&gt;gg&lt;/code&gt; 로 non-recursive mapping 을 한다.&lt;/p&gt;
&lt;p&gt;key mapping 을 할 때 특수 기능 키에 대해 mapping 을 하려면 아래 내용을 참고하여 mapping 하자.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;BS&amp;gt;&lt;/code&gt; : Backspace&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Tab&amp;gt;&lt;/code&gt; : Tab&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;CR&amp;gt;&lt;/code&gt; : Enter&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Enter&amp;gt;&lt;/code&gt; : Enter&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Return&amp;gt;&lt;/code&gt; : Enter&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Esc&amp;gt;&lt;/code&gt; : Escape&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Space&amp;gt;&lt;/code&gt; : Space&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Up&amp;gt;&lt;/code&gt; : Up arrow&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Down&amp;gt;&lt;/code&gt; : Down arrow&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Left&amp;gt;&lt;/code&gt; : Left arrow&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Right&amp;gt;&lt;/code&gt; : Right arrow&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;F1&amp;gt;&lt;/code&gt; - &lt;code&gt;&amp;lt;F12&amp;gt;&lt;/code&gt; : Function keys 1 to 12&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#1&lt;/code&gt;, &lt;code&gt;#2&lt;/code&gt; .. &lt;code&gt;#9&lt;/code&gt;, &lt;code&gt;#0&lt;/code&gt; : Function keys F1 to F9, F10&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Insert&amp;gt;&lt;/code&gt; : Insert&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Del&amp;gt;&lt;/code&gt; : Delete&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;Home&amp;gt;&lt;/code&gt; : Home&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;End&amp;gt;&lt;/code&gt; : End&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;PageUp&amp;gt;&lt;/code&gt; : Page-Up&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;PageDown&amp;gt;&lt;/code&gt; : Page-Down&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;만약 &lt;code&gt;:imap ,&amp;lt;Space&amp;gt; &amp;lt;Space&amp;gt;&amp;lt;Space&amp;gt;&amp;lt;Space&amp;gt;&amp;lt;Space&amp;gt;&lt;/code&gt; 와 같이 key mapping 을 하면, &lt;code&gt;,&amp;lt;Space&amp;gt;&lt;/code&gt; 를 입력할 때마다 4개의 Space 가 입력된다.&lt;/p&gt;
&lt;p&gt;key mapping 에 대한 자세한 내용은 &lt;code&gt;:help key-mapping&lt;/code&gt; 또는 &lt;a href="http://vim.wikia.com/wiki/Mapping_keys_in_Vim_-_Tutorial_%28Part_1%29"&gt;Mapping keys in Vim - Tutorial (Part 1)&lt;/a&gt; 을 참고하자.&lt;/p&gt;
&lt;h2&gt;&lt;leader&gt; key&lt;/h2&gt;
&lt;p&gt;Vim 에는 leader key 가 있다. Default 로 &lt;code&gt;\&lt;/code&gt; 가 leader key 로 되어 있는데, 설정에서 이 leader key 를 이용하여 많은 작업들에 대한 단축키를 생성할 수 있다.&lt;/p&gt;
&lt;p&gt;예를 들어, &lt;code&gt;:map &amp;lt;leader&amp;gt;A g&lt;/code&gt; 를 실행하면  &lt;code&gt;\A&lt;/code&gt; 를 입력했을 때 &lt;code&gt;g&lt;/code&gt; 를 실행한 것과 같은 결과를 얻을 수 있게 된다. 이때 leader key 를 누른 후 1초 내에 다음 key 를 입력해야 한다.&lt;/p&gt;
&lt;p&gt;leader key 를 &lt;code&gt;,&lt;/code&gt; 로 변경하려면 &lt;code&gt;:let mapleader=","&lt;/code&gt; 를 실행한다.&lt;/p&gt;
&lt;h1&gt;My &lt;code&gt;.vimrc&lt;/code&gt; file&lt;/h1&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="c"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;Belows are basic vim configurations&lt;/span&gt;
&lt;span class="c"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;Refer `:help quickref` (quickref.txt)&lt;/span&gt;
&lt;span class="nb"&gt;syntax&lt;/span&gt; &lt;span class="k"&gt;on&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="k"&gt;nu&lt;/span&gt;                   &lt;span class="c"&gt;&amp;quot;line numbers&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;tabstop&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="m"&gt;4&lt;/span&gt;            &lt;span class="c"&gt;&amp;quot;tab stop&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;softtabstop&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="m"&gt;4&lt;/span&gt;        &lt;span class="c"&gt;&amp;quot;soft tabstop&lt;/span&gt;
&lt;span class="c"&gt;&amp;quot;set expandtab            &amp;quot;soft tab: fill tab with blank characters(space)&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;shiftwidth&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="m"&gt;4&lt;/span&gt;         &lt;span class="c"&gt;&amp;quot;tab stop for &amp;#39;&amp;gt;&amp;#39; command&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;autoindent&lt;/span&gt;           &lt;span class="c"&gt;&amp;quot;Auto indentation&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;cindent&lt;/span&gt;              &lt;span class="c"&gt;&amp;quot;The C programming language indentation&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;smartindent&lt;/span&gt;          &lt;span class="c"&gt;&amp;quot;smart autoindenting for C programs&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="k"&gt;history&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="m"&gt;100&lt;/span&gt;          &lt;span class="c"&gt;&amp;quot;remember work history&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;hlsearch&lt;/span&gt;             &lt;span class="c"&gt;&amp;quot;hilighting search word&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;showmatch&lt;/span&gt;            &lt;span class="c"&gt;&amp;quot;hilighting matched parentheses : (),{}&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;ruler&lt;/span&gt;                &lt;span class="c"&gt;&amp;quot;show current cursor&amp;#39;s location at lower right side&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;showmode&lt;/span&gt;             &lt;span class="c"&gt;&amp;quot;To be able to see what mode you are in.&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;laststatus&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;         &lt;span class="c"&gt;&amp;quot;always show status bar&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;nobackup&lt;/span&gt;             &lt;span class="c"&gt;&amp;quot;don&amp;#39;t create backup file&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;relativenumber&lt;/span&gt;
&lt;span class="c"&gt;&amp;quot;&amp;quot;set backup               &amp;quot;create backup file&lt;/span&gt;
&lt;span class="c"&gt;&amp;quot;set backupdir=~/vim/backup &amp;quot;set directory where backup file is saved&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;nocompatible&lt;/span&gt;         &lt;span class="c"&gt;&amp;quot;be improved, required&lt;/span&gt;
&lt;span class="k"&gt;colorscheme&lt;/span&gt; evening


&lt;span class="c"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="c"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;belows are encoding configurations&lt;/span&gt;
&lt;span class="c"&gt;&amp;quot;auto detected file encoding list which is used when vim opens file&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nb"&gt;fencs&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;utf&lt;span class="m"&gt;-8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;euc&lt;span class="p"&gt;-&lt;/span&gt;kr&lt;span class="p"&gt;,&lt;/span&gt;cp949&lt;span class="p"&gt;,&lt;/span&gt;cp932&lt;span class="p"&gt;,&lt;/span&gt;euc&lt;span class="p"&gt;-&lt;/span&gt;jp&lt;span class="p"&gt;,&lt;/span&gt;shift&lt;span class="p"&gt;-&lt;/span&gt;jis&lt;span class="p"&gt;,&lt;/span&gt;big5&lt;span class="p"&gt;,&lt;/span&gt;latin1&lt;span class="p"&gt;,&lt;/span&gt;ucs&lt;span class="m"&gt;-2&lt;/span&gt;le
&lt;span class="c"&gt;&amp;quot;Use command :set fileencoding=utf-8 when you change current file&amp;#39;s encoding&lt;/span&gt;


&lt;span class="c"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="c"&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;belows are key mappings&lt;/span&gt;
&lt;span class="nb"&gt;nnoremap&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;leader&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;&lt;span class="k"&gt;q&lt;/span&gt; :&lt;span class="k"&gt;bp&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nb"&gt;nnoremap&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;leader&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;&lt;span class="k"&gt;w&lt;/span&gt; :&lt;span class="k"&gt;bn&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;CR&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Vim 일반 설정 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;set nocompatible&lt;/code&gt; : vi 호환성을 위한 기능을 사용하지 않는다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;syntax on&lt;/code&gt; : syntax highlighing 을 사용한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set nu&lt;/code&gt; : 왼쪽에 line number 를 보여준다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set tabstop=4&lt;/code&gt; : tab size 를 4로 지정한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set softtabstop=4&lt;/code&gt; : tab size 를 4로 지정한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set shiftwidth=4&lt;/code&gt; : tab size 를 4로 지정한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set expandtab&lt;/code&gt; : tag 을 space 로 사용하도록 한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set relativenumber&lt;/code&gt; : line number 를 현재 위치한 line 에서 상대적인 값으로 보여준다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set hlsearch&lt;/code&gt; : &lt;code&gt;/&lt;/code&gt; 로 검색할 때 검색된 문자열에 highlight 를 해준다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set ignorecase&lt;/code&gt; : &lt;code&gt;/&lt;/code&gt; 로 검색할 때 대소문자를 구분하지 않는다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set autoindent&lt;/code&gt; : 새로운 line 을 입력할 때 자동으로 indent 를 적용한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set cindent&lt;/code&gt; : 새로운 line 을 입력할 때 C style 의 indent 를 적용한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set smartindent&lt;/code&gt; : &lt;/li&gt;
&lt;li&gt;&lt;code&gt;set showmode&lt;/code&gt; : 현재 어떤 mode 인지를 status bar 에 보여준다.(NORMAL, INSERT, VISUAL, etc)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set nobackup&lt;/code&gt; : 파일을 열어서 buffer 를 생성할 때 backup 파일을 만들지 않는다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set ruler&lt;/code&gt; : 현재 cursor 의 위치를 하단에 있는 status bar 의 오른쪽에 보여준다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set history=100&lt;/code&gt; : 100 개의 work history 를 저장한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set showmatch&lt;/code&gt; : &lt;code&gt;(&lt;/code&gt; 와 &lt;code&gt;)&lt;/code&gt;, &lt;code&gt;{&lt;/code&gt; 와 &lt;code&gt;}&lt;/code&gt; 등 matched parentheses 에 hlghlight 적용한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set colorscheme evening&lt;/code&gt; : evening color theme 를 사용한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set fences=utf-8,euc-kr,cp949,latin1&lt;/code&gt; : vim 이 파일을 열 때 자동으로 인식할 file encoding 목록을 지정한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Vim key 설정 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;let mapleader = ","&lt;/code&gt; : leader key 를 '\' 에서 ',' 로 변경한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nnoremap &amp;lt;leader&amp;gt;q :bp&amp;lt;CR&amp;gt;&lt;/code&gt; : &lt;code&gt;&amp;lt;leader key&amp;gt; + q&lt;/code&gt; 를 누르면 previous buffer 로 이동한다. &lt;code&gt;:bp&lt;/code&gt; 명령과 같은 일을 한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nnoremap &amp;lt;leader&amp;gt;w :bn&amp;lt;CR&amp;gt;&lt;/code&gt; : &lt;code&gt;&amp;lt;leader key&amp;gt; + w&lt;/code&gt; 를 누르면 next buffer 로 이동한다. &lt;code&gt;:bn&lt;/code&gt; 명령과 같은 일을 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;References&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://jaeheeship.github.io/console/2013/11/15/vimrc-configuration.html"&gt;vim 설정파일 알아보기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://vim.wikia.com/wiki/Mapping_keys_in_Vim_-_Tutorial_%28Part_1%29"&gt;Mapping keys in Vim - Tutorial (Part 1)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="vim"></category></entry><entry><title>Vim Plugin</title><link href="https://imjang57.github.io/garret/vim-plugin.html" rel="alternate"></link><published>2017-05-05T00:00:00+09:00</published><updated>2017-05-05T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-05-05:/garret/vim-plugin.html</id><summary type="html">&lt;p&gt;Vim Plugin&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Vim Plugin&lt;/h1&gt;
&lt;p&gt;Vim 은 &lt;em&gt;Vim script&lt;/em&gt; 라는 자체 스크립트 언어를 제공하여 Plugin 을 만들 수 있게 한다. 이 스크립트들은 &lt;code&gt;plugin-name.vim&lt;/code&gt; 과 같이 vim 이라는 확장자(extension) 을 갖는다. &lt;em&gt;Vim script&lt;/em&gt; 는 &lt;a href="http://www.vim.org/scripts/index.php"&gt;Vim script page&lt;/a&gt; 에 많이 업로드되어 있다.&lt;/p&gt;
&lt;p&gt;환경 설정을 위해 사용되는 &lt;code&gt;.vimrc&lt;/code&gt; 파일도 사실은 &lt;em&gt;Vim script&lt;/em&gt; 이다.&lt;/p&gt;
&lt;p&gt;Vim plugin 은 2가지 종류가 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;filetype plugin : 특정 file type 에 대해서 동작하는 plugin. Default 로 &lt;code&gt;$VIMRUNTIME/ftplugin&lt;/code&gt; directory 에서 관리된다.&lt;/li&gt;
&lt;li&gt;global plugin : 모든 file type 에 대해서 동작하는 plugin. Default 로 &lt;code&gt;$VIMRUNTIME/plugin&lt;/code&gt; directory 에서 관리된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;각 plugin 의 위치가 &lt;code&gt;$VIMRUNTIME&lt;/code&gt; 밑에 꼭 있어야 하는 것은 아니다. Vim plugin 을 관리하는 plugin 을 설치하면 각자가 Runtime path 를 관리하여 &lt;code&gt;~/.vim/bundle&lt;/code&gt; 에 각 plugin 디렉터리를 생성하고 그 하위에 &lt;code&gt;ftplugin&lt;/code&gt; 과 &lt;code&gt;plugin&lt;/code&gt; 등 필요한 디렉터리들을 생성해서 사용하기도 한다.&lt;/p&gt;
&lt;h1&gt;Vundle&lt;/h1&gt;
&lt;p&gt;Vim plugin 을 관리하기 위한 여러 plugin 들이 있는데 나는 &lt;a href="https://github.com/VundleVim/Vundle.vim"&gt;Vundle&lt;/a&gt; 을 사용한다.&lt;/p&gt;
&lt;p&gt;자세한 내용은 &lt;a href="https://github.com/VundleVim/Vundle.vim"&gt;Vundle&lt;/a&gt; 에 가면 설치 방법부터 잘 나와있으니 참고하자.&lt;/p&gt;
&lt;p&gt;설치는 매우 쉽다. git clone 하여 &lt;code&gt;~/.vim/bundle/Vundle.vim&lt;/code&gt; 에 설치하겨 &lt;code&gt;~/.vimrc&lt;/code&gt; 파일에 Vundle 을 위한 설정과 설치하여 사용할 Plugin 목록을 입력해주기만 하면 된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Vundle 은 인터넷을 통해 각 plugin 들을 받아서 &lt;code&gt;~/.vim/bundle&lt;/code&gt; 에 설치한다.&lt;/p&gt;
&lt;h2&gt;My &lt;code&gt;.vimrc&lt;/code&gt; including Vundle&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;
&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;Belows are basic vim configurations
&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;Refer `:help quickref` (quickref.txt)
syntax on
set nu                   &amp;quot;line numbers
set tabstop=4            &amp;quot;tab stop
set softtabstop=4        &amp;quot;soft tabstop
&amp;quot;set expandtab            &amp;quot;soft tab: fill tab with blank characters(space)
set shiftwidth=4         &amp;quot;tab stop for &amp;#39;&amp;gt;&amp;#39; command
set autoindent           &amp;quot;Auto indentation
set cindent              &amp;quot;The C programming language indentation
set smartindent          &amp;quot;smart autoindenting for C programs
set history=100          &amp;quot;remember work history
set hlsearch             &amp;quot;hilighting search word
set showmatch            &amp;quot;hilighting matched parentheses : (),{}
set ruler                &amp;quot;show current cursor&amp;#39;s location at lower right side
set showmode             &amp;quot;To be able to see what mode you are in.
set laststatus=2         &amp;quot;always show status bar
set nobackup             &amp;quot;don&amp;#39;t create backup file
set relativenumber
&amp;quot;set backup               &amp;quot;create backup file
&amp;quot;set backupdir=~/vim/backup &amp;quot;set directory where backup file is saved
set nocompatible         &amp;quot;be improved, required
colorscheme evening


&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;
&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;belows are encoding configurations
&amp;quot;auto detected file encoding list which is used when vim opens file
set fencs=utf-8,euc-kr,cp949,cp932,euc-jp,shift-jis,big5,latin1,ucs-2le
&amp;quot;Use command :set fileencoding=utf-8 when you change current file&amp;#39;s encoding


&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;
&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;belows are key mappings
nnoremap &amp;lt;leader&amp;gt;q :bp&amp;lt;CR&amp;gt;
nnoremap &amp;lt;leader&amp;gt;w :bn&amp;lt;CR&amp;gt;

&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;
&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;&amp;quot;Belows are Vundle Plugin configurations
filetype off

&amp;quot; set the runtime path to include Vundle and initialize
set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()
&amp;quot; alternatively, pass a path where Vundle should install plugins
&amp;quot;call vundle#begin(&amp;#39;~/some/path/here&amp;#39;)

&amp;quot; let Vundle manage Vundle, required
Plugin &amp;#39;VundleVim/Vundle.vim&amp;#39;

&amp;quot; The following are examples of different formats supported.
&amp;quot; Keep Plugin commands between vundle#begin/end.
&amp;quot; plugin on GitHub repo
&amp;quot;Plugin &amp;#39;tpope/vim-fugitive&amp;#39;
&amp;quot; plugin from http://vim-scripts.org/vim/scripts.html
&amp;quot;Plugin &amp;#39;L9&amp;#39;
&amp;quot; Git plugin not hosted on GitHub
&amp;quot;Plugin &amp;#39;git://git.wincent.com/command-t.git&amp;#39;
&amp;quot; git repos on your local machine (i.e. when working on your own plugin)
&amp;quot;Plugin &amp;#39;file:///home/gmarik/path/to/plugin&amp;#39;
&amp;quot; The sparkup vim script is in a subdirectory of this repo called vim.
&amp;quot; Pass the path to set the runtimepath properly.
&amp;quot;Plugin &amp;#39;rstacruz/sparkup&amp;#39;, {&amp;#39;rtp&amp;#39;: &amp;#39;vim/&amp;#39;}
&amp;quot; Install L9 and avoid a Naming conflict if you&amp;#39;ve already installed a
&amp;quot; different version somewhere else.
&amp;quot;Plugin &amp;#39;ascenator/L9&amp;#39;, {&amp;#39;name&amp;#39;: &amp;#39;newL9&amp;#39;}

Plugin &amp;#39;The-NERD-tree&amp;#39;
Plugin &amp;#39;AutoComplPop&amp;#39;
Plugin &amp;#39;majutsushi/tagbar&amp;#39;
Plugin &amp;#39;airblade/vim-gitgutter&amp;#39;
Plugin &amp;#39;vim-airline/vim-airline&amp;#39;
Plugin &amp;#39;vim-airline/vim-airline-themes&amp;#39;
Plugin &amp;#39;kien/ctrlp.vim&amp;#39;
Plugin &amp;#39;pathogen.vim&amp;#39;

let g:airline#extensions#tabline#enabled = 1

let NERDTreeWinPost = &amp;quot;left&amp;quot;

nmap &amp;lt;F7&amp;gt; :NERDTree&amp;lt;CR&amp;gt;
&amp;quot;nmap &amp;lt;F8&amp;gt; :TlistToggle&amp;lt;CR&amp;gt;
nmap &amp;lt;F8&amp;gt; :TagbarToggle&amp;lt;CR&amp;gt;
filetype on

let Tlist_Ctags_Cmd = &amp;quot;/usr/bin/ctags&amp;quot;
let Tlist_Inc_Winwidth = 0
let Tlist_Exit_OnlyWindow = 0
let Tlist_Auto_Open = 0
let Tlist_Use_Right_Window = 1

&amp;quot; All of your Plugins must be added before the following line
call vundle#end()            &amp;quot; required
filetype plugin indent on    &amp;quot; required
&amp;quot; To ignore plugin indent changes, instead use:
&amp;quot;filetype plugin on
&amp;quot;
&amp;quot; Brief help
&amp;quot; :PluginList       - lists configured plugins
&amp;quot; :PluginInstall    - installs plugins; append `!` to update or just
&amp;quot; :PluginUpdate
&amp;quot; :PluginSearch foo - searches for foo; append `!` to refresh local cache
&amp;quot; :PluginClean      - confirms removal of unused plugins; append `!` to
&amp;quot;auto-approve removal
&amp;quot;
&amp;quot; see :h vundle for more details or wiki for FAQ
&amp;quot; Put your non-Plugin stuff after this line

let g:ctrlp_custom_ignore = {
    \ &amp;#39;dir&amp;#39;: &amp;#39;\.git$\|vendor$&amp;#39;,
    \ &amp;#39;file&amp;#39;: &amp;#39;\v\.(exe|so|dll)$&amp;#39;
        \ }
&lt;/pre&gt;&lt;/div&gt;</content><category term="vim"></category></entry><entry><title>Vim Basic Regular Expression</title><link href="https://imjang57.github.io/garret/vim-basic-regular-expression.html" rel="alternate"></link><published>2017-05-04T00:00:00+09:00</published><updated>2017-05-04T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-05-04:/garret/vim-basic-regular-expression.html</id><summary type="html">&lt;p&gt;Vim 에서 사용가능한 정규표현식의 기본 사용법에 대한 글이다.&lt;/p&gt;</summary><content type="html">&lt;h1&gt;정규 표현식 (regular expression)&lt;/h1&gt;
&lt;p&gt;정규표현식이란 주로 문자열 내에서 검색이나 조작에 사용되는 표현식으로써 특정한 패턴을 가지고 그 패턴에 부합되는 문자열을 찾아내 원하는 일을 수행 할 수가 있다.&lt;/p&gt;
&lt;p&gt;정규표현식은 vim, sed, grep, emacs, perl 등 프로그램이나 프로그래밍 언어 등에서 문자열을 다루는 용도로 사용되고 있다.&lt;/p&gt;
&lt;p&gt;정규표현식이 쓰이는 모든 프로그램에서 동일한 문법으로 정규표현식을 규정하고 있지는 않는다. 기본적인 내용은 모두 같지만 약간의 표현 형식이 다르다. 즉, 이 글에 작성한 내용은 다른 프로그램이나 언어에서 사용하는 정규표현식과 다를 수 있다.&lt;/p&gt;
&lt;p&gt;Vim 의 &lt;code&gt;:help pattern&lt;/code&gt; 을 참고하자.&lt;/p&gt;
&lt;h1&gt;Character&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;[ ]&lt;/code&gt; 안에는 알파벳이나 숫자가 올 수 있고 이 안에 나열되어 있는 문자 중 한 문자를 가리킨다. 즉 [abc] 는 검색에서 한 문자처럼 취급을 받는다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[abc]&lt;/code&gt; : a, b, c 문자 중 한 문자&lt;/li&gt;
&lt;li&gt;&lt;code&gt;b[abc]ll&lt;/code&gt; : ball, bbll, bcll 중 하나&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;[ ]&lt;/code&gt; 안에는 문자의 범위가 들어 갈 수도 있다. 대소문자를 구분하니 주의해야 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[a-z]&lt;/code&gt; : 소문자 a 부터 z 중 한 문자&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[0-9]&lt;/code&gt; : 숫자 0 부터 9 중 한 문자&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[A-Z0-9]&lt;/code&gt; : 대문자 A 부터 Z 와 숫자 0 부터 9 중 한 문자&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;정규표현식에서 &lt;code&gt;.&lt;/code&gt; 은 new line 을 제외한 모든 문자를 가리킨다. 즉 알파벳, 공백과 같은 특수문자, 숫자 모두 &lt;code&gt;.&lt;/code&gt; 로 표현할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;^&lt;/code&gt; 가 &lt;code&gt;[ ]&lt;/code&gt; 안에 들어오면 안에 나열되어 있는 문자를 제외한 다른 모든 문자를 나타낸다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[^a-z]&lt;/code&gt; : 알파벳 소문자를 제외한 모든 문자&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;특수문자는 항상 &lt;code&gt;\&lt;/code&gt; 와 같이 쓰여야 문자 그대로의 의미를 나타낸다. 공백(Space)는 &lt;code&gt;\&lt;/code&gt; 로 Space 앞에 &lt;code&gt;\&lt;/code&gt; 를 붙여주면 된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[A-Z][0-9][0-9]&lt;/code&gt; : 첫문자는 무조건 대문자로 시작하고 곧바로 숫자가 2자리 오는 패턴&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;^&lt;/code&gt; 는 문자열의 가장 처음을 의미한다. Vim 에서 &lt;code&gt;/^The&lt;/code&gt; 로 검색을 하게 되면 줄의 맨 처음에 위치한 The 만 찾게 된다. &lt;code&gt;[ ]&lt;/code&gt; 내에 있던 &lt;code&gt;^&lt;/code&gt; 과 다른 의미이다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$&lt;/code&gt; 는 문자열의 가장 마지막을 의미한다. &lt;code&gt;/today$&lt;/code&gt; 로 검색하면 줄의 마지막에 위치한 today 만 찾게 된다.&lt;/p&gt;
&lt;h1&gt;Iteration&lt;/h1&gt;
&lt;p&gt;반복을 지정하는 표현식은 문자 뒤에 적어 앞에 있는 문자가 몇 개까지 반복되는 지를 지정한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt; : 0 번 이상&lt;/li&gt;
&lt;li&gt;&lt;code&gt;+&lt;/code&gt; : 1 번 이상&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-&lt;/code&gt; : 0번 혹은 1번&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;+&lt;/code&gt; 와 &lt;code&gt;-&lt;/code&gt; 는 전통적인 Vi 에서는 제공되지 않고 Vim 에서만 사용할 수 있다. 물론 리눅스에 설치되어 있는 Vi 는 Vim 이기 때문에 사용 가능하다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ab*&lt;/code&gt; : b 라는 문자가 없을 수도 있고 한번 이상 올 수도 있다. &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;ab&lt;/code&gt;, &lt;code&gt;abb&lt;/code&gt;, &lt;code&gt;abbb&lt;/code&gt;, &lt;code&gt;abbbb&lt;/code&gt;, etc.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ab+&lt;/code&gt; : 반드시 b 라는 문자가 한번 이상 와야 한다. &lt;code&gt;ab&lt;/code&gt;, &lt;code&gt;abb&lt;/code&gt;, &lt;code&gt;abbb&lt;/code&gt;, &lt;code&gt;abbbb&lt;/code&gt;, etc.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ab-&lt;/code&gt; : a 뒤에 b가 올 수도 오지 않을 수 도 있다. &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;ab&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;( )&lt;/code&gt; 를 사용하여 문자열을 반복시킬 수도 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(abc)*&lt;/code&gt; : abc 문자열이 0번 이상 반복&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(abc)+&lt;/code&gt; : abc 문자열이 1번 이상 반복&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Vim 에서 &lt;code&gt;/(abc)*&lt;/code&gt; 로 검색 명령을 내리면 Vim 은 모든 문자가 검색결과로 지정된다. &lt;code&gt;*&lt;/code&gt; 은 0 번도 포함하기 때문이다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt; &amp;gt;&lt;/code&gt; 를 사용하여 문자열의 범위를 한정할 수도 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;\&amp;lt;abc\&amp;gt;&lt;/code&gt; : 정확하게 abc 인 것만 찾는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;정리하면 반드시 줄의 시작은 알파벳 하나 이상으로 시작하고 중간에 하나 이상의 공백 문자 다음에 2개 이상의 숫자가 오는 패턴은 정규표현식으로 다음과 같이 표현된다 : &lt;code&gt;^[A-Za-z]+ +[0-9][0-9]+&lt;/code&gt;&lt;/p&gt;
&lt;h1&gt;Replace&lt;/h1&gt;
&lt;p&gt;Vim 은 검색과 동시에 치환도 가능하다 : &lt;code&gt;:&amp;lt;시작줄 번호&amp;gt;,&amp;lt;끝 번호&amp;gt; s/검색어/바꿀단어/옵션&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:1,10 s/The/the/gc&lt;/code&gt; : 1번째 줄에서 10번째 줄 사이에 있는 "The" 라는 단어를 "the"로 치환&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;g&lt;/code&gt; 라는 옵션은 모든 검색어에 대해 변경을 실시하게 해준다. 만약 &lt;code&gt;g&lt;/code&gt; 옵션이 없을 경우 한 줄에 2 개 이상의 The 가 있을 경우 첫 번째 &lt;code&gt;The&lt;/code&gt; 만 &lt;code&gt;the&lt;/code&gt; 로 변경을 하게 된다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;c&lt;/code&gt; 라는 옵션은 치환이 발생할 때마다 정말 치환할 것인지를 묻는 prompt 를 출력한다.&lt;/p&gt;
&lt;p&gt;이외에 줄 번호를 가리키는 특별한 문자가 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.&lt;/code&gt; : 현재 커서가 놓여 있는 줄의 번호 &lt;/li&gt;
&lt;li&gt;&lt;code&gt;$&lt;/code&gt; : 마지막 줄&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:.,$ s/The/the/g&lt;/code&gt; : 현재에서 마지막 줄까지 모든 &lt;code&gt;The&lt;/code&gt; 를 &lt;code&gt;the&lt;/code&gt; 로 치환&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:1,$ s/\&amp;lt;be\&amp;gt;/BE/g&lt;/code&gt; : 모든 줄에서 다른 단어에 포함되지 않은 &lt;code&gt;be&lt;/code&gt; 라는 단어를 검색하여 대문자 &lt;code&gt;BE&lt;/code&gt; 로 변경&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;또는 아래와 같이 한번에 전체 문서에 대해서 치환을 수행할 수도 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:%s/The/the/g&lt;/code&gt; : 현재에서 마지막 줄까지 모든 &lt;code&gt;The&lt;/code&gt; 를 &lt;code&gt;the&lt;/code&gt; 로 치환. &lt;code&gt;:1,$ s/The/the/g&lt;/code&gt; 와 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;정규표현식과 변수&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;( )&lt;/code&gt; 는 문자열을 하나의 단위로 보게 하는 역할을 하였다. 하지만 치환에 사용 될 경우 변수 역할도 하게 된다.&lt;/p&gt;
&lt;p&gt;정규표현식 &lt;code&gt;([a-z]+) ([0-9]+)&lt;/code&gt; 를 만족하는 문자열 &lt;code&gt;abcd 100&lt;/code&gt; 가 있을 때, 정규표현식에서는 각 &lt;code&gt;( )&lt;/code&gt; 을 하나의 단위로 묶으면서 &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt; 와 같은 변수에 대응을 시킨다. 즉, 첫 번째 &lt;code&gt;( )&lt;/code&gt; 는 &lt;code&gt;1&lt;/code&gt; 이라는 변수에, 두 번째 &lt;code&gt;( )&lt;/code&gt; 는 &lt;code&gt;2&lt;/code&gt; 라는 변수에 저장된다.&lt;/p&gt;
&lt;p&gt;정규표현식의 변수와 Vim 의 치환을 사용하여 앞 뒤 순서를 바꿀 수 있다 : &lt;code&gt;:1,$ s/([a-z]+)( +)([0-9]+)/321/g&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;s/.../.../g&lt;/code&gt; 와 같은 치환 형식에서 찾을 문자열 부분은 세 개의 &lt;code&gt;( )&lt;/code&gt; 로 이루어져 있어서 각각 변수 &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt; 에 저장된다. 그리고 치환할 문자열 부분에서 &lt;code&gt;321&lt;/code&gt; 과 같이 반대 순서로 변수를 나열하여 각 문자열들의 순서를 변경할 수 있게 된다.&lt;/p&gt;</content><category term="vim"></category></entry><entry><title>Vim Basics</title><link href="https://imjang57.github.io/garret/vim-basics.html" rel="alternate"></link><published>2017-05-04T00:00:00+09:00</published><updated>2017-05-04T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-05-04:/garret/vim-basics.html</id><summary type="html">&lt;p&gt;Vim 기본 사용법&lt;/p&gt;</summary><content type="html">&lt;h1&gt;VIM (VI Improved)&lt;/h1&gt;
&lt;p&gt;이 문서는 Vim 의 가장 기본적인 사용법을 정리한 문서이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Web page : http://www.vim.org&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CLI(Command Line Interface) 기반의 Text editor 이다. Linux, Mac, Windows 모두 지원한다. 처음 사용법이 익숙해지기가 어렵지만 한번 익히면 마우스 없이 대부분의 작업들을 빠르게 수행할 수 있다. 리눅스 서버는 대부분 CLI 환경만 제공되기 때문에 리눅스 서버 관리자라면 거의 필수로 익혀야 하는 Text editor 이다.&lt;/p&gt;
&lt;p&gt;Vimscript 라는 것을 작성하여 플러그인을 만들 수 있다. 사용법을 손에 익히고 여러 플러그인을 설치하면 왠만한 IDE 뺨치는 기능을 사용할 수 있다.&lt;/p&gt;
&lt;h1&gt;Vim modes&lt;/h1&gt;
&lt;p&gt;Vim 은 여러가지 모드를 제공한다. 대표적으로 사용되는 모드는 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Normal mode&lt;/em&gt; : where you can execute commands. This is default mode in which Vim starts up.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Insert mode&lt;/em&gt; : where you are simply writing text.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Visual mode&lt;/em&gt; : where you visually select a bunch of text so that you can run a command or operation only on that part of the text.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Vim 을 실행하면 가장 먼저 &lt;em&gt;Normal mode&lt;/em&gt; 상태로 실행된다. 다른 모드에서 &lt;code&gt;ESC&lt;/code&gt; 를 입력하면 &lt;em&gt;Normal mode&lt;/em&gt; 로 돌아온다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Normal mode&lt;/em&gt; 에서 &lt;code&gt;:&lt;/code&gt; 를 입력하면 Command 를 입력할 수 있다. 보통 Command 를 실행할 때 2가지 방법으로 하게 되는데 하나는 &lt;code&gt;:&lt;/code&gt; 를 입력한 후 Command 를 직접 입력하는 것이고, 다른 하나는 단축키를 사용하는 것이다. 2가지 모두 많이 사용되는 방법이다.&lt;/p&gt;
&lt;p&gt;커서 이동, put, yank, delete, search, replace, 기타 등등 대부분의 작업은 &lt;em&gt;Normal mode&lt;/em&gt; 에서 실행된다.&lt;/p&gt;
&lt;h1&gt;Help page&lt;/h1&gt;
&lt;p&gt;Vim 은 기본적으로 built-in help documentation 을 내장하고 있어서 작업 도중에 수시로 help documentation 을 참고할 수 있다.&lt;/p&gt;
&lt;p&gt;Normal mode 에서 &lt;code&gt;:help&lt;/code&gt; command 를 실행하면 확인할 수 있다. 자주 보게 되는 help 내용은 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:help [keyword]&lt;/code&gt; : shows documentation [for keyword]&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:help abbreviation&lt;/code&gt; : help for abbreviations&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:help quickref&lt;/code&gt; : Quick Reference&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:help user-manual&lt;/code&gt; : User Manuals&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;만약 플러그인을 설치할 때 플러그인이 help 를 제공하면 해당 플러그인의 help 문서도 확인가능하다.&lt;/p&gt;
&lt;h1&gt;Switching between modes&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Normal mode&lt;/em&gt; --(&lt;code&gt;i&lt;/code&gt;, &lt;code&gt;I&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;o&lt;/code&gt;, &lt;code&gt;O&lt;/code&gt;, &lt;code&gt;r&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt;)--&amp;gt; Insert mode&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Normal mode&lt;/em&gt; --(&lt;code&gt;v&lt;/code&gt;, &lt;code&gt;V&lt;/code&gt;)--&amp;gt; Visual mode&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Insert mode&lt;/em&gt; --(&lt;code&gt;ESC&lt;/code&gt;)--&amp;gt; Normal mode&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Visual mode&lt;/em&gt; --(&lt;code&gt;ESC&lt;/code&gt;)--&amp;gt; Normal mode&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Move cursor&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;move left / up / right / down : &lt;code&gt;h&lt;/code&gt; / &lt;code&gt;j&lt;/code&gt; / &lt;code&gt;k&lt;/code&gt; / &lt;code&gt;l&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;move left / up / right / down 3 times repeatedly : &lt;code&gt;3h&lt;/code&gt; / &lt;code&gt;3j&lt;/code&gt; / &lt;code&gt;3k&lt;/code&gt; / &lt;code&gt;3l&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;move the cursor to the next word : &lt;code&gt;w&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;move the cursor to the previous word : &lt;code&gt;b&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;go to specific line number : &lt;code&gt;&amp;lt;line-number&amp;gt;G&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;go to head of line : &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;go to tail of line : &lt;code&gt;$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;page up / down : &lt;code&gt;ctrl + b&lt;/code&gt; / &lt;code&gt;ctrl + f&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;page up / down half : &lt;code&gt;ctrl + d&lt;/code&gt; / &lt;code&gt;ctrl + u&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;jump to start of file : &lt;code&gt;gg&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;jump to end of file : &lt;code&gt;G&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;jump to top / bottom / middle of window : &lt;code&gt;H&lt;/code&gt; / &lt;code&gt;L&lt;/code&gt; / &lt;code&gt;M&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;move to previous / next sentence : &lt;code&gt;(&lt;/code&gt; / &lt;code&gt;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;move to previous / next paragraph : &lt;code&gt;{&lt;/code&gt; / &lt;code&gt;}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Editing&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;insert before the curosr : &lt;code&gt;i&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;insert at the beginning of the line : &lt;code&gt;I&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;insert (append) after the cursor : &lt;code&gt;a&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;insert (append) at the End of the line : &lt;code&gt;A&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;append (open) a new line below the current line : &lt;code&gt;o&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;append (open) a new line above the current line : &lt;code&gt;O&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;replace a single character : &lt;code&gt;r&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;replace from current cursor : &lt;code&gt;R&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;join line below to the current one : &lt;code&gt;J&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;exit &lt;em&gt;Insert mode&lt;/em&gt; (swith to &lt;em&gt;Normal mode&lt;/em&gt;) : &lt;code&gt;ESC&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Open and Close file&lt;/h1&gt;
&lt;p&gt;Vim 에서 파일을 열면 &lt;em&gt;buffer&lt;/em&gt; 라는 것을 생성하여 파일의 내용을 메모리에 올린 후 작업을 수행하게 된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Open file (buffer) : &lt;code&gt;:e &amp;lt;path&amp;gt;&lt;/code&gt;, &lt;code&gt;:edit &amp;lt;path&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Save file (buffer) : &lt;code&gt;:w&lt;/code&gt;, &lt;code&gt;:write&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Save file (buffer) as : &lt;code&gt;:saveas &amp;lt;path&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Close file (buffer) : &lt;code&gt;:bd&lt;/code&gt;, &lt;code&gt;:bw&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Quit Vim : &lt;code&gt;:q&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Print Working Directory : &lt;code&gt;:pwd&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Print path of current file : &lt;code&gt;:echo @%&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Print absolute path of current file : &lt;code&gt;echo expand('%:p')&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Use Mark&lt;/h1&gt;
&lt;p&gt;Vim 에서 &lt;em&gt;buffer&lt;/em&gt; 의 특정 위치를 alphabet(a-zA-Z) 으로 마킹할 수 있다. 자세한 내용은 &lt;code&gt;:help mark&lt;/code&gt; 와 &lt;code&gt;:help mark-motions&lt;/code&gt; help page 를 참고하자.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mark current location as a : &lt;code&gt;ma&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;goto mark a : &lt;code&gt;'a&lt;/code&gt; (cursor located on first non-blank character), `a (cursor located on marked character)&lt;/li&gt;
&lt;li&gt;list of marks : &lt;code&gt;:marks&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Abbreviation&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;set abbreviation foo with foooo : &lt;code&gt;:ab foo foooo&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;unset abbreviation foo : &lt;code&gt;:unab foo&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;위의 예의 경우, &lt;em&gt;Insert mode&lt;/em&gt;  에서 foo 와 &lt;SPACEBAR|ENTER&gt; 를 입력하면 foooo 가 입력된다.&lt;/p&gt;
&lt;h1&gt;Cut (Delete), Copy (Yank) and Paste (Put)&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;cut (delete) word : &lt;code&gt;dw&lt;/code&gt; (start from cursor), &lt;code&gt;daw&lt;/code&gt; (whole word)&lt;/li&gt;
&lt;li&gt;cut (delete) current line : &lt;code&gt;dd&lt;/code&gt;, &lt;code&gt;:d&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;cut (delete) 4 lines : &lt;code&gt;4dd&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;cut (delete) to the end of the line : &lt;code&gt;d$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;cut (delete) from cursor to end of current line : &lt;code&gt;D&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;cut (delete) one character of cursor : &lt;code&gt;x&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;cut (delete) one character before cursor : &lt;code&gt;X&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;cut (delete) 3 character of cursor : &lt;code&gt;3x&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;cut (delete) 3 character before cursor : &lt;code&gt;3X&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;cut (delete) lines from 4 to 10 inclusive : &lt;code&gt;:4,10d&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;copy (yank) word : &lt;code&gt;yw&lt;/code&gt; (start from cursor), &lt;code&gt;yaw&lt;/code&gt; (whole word)&lt;/li&gt;
&lt;li&gt;copy (yank) current line : &lt;code&gt;yy&lt;/code&gt;, &lt;code&gt;Y&lt;/code&gt;, &lt;code&gt;:y&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;copy (yank) 4 lines : &lt;code&gt;4yy&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;copy (yank) lines from 4 to 10 inclusive : &lt;code&gt;:4,10y&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;paste (put) at after current : &lt;code&gt;p&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;paste (put) at before current : &lt;code&gt;P&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;cut (delete) from current line to end of text : &lt;code&gt;dG&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;cut (delete) from current line to start of text : &lt;code&gt;dgg&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Undo and Redo&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;undo : &lt;code&gt;u&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;redo : &lt;code&gt;ctrl + r&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Select&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;swith to visual mode to select texts : &lt;code&gt;v&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;swith to visual mode to select line by line : &lt;code&gt;V&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;swith to visual mode to select vertical : &lt;code&gt;Ctrl + v&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can select texts in visual mode using vi move keys such as &lt;code&gt;h&lt;/code&gt;, &lt;code&gt;j&lt;/code&gt;, &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;l&lt;/code&gt;, &lt;code&gt;G&lt;/code&gt;, &lt;code&gt;gg&lt;/code&gt;, &lt;code&gt;w&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;H&lt;/code&gt;, &lt;code&gt;L&lt;/code&gt;, &lt;code&gt;M&lt;/code&gt;, etc. After selection, you can use &lt;code&gt;d&lt;/code&gt; for cut, &lt;code&gt;y&lt;/code&gt; for copy, etc.&lt;/p&gt;
&lt;h1&gt;Search&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;search text : &lt;code&gt;/searchtext&lt;/code&gt; in &lt;em&gt;Normal mode&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you want to search text &lt;em&gt;Hotkeys&lt;/em&gt;, input &lt;code&gt;/Hotkeys&lt;/code&gt;. Searching text is case-sensitive. If you want to ignore case, input &lt;code&gt;:set ignorecase&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;After run &lt;code&gt;/searchtext&lt;/code&gt; command, you can move to next and previous occurrence by &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Vim provide incremental search. This is helpful when you know only a part of the phrase. After &lt;code&gt;:set incsearch&lt;/code&gt;, vim will start searching by everytime you type.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;searchtext&lt;/code&gt; can be regular expression. For example:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;delete lines which are matched to pattern : &lt;code&gt;:g/pattern/d&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;delete empty lines : &lt;code&gt;:g/^$/d&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;delete lines which are include hello : &lt;code&gt;:g/hello/d&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Macro&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;record macro as a : &lt;code&gt;qa&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;stop recording macro : &lt;code&gt;q&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;run macro a : &lt;code&gt;@a&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;rerun last run macro : &lt;code&gt;@@&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;References&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://vim.rtorr.com/"&gt;Vim Cheat Sheet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/rtorr/vim-cheat-sheet"&gt;Vim Cheat Sheet Github&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="vim"></category></entry><entry><title>Vim Basics More</title><link href="https://imjang57.github.io/garret/vim-basics-more.html" rel="alternate"></link><published>2017-05-04T00:00:00+09:00</published><updated>2017-05-04T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-05-04:/garret/vim-basics-more.html</id><summary type="html">&lt;p&gt;Vim 기본 사용법에 대해 더 알면 좋은 내용들에 대한 글이다.&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Vim Basics More&lt;/h1&gt;
&lt;p&gt;Vim 에 대해 추가적으로 알면 좋은 내용들에 대해 정리한 글이다.&lt;/p&gt;
&lt;h1&gt;&lt;em&gt;buffer&lt;/em&gt;, &lt;em&gt;window&lt;/em&gt;, &lt;em&gt;tab&lt;/em&gt;&lt;/h1&gt;
&lt;p&gt;Vim 에서 &lt;em&gt;buffer&lt;/em&gt;  는 열려 있는 파일(file which is opened)를 뜻한다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;window&lt;/em&gt; 는 Vim 이 어떤 것을 출력하기 위한 component 로 &lt;em&gt;buffer&lt;/em&gt; 를 출력하는 방법이다. 사실 Vim 의 &lt;em&gt;buffer&lt;/em&gt; 는 text 만 출력할 수 있는 것이 아니다. Vim 화면을 가로나 세로로 분할하면 이 &lt;em&gt;windows&lt;/em&gt; 가 새로 만들어 지고 각 &lt;em&gt;window&lt;/em&gt; 에 &lt;em&gt;buffer&lt;/em&gt; 가 출력된다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;tab&lt;/em&gt; 은 Vim 의 Layout 이다. 여러 &lt;em&gt;windows&lt;/em&gt; 들의 집합이다. 대부분의 Text editor 나 Internet browser 에서 사용하는 tab 과는 개념이 다르다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A buffer is the in-memory text of a file.&lt;/li&gt;
&lt;li&gt;A window is a viewport on a buffer.&lt;/li&gt;
&lt;li&gt;A tab page is a collection of windows.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;대충 간략하게 정리하면 파일은 &lt;em&gt;buffer&lt;/em&gt; 에 로드되고, &lt;em&gt;buffer&lt;/em&gt; 는 &lt;em&gt;window&lt;/em&gt; 에 의해 출력되고, &lt;em&gt;window&lt;/em&gt; 는 &lt;em&gt;tab&lt;/em&gt; 에 의해 layout 이 결정된다.&lt;/p&gt;
&lt;h2&gt;Vim &lt;em&gt;buffer&lt;/em&gt; management&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;list of current buffers : &lt;code&gt;:ls&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;open new file (buffer) : &lt;code&gt;:e &amp;lt;path&amp;gt;&lt;/code&gt;, &lt;code&gt;:edit &amp;lt;path&amp;gt;&lt;/code&gt; (with enhanced tab completion (put set wildmenu in your .vimrc))&lt;/li&gt;
&lt;li&gt;save file (buffer) : &lt;code&gt;:w&lt;/code&gt;, &lt;code&gt;:write&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;close file (buffer) : &lt;code&gt;:bd&lt;/code&gt;, &lt;code&gt;:bw&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;switch between all open files (buffers) : &lt;code&gt;:b&amp;lt;buffer number&amp;gt;&lt;/code&gt; (&lt;code&gt;:b#&lt;/code&gt; chooses the last visited file)&lt;/li&gt;
&lt;li&gt;previous buffer : &lt;code&gt;:bp&lt;/code&gt;, &lt;code&gt;:bprevious&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;next buffer : &lt;code&gt;:bn&lt;/code&gt;, &lt;code&gt;:bnext&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;delete buffer : &lt;code&gt;:bd [buffer numbers...]&lt;/code&gt;, &lt;code&gt;:bw&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Close all buffer : &lt;code&gt;:%bd&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Close buffer from buffer number 1 to 1000 : &lt;code&gt;:1,1000bd&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;:ls&lt;/code&gt; 를 실행하면 Vim 의 하단에 다음과 같이 현재 열려진 &lt;em&gt;buffer&lt;/em&gt; 들을 보여준다. 아래 화면에서 &lt;em&gt;buffer&lt;/em&gt; 를 선택하여 이동할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;1 %a   &amp;quot;./checkin.pl&amp;quot;            line 1
2 #    &amp;quot;./grabakamailogs.pl&amp;quot;     line 1
3      &amp;quot;./grabwmlogs.pl&amp;quot;         line 0
  etc.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;%&lt;/code&gt; 는 현재 편집 중인 &lt;em&gt;buffer&lt;/em&gt; (current buffer) 를 참조한다. &lt;code&gt;#&lt;/code&gt; 는 직전에 편집하던 &lt;em&gt;buffer&lt;/em&gt; (alternative buffer) 를 참조한다. &lt;code&gt;ctrl + shift + 6&lt;/code&gt; 를 실행하면 두 &lt;em&gt;buffer&lt;/em&gt; 사이를 switch 한다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;e &amp;lt;path&amp;gt;&lt;/code&gt; 를 실행하면 새로운 &lt;em&gt;buffer&lt;/em&gt; 를 만들고 전달 받은 파일의 내용을 로드한다. &lt;code&gt;:e foo.txt bar.txt&lt;/code&gt;, &lt;code&gt;e /foo/bar/*.txt&lt;/code&gt; 와 같이 한 번에 여러 &lt;em&gt;buffer&lt;/em&gt; 를 생성하지는 못한다. 만약, 여러 파일을 한 번에 열고 싶으면 처음에 Vim 을 실행할 때 &lt;code&gt;Vim file1.txt file2.txt&lt;/code&gt; 와 같이 실행하면 된다. 아니면 &lt;code&gt;arga [paths...]&lt;/code&gt; 를 실행하면 여러 파일들로 새로운 &lt;em&gt;buffer&lt;/em&gt; 를 생성하고 대신 새로운 &lt;em&gt;buffer&lt;/em&gt; 로 switch 를 하지는 않는다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;:arga foo.txt bar.txt
:argadd /foo/bar/*.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Install &lt;em&gt;BufOnly&lt;/em&gt; plugin&lt;/h2&gt;
&lt;p&gt;Vim 으로 &lt;em&gt;buffer&lt;/em&gt; 를 사용하다보면 불편할 때가 있는데, 예를 들면 지금 편집중인 &lt;em&gt;buffer&lt;/em&gt; 를 빼고 나머지 &lt;em&gt;buffer&lt;/em&gt; 들을 모두 닫고 싶을 때이다. &lt;code&gt;:ls&lt;/code&gt; 로 현재 생성되어 있는 &lt;em&gt;buffer&lt;/em&gt; 를 확인하고 &lt;code&gt;bd &amp;lt;buffer number&amp;gt;&lt;/code&gt; 로 일일이 하나씩 &lt;em&gt;buffer&lt;/em&gt; 를 삭제해야 한다. 그래서 나는 &lt;em&gt;BufOnly&lt;/em&gt; 라는 plugin 을 설치해서 사용한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Download &lt;code&gt;BufOnly.vim&lt;/code&gt; Vimscript at &lt;a href="http://www.vim.org/scripts/script.php?script_id=1071"&gt;BufOnly page&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Goto &lt;code&gt;$VIMRUNTIME&lt;/code&gt; : &lt;code&gt;:echo $VIMRUNTIME&lt;/code&gt;, &lt;code&gt;:!explorer $VIMRUNTIME&lt;/code&gt; in Vim.&lt;/li&gt;
&lt;li&gt;Copy downloaded &lt;code&gt;BufOnly.vim&lt;/code&gt; to &lt;code&gt;$VIMRUNTIME&lt;/code&gt; directory or &lt;code&gt;~/.vim/plugin/BufOnly.vim&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Restart Vim&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;참고로 &lt;code&gt;$VIMRUNTIME&lt;/code&gt; 은 Vim 실행 후 &lt;em&gt;Normal mode&lt;/em&gt; 에서 &lt;code&gt;:echo $VIMRUNTIME&lt;/code&gt; 으로 확인할 수 있으며 Vim 이 실행되는 root path 이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;close buffers : &lt;code&gt;:BufOnly [buffer number]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Vim &lt;em&gt;window&lt;/em&gt; management&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;split window horizontal : &lt;code&gt;:sp [path]&lt;/code&gt;, &lt;code&gt;:split [path]&lt;/code&gt;, &lt;code&gt;Ctrl + w, s&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;split window vertical : &lt;code&gt;vs [path]&lt;/code&gt;, &lt;code&gt;:vertical split [path]&lt;/code&gt;, &lt;code&gt;Ctrl + w, v&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;resize all windows same : &lt;code&gt;Ctrl - w, =&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;resize horizontal : &lt;code&gt;:resize 60&lt;/code&gt;, &lt;code&gt;:res 60&lt;/code&gt;, &lt;code&gt;:resize +5&lt;/code&gt;, &lt;code&gt;:res +5&lt;/code&gt;, &lt;code&gt;:resize -5&lt;/code&gt;, &lt;code&gt;:res -5&lt;/code&gt;, &lt;code&gt;ctrl + w, +&lt;/code&gt;, &lt;code&gt;ctrl + w, -&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;resize vertical :  &lt;code&gt;:vertical resize 60&lt;/code&gt;, &lt;code&gt;:vertical res 60&lt;/code&gt;, &lt;code&gt;:vertical resize +5&lt;/code&gt;, &lt;code&gt;:vertical res +5&lt;/code&gt;, &lt;code&gt;:vertical resize -5&lt;/code&gt;, &lt;code&gt;:vertical res -5&lt;/code&gt;, &lt;code&gt;ctrl + w, &amp;gt;&lt;/code&gt;, &lt;code&gt;ctrl + w, &amp;lt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;switch between splitscreens : &lt;code&gt;ctrl + w, arrow key&lt;/code&gt;, &lt;code&gt;ctrl + w, &amp;lt;h|j|k|l&amp;gt;&lt;/code&gt;, &lt;code&gt;ctrl + w, n&lt;/code&gt;, &lt;code&gt;ctrl + w, p&lt;/code&gt;, &lt;code&gt;ctrl + w, w&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;close the current window : &lt;code&gt;ctrl + w, c&lt;/code&gt;, &lt;code&gt;:q&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;close all windows except the current one : &lt;code&gt;ctrl + w, o&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To resize in different steps, you can create maps that will adjust the window size differently. For example to increase the window size by a factor of 1.5 and decrease the window size by 0.67, you can map this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;nnoremap &amp;lt;silent&amp;gt; &amp;lt;Leader&amp;gt;+ :exe &amp;quot;resize &amp;quot; . (winheight(0) * 3/2)&amp;lt;CR&amp;gt;
nnoremap &amp;lt;silent&amp;gt; &amp;lt;Leader&amp;gt;- :exe &amp;quot;resize &amp;quot; . (winheight(0) * 2/3)&amp;lt;CR&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Vim &lt;em&gt;tab&lt;/em&gt; management&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;add new tab : &lt;code&gt;:tabe &amp;lt;path&amp;gt;&lt;/code&gt;, &lt;code&gt;:tabedit &amp;lt;path&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;add buffer to tab : &lt;code&gt;:&amp;lt;tab number&amp;gt;tabe &amp;lt;path&amp;gt;&lt;/code&gt;, &lt;code&gt;:&amp;lt;tab number&amp;gt;tabedit &amp;lt;path&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;close tab : &lt;code&gt;:tabc&lt;/code&gt;, &lt;code&gt;:tabclose&lt;/code&gt;, &lt;code&gt;:&amp;lt;tab number&amp;gt;tabc&lt;/code&gt;, &lt;code&gt;:&amp;lt;tab number&amp;gt;tabclose&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;switch between tabs : &lt;code&gt;:tabn&lt;/code&gt;, &lt;code&gt;:tabnext&lt;/code&gt;, &lt;code&gt;:tabp&lt;/code&gt;, &lt;code&gt;:tabprevious&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;switch to next tab by number : &lt;code&gt;gt&lt;/code&gt;, &lt;code&gt;&amp;lt;number&amp;gt;gt&lt;/code&gt;, &lt;code&gt;ctrl + PageDown&lt;/code&gt;, &lt;code&gt;&amp;lt;number&amp;gt;ctrl + PageDown&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;switch to previous tab by number : &lt;code&gt;gT&lt;/code&gt;, &lt;code&gt;&amp;lt;number&amp;gt;gT&lt;/code&gt;, &lt;code&gt;ctrl + PageUp&lt;/code&gt;, &lt;code&gt;&amp;lt;number&amp;gt;ctrl + PageUp&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;go to tab : &lt;code&gt;:tabmove &amp;lt;tab number&amp;gt;&lt;/code&gt;, &lt;code&gt;:tabm &amp;lt;tab number&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you map &lt;code&gt;:tabn&lt;/code&gt; and &lt;code&gt;:tabp&lt;/code&gt; to your &lt;code&gt;F7&lt;/code&gt; and &lt;code&gt;F8&lt;/code&gt; keys you can easily switch between files.&lt;/p&gt;
&lt;h1&gt;Selection&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;- select : &lt;code&gt;v, [h|j|k|l|g|G|...]&lt;/code&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;- select vertical : &lt;code&gt;ctrl + v, [h|j|k|l|g|G|...]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1&gt;Indentation&lt;/h1&gt;
&lt;p&gt;In command mode,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;indent current line by shiftwidth spaces : &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;:&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;de-indent current line by shiftwidth spaces : &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;:&amp;lt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;re-indent current line : &lt;code&gt;==&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;indent 5 lines : &lt;code&gt;5&amp;gt;&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;de-indent 5 lines : &lt;code&gt;5&amp;lt;&amp;lt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;re-indent 5 lines : &lt;code&gt;5==&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;indent lines 4 to 8, inclusive : &lt;code&gt;:4,8&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;indent selected lines : Select lines and use &lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;increase indent of a curly-braces block : put cursor on one of the curly braces and use &lt;code&gt;&amp;gt;, %&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;decrease indent of a curly-braces block : put cursor on one of the curly braces and use &lt;code&gt;&amp;lt;, %&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;re-indent a curly-braces block : put cursor on one of the curly braces and use &lt;code&gt;=, %&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Paste text, aligning indentation with surroundings : &lt;code&gt;]p&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;re-indent entire buffer : &lt;code&gt;gg=G&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In insert mode,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;insert indent at start of line : &lt;code&gt;ctrl + t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;remove indent at start of line : &lt;code&gt;ctrl + d&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;vim settings in &lt;code&gt;.vimrc&lt;/code&gt; file for indentation:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;set expandtab       &amp;quot;Use softtabstop spaces instead of tab characters for indentation
set shiftwidth=4    &amp;quot;Indent by 4 spaces when using &amp;gt;&amp;gt;, &amp;lt;&amp;lt;, == etc.
set softtabstop=4   &amp;quot;Indent by 4 spaces when pressing &amp;lt;TAB&amp;gt;

set autoindent      &amp;quot;Keep indentation from previous line
set smartindent     &amp;quot;Automatically inserts indentation in some cases
set cindent         &amp;quot;Like smartindent, but stricter and more customisable
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Vim has intelligent indentation based on filetype. Try adding this to your &lt;code&gt;.vimrc&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="k"&gt;has&lt;/span&gt; (&lt;span class="s"&gt;&amp;quot;autocmd&amp;quot;&lt;/span&gt;)
    &amp;quot; &lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="n"&gt;detection&lt;/span&gt;. &lt;span class="n"&gt;Indent&lt;/span&gt; &lt;span class="n"&gt;based&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt; &lt;span class="n"&gt;filetype&lt;/span&gt;. &lt;span class="n"&gt;Recommended&lt;/span&gt;.
    &lt;span class="n"&gt;filetype&lt;/span&gt; &lt;span class="n"&gt;plugin&lt;/span&gt; &lt;span class="n"&gt;indent&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt;
&lt;span class="n"&gt;endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Folding&lt;/h1&gt;
&lt;p&gt;여러 line 들을 folding 하면 필요 없는 부분들을 숨겨서 긴 source code 등을 보는데 더 수월할 때가 많다.&lt;/p&gt;
&lt;p&gt;folding 을 하는 가장 기본적인 방법은 원하는 line 들을 선택한 후 &lt;code&gt;z, f&lt;/code&gt;, &lt;code&gt;:fold&lt;/code&gt;, &lt;code&gt;:fo&lt;/code&gt; 를 실행하는 것이다.&lt;/p&gt;
&lt;p&gt;unfolding 은 folding 된 line 에서 &lt;code&gt;z, o&lt;/code&gt;, &lt;code&gt;:foldopen&lt;/code&gt;, &lt;code&gt;:foldo&lt;/code&gt; 중 하나를 실행하면 된다.&lt;/p&gt;
&lt;p&gt;자세한 내용은 &lt;code&gt;:help fold&lt;/code&gt; 를 참고하자.&lt;/p&gt;
&lt;h1&gt;Get the name of the current file&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Register &lt;code&gt;%&lt;/code&gt; contains the name of the current file&lt;/li&gt;
&lt;li&gt;Register &lt;code&gt;#&lt;/code&gt; contains the name of the alternate file.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;현재 작업 중인 buffer 의 file name 을 확인하려면 register &lt;code&gt;%&lt;/code&gt; 를 확인하면 된다 : &lt;code&gt;:echo @%&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;기타 file path 를 확인하기 위한 command :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:echo expand('%:t')&lt;/code&gt; : &lt;code&gt;my.txt&lt;/code&gt;, name of file ('tail')&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:echo expand('%:p')&lt;/code&gt; : &lt;code&gt;/abc/def/my.txt&lt;/code&gt;, full path&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:echo expand('%:p:h')&lt;/code&gt; : &lt;code&gt;/abc/def&lt;/code&gt;, directory containing file ('head')&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:echo expand('%:p:h:t')&lt;/code&gt; : &lt;code&gt;dev&lt;/code&gt;, First get the full path with &lt;code&gt;:p&lt;/code&gt; (&lt;code&gt;/abc/def/my.txt&lt;/code&gt;), then get the head of that with &lt;code&gt;:h&lt;/code&gt; (&lt;code&gt;/abc/def&lt;/code&gt;), then get the tail of that with &lt;code&gt;:t&lt;/code&gt; (&lt;code&gt;def&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:echo expand('%:r')&lt;/code&gt; : &lt;code&gt;my&lt;/code&gt;, name of file less one extension ('root')&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:echo expand('%:e')&lt;/code&gt; : &lt;code&gt;txt&lt;/code&gt; name of file's extension ('extension')&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For more info run &lt;code&gt;:help expand&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;If all that is wanted is to display the name of the current file, type &lt;code&gt;Ctrl-G&lt;/code&gt; (or press &lt;code&gt;1 then Ctrl-G&lt;/code&gt; for the full path).&lt;/p&gt;
&lt;p&gt;When using &lt;code&gt;@%&lt;/code&gt;, the name is displayed relative to the current directory.&lt;/p&gt;</content><category term="vim"></category></entry><entry><title>JVM Process monitoring with JDK tools</title><link href="https://imjang57.github.io/garret/jvm-process-monitoring-with-jdk-tools.html" rel="alternate"></link><published>2017-01-18T00:00:00+09:00</published><updated>2017-01-18T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-18:/garret/jvm-process-monitoring-with-jdk-tools.html</id><summary type="html">&lt;p&gt;JDK Tools 을 사용하여 JVM Process 를 모니터링하는 방법에 대한 소개&lt;/p&gt;</summary><content type="html">&lt;h1&gt;JVM Process monitoring&lt;/h1&gt;
&lt;p&gt;요즘 일 때문에 오랜만에 자바를 사용하고 있고, 스칼라에 관심이 생겨 공부해보고 있다. 그런데 둘다 &lt;em&gt;JVM&lt;/em&gt; 기반 언어다 보니 JVM 에 대해 알아야 겠다는 생각이 들었다. (사실 일하다가 JVM 모니터링 할 일이 생긴 김에 간단하게 정리한다.) 어쨌든 둘 다 JVM 에서 동작하는 녀석들이라 JVM 모니터링에 대해 간단하게 남겨보고자 한다.&lt;/p&gt;
&lt;p&gt;자바든 스칼라든 실행되면 JVM 프로세스이다. 자바나 스칼라로 쓰여진 코드는 Java Bytecode 로 컴파일되고, JVM 은 이 Bytecode 를 실행한다. 그러므로 컴파일 된 이후에는 자바로 작성했든 스칼라로 작성했든 JVM 입장에서는 그냥 똑같은 Bytecode 이다. 그러니 같은 방법(JVM Process monitoring)으로 모니터링할 수 있다.&lt;/p&gt;
&lt;h1&gt;JVM Monitoring tools&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;JDK (Java Development Kit)&lt;/em&gt; 를 설치하면 기본적으로 자바 코드를 컴파일하기 위한 &lt;code&gt;javac&lt;/code&gt;, 컴파일된 bytecode 를 실행하는 &lt;code&gt;java&lt;/code&gt; 를 제공한다. 그리고 개발자들을 위한 다양한 도구들을 기본적으로 제공한다. 모니터링을 위해서 아래 도구들을 사용가능하다.(물론 아래 도구들 외에 더 많다.)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;jps&lt;/code&gt; : JVM Process Status&lt;/li&gt;
&lt;li&gt;&lt;code&gt;jstat&lt;/code&gt; : JVM Statistics&lt;/li&gt;
&lt;li&gt;&lt;code&gt;jhat&lt;/code&gt; : Java Heap Analysis Tool&lt;/li&gt;
&lt;li&gt;&lt;code&gt;jstack&lt;/code&gt; : Java thread Stack traces&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;VisualVM&lt;/em&gt; 과 같은 GUI 도구도 있지만 어쨌든 기본은 CLI 도구들이고, GUI 도구들도 CLI 도구들을 이용하는 형태이다.&lt;/p&gt;
&lt;h1&gt;JVM Monitoring&lt;/h1&gt;
&lt;p&gt;JVM 프로세스를 모니터링하려면 당연히 JVM 프로세스가 있어야 한다. 테스트 프로그램은 임시로 tomcat 을 사용하였다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;yum install -y tomcat&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;passwd tomcat&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/etc/passwd&lt;/code&gt; 파일에서 tomcat 계정의 login shell 을 bash 로 지정&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sudo service tomcat start&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;tomcat 계정으로 전환(&lt;code&gt;su - tomcat&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;jps : JVM Process Status&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;jps&lt;/code&gt; 를 실행하면 JVM Process 목록과 PID 를 확인할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ jps
&lt;span class="m"&gt;17285&lt;/span&gt; Bootstrap
&lt;span class="m"&gt;17322&lt;/span&gt; Jps
$ jps -m
&lt;span class="m"&gt;17285&lt;/span&gt; Bootstrap start
&lt;span class="m"&gt;17398&lt;/span&gt; Jps -m
$ jps -ml
&lt;span class="m"&gt;17285&lt;/span&gt; org.apache.catalina.startup.Bootstrap start
&lt;span class="m"&gt;17413&lt;/span&gt; sun.tools.jps.Jps -ml
$
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;jstat: JVM Statistics&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;jps&lt;/code&gt; 에서 확인한 PID 로 &lt;code&gt;jstat&lt;/code&gt; 를 실행할 수 있다. 위에서 tomcat 을 실행하는 Bootstrap 의 PID 가 17285 이므로 이를 이용하여 &lt;code&gt;jstat&lt;/code&gt; 을 실행하였다. 그리고 1000 밀리초 단위로 통계치를 수집하도록 하였다. 결과는 퍼센트(%)로 출력된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ jstat -gcutil &lt;span class="m"&gt;17285&lt;/span&gt; 1000
  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT   
  0.00  98.44  60.41   5.27  96.61  89.46      &lt;span class="m"&gt;1&lt;/span&gt;    0.005     &lt;span class="m"&gt;0&lt;/span&gt;    0.000    0.005
  0.00  98.44  60.41   5.27  96.61  89.46      &lt;span class="m"&gt;1&lt;/span&gt;    0.005     &lt;span class="m"&gt;0&lt;/span&gt;    0.000    0.005
  0.00  98.44  60.41   5.27  96.61  89.46      &lt;span class="m"&gt;1&lt;/span&gt;    0.005     &lt;span class="m"&gt;0&lt;/span&gt;    0.000    0.005
  0.00  98.44  60.41   5.27  96.61  89.46      &lt;span class="m"&gt;1&lt;/span&gt;    0.005     &lt;span class="m"&gt;0&lt;/span&gt;    0.000    0.005
  0.00  98.44  60.41   5.27  96.61  89.46      &lt;span class="m"&gt;1&lt;/span&gt;    0.005     &lt;span class="m"&gt;0&lt;/span&gt;    0.000    0.005
$
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;위에서처럼 &lt;code&gt;-gcutil&lt;/code&gt; 옵션을 사용하면 Java Heap 현황을 확인할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;GCT&lt;/em&gt; : Garbage Collection Time (seconds, 누적)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;FGCT&lt;/em&gt; : Full GCT (seconds, 누적)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;FGC&lt;/em&gt; : Full Garbage Collection 발생 회수&lt;/li&gt;
&lt;li&gt;&lt;em&gt;M&lt;/em&gt; : Metaspace 영역의 사용률&lt;/li&gt;
&lt;li&gt;&lt;em&gt;S0&lt;/em&gt; : Survivor 0 영역의 사용률&lt;/li&gt;
&lt;li&gt;&lt;em&gt;S1&lt;/em&gt; : Survivor 1 영역의 사용률&lt;/li&gt;
&lt;li&gt;&lt;em&gt;E&lt;/em&gt; : Eden 영역의 사용률&lt;/li&gt;
&lt;li&gt;&lt;em&gt;O&lt;/em&gt; : Old 영역의 사용률&lt;/li&gt;
&lt;li&gt;&lt;em&gt;CCS&lt;/em&gt; : Compressed Class Space (part of metaspace)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;YGC&lt;/em&gt; : Young GC 발생 회수&lt;/li&gt;
&lt;li&gt;&lt;em&gt;YGCT&lt;/em&gt; : Young GC Time (seconds, 누적)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;FGCT 열의 값이 계속 증가하면 문제가 있는 것이다.&lt;/p&gt;
&lt;p&gt;M 열은 Metadata 를 위한 힙 영역이다. 이 영역은 자바8부터 M(Metaspace)로 표시되기 시작했고 이전 버전까지는 P(Permgen, Permanent Generation) 영역이라고 불리었다. 클래스의 Metadata, JVM 내부 객체 등이 저장되는 중요한 곳이다. 매우 무조건 자바 프로그램의 경우 이 영역에서 &lt;code&gt;java.lang.OutOfMemoryError&lt;/code&gt; 를 만날 수도 있다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-gcutil&lt;/code&gt; 대신 &lt;code&gt;-gccause&lt;/code&gt; 옵션을 사용하면 &lt;code&gt;-gcutil&lt;/code&gt; 의 결과에 GC 의 원인까지 확인할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ jstat -gccause &lt;span class="m"&gt;17285&lt;/span&gt; 1000
  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT    LGCC                 GCC                 
  0.00  98.44  61.41   5.27  96.61  89.46      &lt;span class="m"&gt;1&lt;/span&gt;    0.005     &lt;span class="m"&gt;0&lt;/span&gt;    0.000    0.005 Allocation Failure   No GC               
  0.00  98.44  61.41   5.27  96.61  89.46      &lt;span class="m"&gt;1&lt;/span&gt;    0.005     &lt;span class="m"&gt;0&lt;/span&gt;    0.000    0.005 Allocation Failure   No GC               
  0.00  98.44  61.41   5.27  96.61  89.46      &lt;span class="m"&gt;1&lt;/span&gt;    0.005     &lt;span class="m"&gt;0&lt;/span&gt;    0.000    0.005 Allocation Failure   No GC               
$
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;&lt;em&gt;LGCC&lt;/em&gt; : 지난 GC의 발생 이유&lt;/li&gt;
&lt;li&gt;&lt;em&gt;GCC&lt;/em&gt; : 현재 GC의 발생 이유&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;jstack: Java thread Stack traces&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;jstack&lt;/code&gt; 을 이용하면 현재 Java 프로세스의 stack dump 를 얻을 수 있다. &lt;code&gt;jstack&lt;/code&gt; 을 이용하면 현재 실행 중인 여러 thread 들의 stack 을 확인할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ jstack 17285
2016-12-26 10:32:20
Full thread dump OpenJDK 64-Bit Server VM &lt;span class="o"&gt;(&lt;/span&gt;25.111-b15 mixed mode&lt;span class="o"&gt;)&lt;/span&gt;:
&lt;span class="s2"&gt;&amp;quot;Attach Listener&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#17 daemon prio=9 os_prio=0 tid=0x00007f48d0001000 nid=0x458b waiting on condition [0x0000000000000000]&lt;/span&gt;
   java.lang.Thread.State: RUNNABLE
&lt;span class="s2"&gt;&amp;quot;ajp-bio-8009-AsyncTimeout&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#15 daemon prio=5 os_prio=0 tid=0x00007f491049c800 nid=0x43a9 waiting on condition [0x00007f48f8ba4000]&lt;/span&gt;
   java.lang.Thread.State: TIMED_WAITING &lt;span class="o"&gt;(&lt;/span&gt;sleeping&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.Thread.sleep&lt;span class="o"&gt;(&lt;/span&gt;Native Method&lt;span class="o"&gt;)&lt;/span&gt;
 at org.apache.tomcat.util.net.JIoEndpoint&lt;span class="nv"&gt;$AsyncTimeout&lt;/span&gt;.run&lt;span class="o"&gt;(&lt;/span&gt;JIoEndpoint.java:152&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.Thread.run&lt;span class="o"&gt;(&lt;/span&gt;Thread.java:745&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;ajp-bio-8009-Acceptor-0&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#14 daemon prio=5 os_prio=0 tid=0x00007f491049a000 nid=0x43a8 runnable [0x00007f48f8ca5000]&lt;/span&gt;
   java.lang.Thread.State: RUNNABLE
 at java.net.PlainSocketImpl.socketAccept&lt;span class="o"&gt;(&lt;/span&gt;Native Method&lt;span class="o"&gt;)&lt;/span&gt;
 at java.net.AbstractPlainSocketImpl.accept&lt;span class="o"&gt;(&lt;/span&gt;AbstractPlainSocketImpl.java:409&lt;span class="o"&gt;)&lt;/span&gt;
 at java.net.ServerSocket.implAccept&lt;span class="o"&gt;(&lt;/span&gt;ServerSocket.java:545&lt;span class="o"&gt;)&lt;/span&gt;
 at java.net.ServerSocket.accept&lt;span class="o"&gt;(&lt;/span&gt;ServerSocket.java:513&lt;span class="o"&gt;)&lt;/span&gt;
 at org.apache.tomcat.util.net.DefaultServerSocketFactory.acceptSocket&lt;span class="o"&gt;(&lt;/span&gt;DefaultServerSocketFactory.java:60&lt;span class="o"&gt;)&lt;/span&gt;
 at org.apache.tomcat.util.net.JIoEndpoint&lt;span class="nv"&gt;$Acceptor&lt;/span&gt;.run&lt;span class="o"&gt;(&lt;/span&gt;JIoEndpoint.java:222&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.Thread.run&lt;span class="o"&gt;(&lt;/span&gt;Thread.java:745&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;ContainerBackgroundProcessor[StandardEngine[Catalina]]&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#13 daemon prio=5 os_prio=0 tid=0x00007f4910497000 nid=0x43a7 waiting on condition [0x00007f48f8da6000]&lt;/span&gt;
   java.lang.Thread.State: TIMED_WAITING &lt;span class="o"&gt;(&lt;/span&gt;sleeping&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.Thread.sleep&lt;span class="o"&gt;(&lt;/span&gt;Native Method&lt;span class="o"&gt;)&lt;/span&gt;
 at org.apache.catalina.core.ContainerBase&lt;span class="nv"&gt;$ContainerBackgroundProcessor&lt;/span&gt;.run&lt;span class="o"&gt;(&lt;/span&gt;ContainerBase.java:1510&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.Thread.run&lt;span class="o"&gt;(&lt;/span&gt;Thread.java:745&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;GC Daemon&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#11 daemon prio=2 os_prio=0 tid=0x00007f491040c800 nid=0x43a5 in Object.wait() [0x00007f48fa637000]&lt;/span&gt;
   java.lang.Thread.State: TIMED_WAITING &lt;span class="o"&gt;(&lt;/span&gt;on object monitor&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.Object.wait&lt;span class="o"&gt;(&lt;/span&gt;Native Method&lt;span class="o"&gt;)&lt;/span&gt;
 - waiting on &amp;lt;0x00000000ecfdd7d0&amp;gt; &lt;span class="o"&gt;(&lt;/span&gt;a sun.misc.GC&lt;span class="nv"&gt;$LatencyLock&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
 at sun.misc.GC&lt;span class="nv"&gt;$Daemon&lt;/span&gt;.run&lt;span class="o"&gt;(&lt;/span&gt;GC.java:117&lt;span class="o"&gt;)&lt;/span&gt;
 - locked &amp;lt;0x00000000ecfdd7d0&amp;gt; &lt;span class="o"&gt;(&lt;/span&gt;a sun.misc.GC&lt;span class="nv"&gt;$LatencyLock&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;Service Thread&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#8 daemon prio=9 os_prio=0 tid=0x00007f49100e1000 nid=0x43a3 runnable [0x0000000000000000]&lt;/span&gt;
   java.lang.Thread.State: RUNNABLE
&lt;span class="s2"&gt;&amp;quot;C1 CompilerThread2&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#7 daemon prio=9 os_prio=0 tid=0x00007f49100ce000 nid=0x43a2 waiting on condition [0x0000000000000000]&lt;/span&gt;
   java.lang.Thread.State: RUNNABLE
&lt;span class="s2"&gt;&amp;quot;C2 CompilerThread1&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#6 daemon prio=9 os_prio=0 tid=0x00007f49100cc800 nid=0x43a1 waiting on condition [0x0000000000000000]&lt;/span&gt;
   java.lang.Thread.State: RUNNABLE
&lt;span class="s2"&gt;&amp;quot;C2 CompilerThread0&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#5 daemon prio=9 os_prio=0 tid=0x00007f49100bf000 nid=0x43a0 waiting on condition [0x0000000000000000]&lt;/span&gt;
   java.lang.Thread.State: RUNNABLE
&lt;span class="s2"&gt;&amp;quot;Signal Dispatcher&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#4 daemon prio=9 os_prio=0 tid=0x00007f49100bc800 nid=0x439f runnable [0x0000000000000000]&lt;/span&gt;
   java.lang.Thread.State: RUNNABLE
&lt;span class="s2"&gt;&amp;quot;Finalizer&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#3 daemon prio=8 os_prio=0 tid=0x00007f4910093000 nid=0x439e in Object.wait() [0x00007f48fb5f4000]&lt;/span&gt;
   java.lang.Thread.State: WAITING &lt;span class="o"&gt;(&lt;/span&gt;on object monitor&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.Object.wait&lt;span class="o"&gt;(&lt;/span&gt;Native Method&lt;span class="o"&gt;)&lt;/span&gt;
 - waiting on &amp;lt;0x00000000edd08988&amp;gt; &lt;span class="o"&gt;(&lt;/span&gt;a java.lang.ref.ReferenceQueue&lt;span class="nv"&gt;$Lock&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.ref.ReferenceQueue.remove&lt;span class="o"&gt;(&lt;/span&gt;ReferenceQueue.java:143&lt;span class="o"&gt;)&lt;/span&gt;
 - locked &amp;lt;0x00000000edd08988&amp;gt; &lt;span class="o"&gt;(&lt;/span&gt;a java.lang.ref.ReferenceQueue&lt;span class="nv"&gt;$Lock&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.ref.ReferenceQueue.remove&lt;span class="o"&gt;(&lt;/span&gt;ReferenceQueue.java:164&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.ref.Finalizer&lt;span class="nv"&gt;$FinalizerThread&lt;/span&gt;.run&lt;span class="o"&gt;(&lt;/span&gt;Finalizer.java:209&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;Reference Handler&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#2 daemon prio=10 os_prio=0 tid=0x00007f491008e800 nid=0x439d in Object.wait() [0x00007f48fb6f5000]&lt;/span&gt;
   java.lang.Thread.State: WAITING &lt;span class="o"&gt;(&lt;/span&gt;on object monitor&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.Object.wait&lt;span class="o"&gt;(&lt;/span&gt;Native Method&lt;span class="o"&gt;)&lt;/span&gt;
 - waiting on &amp;lt;0x00000000edd00970&amp;gt; &lt;span class="o"&gt;(&lt;/span&gt;a java.lang.ref.Reference&lt;span class="nv"&gt;$Lock&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.Object.wait&lt;span class="o"&gt;(&lt;/span&gt;Object.java:502&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.ref.Reference.tryHandlePending&lt;span class="o"&gt;(&lt;/span&gt;Reference.java:191&lt;span class="o"&gt;)&lt;/span&gt;
 - locked &amp;lt;0x00000000edd00970&amp;gt; &lt;span class="o"&gt;(&lt;/span&gt;a java.lang.ref.Reference&lt;span class="nv"&gt;$Lock&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.ref.Reference&lt;span class="nv"&gt;$ReferenceHandler&lt;/span&gt;.run&lt;span class="o"&gt;(&lt;/span&gt;Reference.java:153&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;main&amp;quot;&lt;/span&gt; &lt;span class="c1"&gt;#1 prio=5 os_prio=0 tid=0x00007f4910009000 nid=0x4397 runnable [0x00007f4919dbd000]&lt;/span&gt;
   java.lang.Thread.State: RUNNABLE
 at java.net.PlainSocketImpl.socketAccept&lt;span class="o"&gt;(&lt;/span&gt;Native Method&lt;span class="o"&gt;)&lt;/span&gt;
 at java.net.AbstractPlainSocketImpl.accept&lt;span class="o"&gt;(&lt;/span&gt;AbstractPlainSocketImpl.java:409&lt;span class="o"&gt;)&lt;/span&gt;
 at java.net.ServerSocket.implAccept&lt;span class="o"&gt;(&lt;/span&gt;ServerSocket.java:545&lt;span class="o"&gt;)&lt;/span&gt;
 at java.net.ServerSocket.accept&lt;span class="o"&gt;(&lt;/span&gt;ServerSocket.java:513&lt;span class="o"&gt;)&lt;/span&gt;
 at org.apache.catalina.core.StandardServer.await&lt;span class="o"&gt;(&lt;/span&gt;StandardServer.java:470&lt;span class="o"&gt;)&lt;/span&gt;
 at org.apache.catalina.startup.Catalina.await&lt;span class="o"&gt;(&lt;/span&gt;Catalina.java:781&lt;span class="o"&gt;)&lt;/span&gt;
 at org.apache.catalina.startup.Catalina.start&lt;span class="o"&gt;(&lt;/span&gt;Catalina.java:727&lt;span class="o"&gt;)&lt;/span&gt;
 at sun.reflect.NativeMethodAccessorImpl.invoke0&lt;span class="o"&gt;(&lt;/span&gt;Native Method&lt;span class="o"&gt;)&lt;/span&gt;
 at sun.reflect.NativeMethodAccessorImpl.invoke&lt;span class="o"&gt;(&lt;/span&gt;NativeMethodAccessorImpl.java:62&lt;span class="o"&gt;)&lt;/span&gt;
 at sun.reflect.DelegatingMethodAccessorImpl.invoke&lt;span class="o"&gt;(&lt;/span&gt;DelegatingMethodAccessorImpl.java:43&lt;span class="o"&gt;)&lt;/span&gt;
 at java.lang.reflect.Method.invoke&lt;span class="o"&gt;(&lt;/span&gt;Method.java:498&lt;span class="o"&gt;)&lt;/span&gt;
 at org.apache.catalina.startup.Bootstrap.start&lt;span class="o"&gt;(&lt;/span&gt;Bootstrap.java:294&lt;span class="o"&gt;)&lt;/span&gt;
 at org.apache.catalina.startup.Bootstrap.main&lt;span class="o"&gt;(&lt;/span&gt;Bootstrap.java:428&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;VM Thread&amp;quot;&lt;/span&gt; &lt;span class="nv"&gt;os_prio&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="nv"&gt;tid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00007f4910084800 &lt;span class="nv"&gt;nid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x439c runnable
&lt;span class="s2"&gt;&amp;quot;GC task thread#0 (ParallelGC)&amp;quot;&lt;/span&gt; &lt;span class="nv"&gt;os_prio&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="nv"&gt;tid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00007f491001e000 &lt;span class="nv"&gt;nid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x4398 runnable
&lt;span class="s2"&gt;&amp;quot;GC task thread#1 (ParallelGC)&amp;quot;&lt;/span&gt; &lt;span class="nv"&gt;os_prio&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="nv"&gt;tid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00007f491001f800 &lt;span class="nv"&gt;nid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x4399 runnable
&lt;span class="s2"&gt;&amp;quot;GC task thread#2 (ParallelGC)&amp;quot;&lt;/span&gt; &lt;span class="nv"&gt;os_prio&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="nv"&gt;tid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00007f4910021800 &lt;span class="nv"&gt;nid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x439a runnable
&lt;span class="s2"&gt;&amp;quot;GC task thread#3 (ParallelGC)&amp;quot;&lt;/span&gt; &lt;span class="nv"&gt;os_prio&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="nv"&gt;tid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00007f4910023800 &lt;span class="nv"&gt;nid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x439b runnable
&lt;span class="s2"&gt;&amp;quot;VM Periodic Task Thread&amp;quot;&lt;/span&gt; &lt;span class="nv"&gt;os_prio&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="nv"&gt;tid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x00007f49100ef800 &lt;span class="nv"&gt;nid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;0x43a4 waiting on condition
JNI global references: 44
$
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;References&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.wolfe.id.au/2011/10/16/monitoring-the-openjdk-from-the-cli/"&gt;Monitoring the OpenJDK from the CLI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://d2.naver.com/helloworld/6043"&gt;Garbage Collection 모니터링 방법&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="java"></category><category term="jvm"></category><category term="monitoring"></category><category term="jps"></category><category term="stat"></category><category term="stack"></category></entry><entry><title>Git Basics</title><link href="https://imjang57.github.io/garret/git-basics.html" rel="alternate"></link><published>2017-01-05T00:00:00+09:00</published><updated>2017-01-05T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2017-01-05:/garret/git-basics.html</id><summary type="html">&lt;p&gt;Git 기본 사용법&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Git Basic&lt;/h1&gt;
&lt;p&gt;이 글은 Git 에 대해 기본적인 내용은 알고 있다고 생각하고 정리 목적으로 작성된 글이니 Git 을 아예 모르면 &lt;a href="http://git-scm.com/book/"&gt;Git Book&lt;/a&gt; 을 먼저 숙지하자.&lt;/p&gt;
&lt;p&gt;아래 내용들에 알면 Git 을 잘 사용하기 위한 개념들은 다 알고 있다고 봐도 된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;VCS (Version Control System), DVCS (Distributed Version Control System)&lt;/li&gt;
&lt;li&gt;Working tree, Staging Area (Index), Local Repository, Remote Repository, Bare Repository&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;git help&lt;/code&gt; 명령을 실행하면 사용 가능한 subcommand 들을 확인할 수 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ git &lt;span class="nb"&gt;help&lt;/span&gt;
usage: git &lt;span class="o"&gt;[&lt;/span&gt;--version&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;--help&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;-C &amp;lt;path&amp;gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;-c &lt;span class="nv"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;value&lt;span class="o"&gt;]&lt;/span&gt;
           &lt;span class="o"&gt;[&lt;/span&gt;--exec-path&lt;span class="o"&gt;[=&lt;/span&gt;&amp;lt;path&amp;gt;&lt;span class="o"&gt;]]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;--html-path&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;--man-path&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;--info-path&lt;span class="o"&gt;]&lt;/span&gt;
           &lt;span class="o"&gt;[&lt;/span&gt;-p &lt;span class="p"&gt;|&lt;/span&gt; --paginate &lt;span class="p"&gt;|&lt;/span&gt; --no-pager&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;--no-replace-objects&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;--bare&lt;span class="o"&gt;]&lt;/span&gt;
           &lt;span class="o"&gt;[&lt;/span&gt;--git-dir&lt;span class="o"&gt;=&lt;/span&gt;&amp;lt;path&amp;gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;--work-tree&lt;span class="o"&gt;=&lt;/span&gt;&amp;lt;path&amp;gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;--namespace&lt;span class="o"&gt;=&lt;/span&gt;&amp;lt;name&amp;gt;&lt;span class="o"&gt;]&lt;/span&gt;
           &amp;lt;command&amp;gt; &lt;span class="o"&gt;[&lt;/span&gt;&amp;lt;args&amp;gt;&lt;span class="o"&gt;]&lt;/span&gt;

These are common Git commands used in various situations:

start a working area &lt;span class="o"&gt;(&lt;/span&gt;see also: git &lt;span class="nb"&gt;help&lt;/span&gt; tutorial&lt;span class="o"&gt;)&lt;/span&gt;
   clone      Clone a repository into a new directory
   init       Create an empty Git repository or reinitialize an existing one

work on the current change &lt;span class="o"&gt;(&lt;/span&gt;see also: git &lt;span class="nb"&gt;help&lt;/span&gt; everyday&lt;span class="o"&gt;)&lt;/span&gt;
   add        Add file contents to the index
   mv         Move or rename a file, a directory, or a symlink
   reset      Reset current HEAD to the specified state
   rm         Remove files from the working tree and from the index

examine the &lt;span class="nb"&gt;history&lt;/span&gt; and state &lt;span class="o"&gt;(&lt;/span&gt;see also: git &lt;span class="nb"&gt;help&lt;/span&gt; revisions&lt;span class="o"&gt;)&lt;/span&gt;
   bisect     Use binary search to find the commit that introduced a bug
   grep       Print lines matching a pattern
   log        Show commit logs
   show       Show various types of objects
   status     Show the working tree status

grow, mark and tweak your common &lt;span class="nb"&gt;history&lt;/span&gt;
   branch     List, create, or delete branches
   checkout   Switch branches or restore working tree files
   commit     Record changes to the repository
   diff       Show changes between commits, commit and working tree, etc
   merge      Join two or more development histories together
   rebase     Reapply commits on top of another base tip
   tag        Create, list, delete or verify a tag object signed with GPG

collaborate &lt;span class="o"&gt;(&lt;/span&gt;see also: git &lt;span class="nb"&gt;help&lt;/span&gt; workflows&lt;span class="o"&gt;)&lt;/span&gt;
   fetch      Download objects and refs from another repository
   pull       Fetch from and integrate with another repository or a &lt;span class="nb"&gt;local&lt;/span&gt; branch
   push       Update remote refs along with associated objects

&lt;span class="s1"&gt;&amp;#39;git help -a&amp;#39;&lt;/span&gt; and &lt;span class="s1"&gt;&amp;#39;git help -g&amp;#39;&lt;/span&gt; list available subcommands and some
concept guides. See &lt;span class="s1"&gt;&amp;#39;git help &amp;lt;command&amp;gt;&amp;#39;&lt;/span&gt; or &lt;span class="s1"&gt;&amp;#39;git help &amp;lt;concept&amp;gt;&amp;#39;&lt;/span&gt;
to &lt;span class="nb"&gt;read&lt;/span&gt; about a specific subcommand or concept.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;git help commit&lt;/code&gt; 이나 &lt;code&gt;git commit --help&lt;/code&gt; 와 같이 subcommand 자체에 대한 help 도 확인할 수 있으니 필요할 때마다 help 를 활용하자.&lt;/p&gt;
&lt;h1&gt;Git configuration&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;Git&lt;/em&gt; 설정을 적용하는 방법은 2가지가 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git config&lt;/code&gt; command 를 사용하는 방법&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.gitconfig&lt;/code&gt; 파일에 추가하는 방법&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;git config&lt;/code&gt; 명령을 사용하면 git 프로그램이 자동으로 &lt;code&gt;.gitconfig&lt;/code&gt; 파일에 해당 설정을 추가하는 것이기 때문에 결과는 같다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git config&lt;/code&gt; command:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git config --global user.name &lt;span class="s2"&gt;&amp;quot;imjang57&amp;quot;&lt;/span&gt;
git config --global user.email &lt;span class="s2"&gt;&amp;quot;imjang57@gmail.com&amp;quot;&lt;/span&gt;
git config --global color.ui auto
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;git config file (&lt;code&gt;~/.gitconfig&lt;/code&gt;):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;[user]&lt;/span&gt;
    &lt;span class="na"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;imjang57&lt;/span&gt;
&lt;span class="s"&gt;    email = imjang57@gmail.com&lt;/span&gt;
&lt;span class="k"&gt;[color]&lt;/span&gt;
    &lt;span class="na"&gt;ui&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;auto&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;위에서 &lt;code&gt;git config --global&lt;/code&gt; 과 같이 global option 을 전달했기 때문에 &lt;code&gt;~/.gitconfig&lt;/code&gt; 파일에 설정이 저장되었다. 만약 특정 Git repository 에만 설정을 적용하고 싶으면 해당 Local git repository 의 working directory 로 가서 &lt;code&gt;git config --local&lt;/code&gt; 과 같이 local option 을 사용하면 된다. 그러면 &lt;code&gt;&amp;lt;PROJECT_HOME&amp;gt;/.git/config&lt;/code&gt; 에 설정이 저장된다.&lt;/p&gt;
&lt;p&gt;현재의 git 설정들을 확인하고 싶다면 &lt;code&gt;git config --list&lt;/code&gt; 와 같이 실행한다. 만약 범위를 좁히고 싶다면 &lt;code&gt;git config --list --system&lt;/code&gt;, &lt;code&gt;git config --list --global&lt;/code&gt;, &lt;code&gt;git config --list --local&lt;/code&gt; 와 같이 실행할 수도 있다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;아래 설정은 git 이 실행할 텍스트 에디터 명령을 지정한다. commit message 작성 등을 위해 사용된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git config --global core.editor &amp;quot;\&amp;quot;C:\Windows\notepad.exe\&amp;quot;&amp;quot;
git config --global core.editor &amp;quot;nano&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr&gt;
&lt;p&gt;아래 설정은 proxy 를 설정한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git config --global http.proxy http://&amp;lt;username&amp;gt;:&amp;lt;password&amp;gt;@&amp;lt;host&amp;gt;:&amp;lt;port&amp;gt;
git config --global https.proxy http://&amp;lt;username&amp;gt;:&amp;lt;password&amp;gt;@&amp;lt;host&amp;gt;:&amp;lt;port&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;만약 프록시 서버가 별도의 인증서가 필요하면 다음과 같은 설정으로 인증서 파일을 추가한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git config --global http.sslCAInfo /path/to/mycertification.crt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;아니면 다음과 같이 ssl 인증서에 대한 validation 을 하지 않도록 설정할 수도 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git config http.sslVerify &lt;span class="nb"&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr&gt;
&lt;p&gt;아래 설정은 git 에서 사용하는 scheme 을 강제로 변환하기 위해 사용된다. 아래와 같이 설정하면 git scheme 을 https 로 바꿔서 사용하게 된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git config --global url.&lt;span class="s2"&gt;&amp;quot;https://&amp;quot;&lt;/span&gt;.insteadOf git://
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Git basic usage&lt;/h1&gt;
&lt;h2&gt;Git Local Repository 생성&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;새로운 git repository 생성 : &lt;code&gt;git init&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;명령어를 실행한 경로에 &lt;code&gt;.git&lt;/code&gt; 이라는 디렉터리가 생성되어 repository 관리 정보가 저장된다. &lt;code&gt;git init&lt;/code&gt; 명령을 실행한 디렉터리의 내용을 &lt;em&gt;Working Tree&lt;/em&gt; 라고 한다. working tree 의 변경 내용이 있을 때 &lt;code&gt;git add&lt;/code&gt;, &lt;code&gt;git rm&lt;/code&gt; 등을 실행하면 &lt;em&gt;Index&lt;/em&gt; 가 생성된다. &lt;code&gt;git commit&lt;/code&gt; 을 실행하면 local branch 에 변경 내용이 적용된다. &lt;code&gt;git push&lt;/code&gt; 를 실행하면 remote repository 에 변경된 내용을 추가한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Remote Repository 추가 : &lt;code&gt;git remote add &amp;lt;remote repository name&amp;gt; &amp;lt;Remote Repository URL&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;git init&lt;/code&gt; 후에 &lt;code&gt;git remote add&lt;/code&gt; 를 통해 remote repoistory 를 추가할 수 있다. 이후 &lt;code&gt;git fetch&lt;/code&gt; 을 실행하면 remote repository 의 정보를 읽어서 local repository 에 동기화한다. 그런데 &lt;code&gt;git fetch&lt;/code&gt;는 working tree 에 이 정보들을 적용하지는 않는다. 단지 local repository (&lt;code&gt;.git&lt;/code&gt; directory) 에만 정보를 저장한다. &lt;code&gt;git remote add origin ssh://user@host:22/repos/project&lt;/code&gt; 로 remote repository 를 등록했으면 &lt;code&gt;git merge origin/master&lt;/code&gt; 를 실행해서 merge 해야만 working tree 에 최신 정보가 적용된다. 만약 이 과정이 귀찮으면 그냥 &lt;code&gt;git pull&lt;/code&gt; 을 실행하면 된다. &lt;code&gt;git pull&lt;/code&gt; 은 &lt;code&gt;git fetch&lt;/code&gt; 와 &lt;code&gt;git merge&lt;/code&gt; 를 한꺼번에 실행해준다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Git Local Repository 를 만드는 다른 방법은 Remote Repository 를 복사하는 것이다. &lt;code&gt;git clone &amp;lt;url&amp;gt; [target directory]&lt;/code&gt; 을 실행하면 remote repository 를 복사한다. target directory 를 지정해주지 않으면 remote repository 의 이름으로 target directory 가 생성된다.&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;remote repository 목록 확인 : &lt;code&gt;git remote&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;URL 포함하여 remote repository 목록 확인 : &lt;code&gt;git remote -v&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;remote repository 상세 정보 확인 : &lt;code&gt;git remote show [remote repository name]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;remote repository 를 삭제 : &lt;code&gt;git remote rm &amp;lt;remote repository name&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;remote repository 의 이름 변경 : &lt;code&gt;git remote rename &amp;lt;from_name&amp;gt; &amp;lt;to_name&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2&gt;Bare repository&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;git init&lt;/code&gt; 을 실행할 때 &lt;code&gt;--bare&lt;/code&gt; 옵션을 추가하면 &lt;em&gt;Bare repository&lt;/em&gt; 를 생성한다. &lt;em&gt;Bare repository&lt;/em&gt; 는 저장소 역할만 한다. 즉, &lt;em&gt;Working directory&lt;/em&gt; 가 생성되지 않으며, 읽기 작업만 가능하다. &lt;code&gt;git init --bare &amp;lt;repository name&amp;gt;&lt;/code&gt; 으로 생성된 repository 에는 보통 &lt;code&gt;.git&lt;/code&gt; 디렉터리에 생성되는 파일들이 그대로 생성된다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Bare repository&lt;/em&gt; 는 코드 공유 및 협업을 위한 서버에 생성되는 저장소로 사용되며 각 개발자들은 이 &lt;em&gt;Bare repository&lt;/em&gt; 를 clone 하여 각자의 작업을 진행한다.&lt;/p&gt;
&lt;h2&gt;Managing Modifications in local repository&lt;/h2&gt;
&lt;p&gt;Git 으로 변경사항들을 관리하기 위한 기본적인 명령들을에는 status, add, rm, mv, commit, stash, diff 등이 있다.&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;repository 상태 (현재 branch, 변경 내역 등) 확인 : &lt;code&gt;git status&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;staging area (index) 에 파일 추가 : &lt;code&gt;git add &amp;lt;file&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;새롭게 생성된 Untracked files 나 modificated files 는 &lt;code&gt;git commit&lt;/code&gt; 전에 &lt;code&gt;git add&lt;/code&gt; 로 staging area 에 등록해야 한다. staging area 는 commit 전에 존재하는 임시 영역이다.&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;git repository 에 변경 내용을 기록 : &lt;code&gt;git commit [-m "messages"]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Staging area 에 기록된 파일들을 실제 repository 에 반영하는 작업이다. -m 옵션이 없다면 git 환경설정에서 지정된 editor 가 실행되고 자세한 로그를 작성할 수 있다. 관례적으로 첫 번째 줄에는 로그에 대한 한 줄 요약을 작성하고 두 번째 줄은 공백, 세 번째 줄부터 상세 내용을 작성한다. 아무것도 입력하지 않고 editor 를 종료하면 commit 이 취소된다.&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;working tree 와 staging area 의 차이를 확인 : &lt;code&gt;git diff&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;staging area 와 laest commit 의 차이를 확인 : &lt;code&gt;git diff --staged&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;working tree 와 최신 commit 의 차이를 확인 : &lt;code&gt;git diff HEAD&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;특정 branch 와 master branch 간의 diff 확인 : &lt;code&gt;git diff master..&amp;lt;branch name&amp;gt; [path]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;staging area 의 파일 삭제 : &lt;code&gt;git rm &amp;lt;path/to&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;특정 파일을 staging area 에서 삭제하지만 working tree 에는 보존 : &lt;code&gt;git rm --cached &amp;lt;path/to&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;파일 이동 : &lt;code&gt;git mv &amp;lt;from_file&amp;gt; &amp;lt;to_file&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;현재의 모든 변경 내용을 임시 저장하기 : &lt;code&gt;git stash&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;가장 최근의 임시 저장된 내용을 다시 적용하기 : &lt;code&gt;git stash pop&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;현재 임시 저장된 목록을 출력 : &lt;code&gt;git stash list&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;가장 최근의 임시 저장된 내용을 삭제 : &lt;code&gt;git stash drop&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Igrnoring files&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;.gitigrnore&lt;/code&gt; 파일에 무시할 파일들의 리스트를 추가하면 이후 추가된 파일들은 git add 등으로 변경 내용을 index 에 적용할 때 무시된다. 디렉터리마다 &lt;code&gt;.gitignore&lt;/code&gt; 파일을 생성할 수 있으며 해당 디렉터리부터 하위 디렉터리 들에 대해 파일의 내용이 적용된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;*.[oa]       # ignore files ending in &amp;quot;.o&amp;quot; or &amp;quot;.a&amp;quot;
!lib.a       # do track lib.a, even though you&amp;#39;re ignoring .a files above
*~           # ignore files ending in tilde(&amp;quot;~&amp;quot;)
/TODO        # only ignore the root TODO file, not subdir/TODO
build/       # ignore all files in the build/ directory
doc/*.txt    # ignore doc/notes.txt, but not doc/server/arch.txt
doc/**/*.txt # ignore all &amp;quot;*.txt&amp;quot; files in the doc/ directory
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;.gitignore&lt;/code&gt; 파일의 다른 용도는 empty directory 를 repository 에 저장하기 위해 사용된다. git 은 빈 디렉터리는 저장소에 저장하지 않는다. 이때 빈 디렉터리 안에 임의의 빈 &lt;code&gt;.gitignore&lt;/code&gt; 파일을 생성하여 commit 하면 해당 디렉터리도 저장소에 추가할 수 있다.&lt;/p&gt;
&lt;h2&gt;Viewing the Commit History&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;commit history 확인 : &lt;code&gt;git log [/path/to]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;commit 에서 변경된 내용도 같이 확인 : - &lt;code&gt;git log -p [/path/to]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;마지막 2개의 내용만 확인 : &lt;code&gt;git log -2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;한줄 요약으로 보기 : &lt;code&gt;git log --pretty=oneline&lt;/code&gt;, &lt;code&gt;git log --oneline&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Commit graph 를 같이 확인 : &lt;code&gt;git log --graph&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Commit 에 대한 Reference 정보 추가 : &lt;code&gt;git log --decorate&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;전체 또는 특정 branch 에 대한 Commit 정보 확인 : &lt;code&gt;git log --branch[=&amp;lt;pattern&amp;gt;]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;master branch 에 없고 feature-A branch 에 존재하는 commit 들을 확인 : &lt;code&gt;git log master..feature-A&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;전체 branch 의 commit 들을 commit graph 와 Reference 정보를 추가하여 한줄만 확인하려면 &lt;code&gt;git log --branches --graph --decoraete --oneline&lt;/code&gt; 을 실행하면 된다.&lt;/p&gt;
&lt;p&gt;특정 파일의 version history list 를 확인하려면 &lt;code&gt;git log --follow [file]&lt;/code&gt; 를 실행한다. git 나름대로 rename 한 작업까지 계산해준다.&lt;/p&gt;
&lt;h2&gt;Working with Remote Repository&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;git pull&lt;/code&gt;, &lt;code&gt;git fetch&lt;/code&gt;, &lt;code&gt;git merge&lt;/code&gt;, &lt;code&gt;git push&lt;/code&gt; 를 통해 remote repository 와 동기화할 수 있다.&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;Remote Repository 의 변경 내용들을 Local Repository 로 갱신 : &lt;code&gt;git pull&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;원격 저장소의 변경 내용이 로컬 작업 디렉토리에 받아지고(fetch), 병합(merge)된다. &lt;code&gt;git pull&lt;/code&gt; 은 내부적으로 아래의 두 명령이 연속적으로 실행된 것과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git fetch &amp;lt;remote repository name&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git merge &amp;lt;remote repository name&amp;gt;/master&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;Local Repository 의 commit 들을 Remote Repository 에 전달 : &lt;code&gt;git push [remote repository] [remote branch]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Remote Repository 이름이 origin 이고, origin 의 master branch 로 Local Repository 의 변경 내용을 올리려고 하면 &lt;code&gt;git push origin master&lt;/code&gt; 를 실행한다.&lt;/p&gt;
&lt;h2&gt;Branch and Merge&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;branch 목록 출력 및 현재 작업 중인 branch 확인 : &lt;code&gt;git branch&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Remote Repository 의 branch 들을 모두 포함하여 출력 : &lt;code&gt;git branch -a&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;branch 생성 : &lt;code&gt;git branch &amp;lt;branch name&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;branch 변경 : &lt;code&gt;git checkout &amp;lt;branch name&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;branch 생성 및 변경 : &lt;code&gt;git checkout -b &amp;lt;branch name&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;만약 feature-A 라는 이름의 branch를 생성하고 해당 branch 로 변경하고 싶으면 &lt;code&gt;git checkout -b feature-A&lt;/code&gt; 을 실행한다. 이는 다음 명령어 들을 연속으로 실행한 것과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git branch feature-A&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git checkout feature-A&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이후 master branch 로 돌아오려면 &lt;code&gt;git checkout master&lt;/code&gt; 를 실행한다. 만약 현재 branch 를 사용하기 전의 branch 로 되돌아가려면 &lt;code&gt;git checkout -&lt;/code&gt; 를 실행하면 된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;branch 삭제 : &lt;code&gt;git branch -d &amp;lt;branch name&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;branch 를 merge 하기 : &lt;code&gt;git merge [options] &amp;lt;branch name&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;만약 구현이 완료된 feature-A branch 를 merge 하려면 base branch(보통 master 또는 development)에서 &lt;code&gt;git merge feature-A&lt;/code&gt; 를 실행한다.&lt;/p&gt;
&lt;h2&gt;Resolve conflicts&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;git pull&lt;/code&gt;, &lt;code&gt;git merge&lt;/code&gt; 등을 하다보면 내가 변경하고 commit 한 내용과 다른 사람이 변경하고 commit 한 내용이 서로 충돌하는 경우가 발생한다. 대부분의 경우 git 이 자동으로 바뀐 부분을 알아서 적용해준다. 하지만 만약 서로 다른 사람들이 파일의 같은 부분을 동시에 고쳤을 경우, git 이 해결하지 못하고 충돌이 발생했음을 알려준다.&lt;/p&gt;
&lt;p&gt;이렇게 충돌이 발생하면, git이 알려주는 파일의 충돌 부분을 직접 수정해서 병합이 가능하도록 수정해야 한다. 충돌을 해결했다면, &lt;code&gt;git add [file path]&lt;/code&gt; 를 실행하여 수정된 부분을 다시 index 에 저장하고 commit 한다.&lt;/p&gt;
&lt;p&gt;변경 내용을 병합하기 전에, &lt;code&gt;git diff&lt;/code&gt; 를 사용하여 어떻게 바뀌었는지 비교해보는 것이 좋다.&lt;/p&gt;
&lt;h2&gt;Rebase&lt;/h2&gt;
&lt;p&gt;보통 &lt;code&gt;git merge&lt;/code&gt; 를 실행하면 작업 내용이 특정 parent commit 에서 분기되지 않았으면 &lt;em&gt;fast forward&lt;/em&gt; 방식이라고 해서 그대로 commit 내용을 가져 온 후 HEAD Reference 를 가장 최신의 commit 으로 변경한다.&lt;/p&gt;
&lt;p&gt;하지만 특정 parent commit 에서 작업 내용이 분기된 경우 &lt;code&gt;git merge&lt;/code&gt; 는 Base commit 으로부터 분기된 두 작업 내용을 합쳐서 새로운 commit 을 생성한다. 즉, parent commit 이 2개인 새로운 commit 이 생성되는 것이다. 이 경우 merge 한 내용을 commit history 나 graph 로 확인할 때 복잡해질 수 있다. 때문에 merge 전에 rebase 를 하도록 권장하기도 한다. 단, 이는 각 팀에 따라 다를 수 있다. 어떤 팀은 그냥 merge 를 할 수 있고 어떤 팀은 rebase 를 장려할 수도 있다. 필수는 아니다.&lt;/p&gt;
&lt;p&gt;만약 feature-A branch 에서 기능 개발 완료 후 master 로 merge 전에 rebase 를 하여 commit history 를 정리하고 싶다면 feature-A branch 에서 &lt;code&gt;git rebase master&lt;/code&gt; 를 실행한다. 그 후 master branch 로 전환한 후 &lt;code&gt;git merge feature-A&lt;/code&gt; 를 실행하면 &lt;em&gt;fast forward&lt;/em&gt; 방식으로 merge 된 것과 같이 commit history 가 정리된다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git merge&lt;/code&gt; 와 마찬가지로 &lt;code&gt;git rebase&lt;/code&gt; 도 conflict 가 발생할 수 있다. rebase 중에 conflic file 이 발견되면 rebase 작업은 잠시 멈추게 된다. 그리고 merge 와 마찬가지로 conflict file 을 수정한 후 &lt;code&gt;git add &amp;lt;conflict file&amp;gt;&lt;/code&gt; 을 실행한 뒤 &lt;code&gt;git rebase --continue&lt;/code&gt; 를 실행하면 작업이 이어서 진행된다. 만약 rebase 작업을 취소하고 싶다면 &lt;code&gt;git rebase --abort&lt;/code&gt; 를 실행한다.&lt;/p&gt;
&lt;p&gt;rebase 와 commit cherry-picking 으로 commit 을 관리하면 &lt;em&gt;fast forward&lt;/em&gt; 방식으로 정리된  commit history 를 관리할 수 있다.&lt;/p&gt;
&lt;p&gt;자세한 내용은 &lt;code&gt;git help rebase&lt;/code&gt; 나 공식 문서를 확인하자.&lt;/p&gt;
&lt;h2&gt;Tag&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Tag 목록 확인 : &lt;code&gt;git tag&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Tag 생성 : &lt;code&gt;git tag &amp;lt;tag name&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Tag 삭제 : &lt;code&gt;git tag -d &amp;lt;tag name&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;pattern 으로 tag 목록 확인 : &lt;code&gt;git tag -l 'v1.8.5*'&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;특정 tag의 정보 보기 : &lt;code&gt;git show &amp;lt;tag name&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;이미 지나간 commit 에 대한 tag 를 생성 : git tag -a &lt;tag name&gt; &lt;commit ID&gt;&lt;/li&gt;
&lt;li&gt;remote server 에 tag 정보 push : &lt;code&gt;git push origin [tagname]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;remote server 에 모든 tag 정보를 한꺼번에 전송 : &lt;code&gt;git push origin --tags&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;git tag 에는 2가지 type 이 있다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;lightweight : pointer to a specific commit. 즉, lightweight tag 정보는 오직 commit checksum 만 저장된다.&lt;/li&gt;
&lt;li&gt;annotated tag: stored as full objects in the Git database. They are checksummed; contain the tagger name, e-mail, and date; have a tagging message; and can be signed and verified with GNU Privacy Guard (GPG).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;git tag &amp;lt;tag name&amp;gt;&lt;/code&gt; 으로 Tag 를 생성할 경우 기본적으로 libweight tag 이다. annotated tag 는 &lt;code&gt;-a&lt;/code&gt; 옵션을 사용(&lt;code&gt;git tag -a &amp;lt;tag name&amp;gt; -m '&amp;lt;message&amp;gt;'&lt;/code&gt;)해야 한다. &lt;code&gt;-m&lt;/code&gt; 옵션이 없으면 git 에 editor 를 실행하여 message를 입력할 수 있도록 한다.&lt;/p&gt;
&lt;p&gt;annotated tag 는 추가적인 tag 정보들(tag name, tagger, date, message 등)과 commit 내용을 보여 준다. lightweight tag 는 tag 관련된 추가적인 정보들이 없이 commit 내용만 보여준다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tag 로 checkout : &lt;code&gt;git checkout -b version2 v2.0.0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;git 에는 사실 tag 로 checkout 하는 기능은 없다. 단지 특정 tag 로 branch 를 만드는 것이다. 때문에 이렇게 만들어진 branch 에서 작업하고 commit 하면 master 에 반영이 안되니 주의해야 한다.&lt;/p&gt;
&lt;h1&gt;Advanced&lt;/h1&gt;
&lt;h2&gt;Undo modifications&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Local 의 변경 내용을 HEAD 로 되돌리기: &lt;code&gt;git checkout -- &amp;lt;file path&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;위의 명령은 이미 인덱스에 추가된 변경 내용과 새로 생성한 파일은 그대로 남는다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Staging Area (index) 의 파일을 Unstaged 로 바꾸기: &lt;code&gt;git reset HEAD &amp;lt;file path&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;만약 어떤 파일을 수정한 후 git add 를 실행하여 Staged 상태일 때, 변경 내용들을 취소하고 싶을 경우 아래 명령들을 차례로 실행한다.&lt;/p&gt;
&lt;p&gt;HEAD 는 Git 에서 사용되는 special pointer 이다. HEAD 는 현재 작업 중인 local branch 를 가리킨다. &lt;code&gt;git checkout&lt;/code&gt; 으로 branch 를 변경하면 HEAD 가 변경된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Repository 의 history 중 하나로 복원하기: &lt;code&gt;git reset [options] &amp;lt;commit hash ID&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;history 와 모든 변경 내용들을 삭제하면서 특정 commit 으로 되돌아가기 : &lt;code&gt;git reset --hard [commit]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;git reset --hard&lt;/code&gt; 의 경우 history 를 포함한 모든 변경 내용들을 삭제하여 깔끔하게 이전 내용으로 되돌아갈 수 있다. 하지만 Local Git Repository 가 다른 Remote Repository 와 공유될 경우 문제가 발생할 수도 있다. 이때 사용가능 한 것이 &lt;code&gt;git revert &amp;lt;commit hash ID&amp;gt;&lt;/code&gt; 이다. &lt;code&gt;git revert&lt;/code&gt; 는 history 와 commit 들을 삭제하지 않는다. 내용을 특정 commit 으로 되돌리지만 삭제하지 않고 또하나의 새로운 commit 으로 처리한다.&lt;/p&gt;
&lt;h2&gt;Modify commits&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;commit 수정하기: &lt;code&gt;git commit --amend&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;아래와 같은 경우 commit 내용을 수정해야 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;어떤 파일을 빼먹었을 때&lt;/li&gt;
&lt;li&gt;commit message 를 잘못 적었을 때&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;커밋을 했는데 Stage하는 것을 깜빡하고 빠트린 파일이 있으면 아래와 같이 고칠 수 있다:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git commit -m &amp;#39;initial commit&amp;#39;
git add &amp;lt;forgotten_file_path&amp;gt;
git commit --amend
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;여기서 실행한 명령어 3개는 모두 하나의 commit 으로 기록된다. 두 번째 commit 은 첫 번째 commit 을 덮어쓴다.&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;.git&lt;/code&gt; directory&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;.git&lt;/code&gt; 디렉터리는 local git repository 정보가 저장되는 곳이다. 안에 여러 파일들이 있는데 간단하게 중요한 몇몇 파일만 설명하면 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.git/objects&lt;/code&gt; : 각 Commit Object 들이 Hash 값에 따라 저장됨&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.git/refs&lt;/code&gt; : Commit Hash 를 참조하는 Reference 정보&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.git/refs/heads&lt;/code&gt; : local git repository 의 각 branch 들의 HEAD 가 저장(master branch 의 head 는 &lt;code&gt;.git/refs/heads/master&lt;/code&gt; 에 저장)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.git/HEAD&lt;/code&gt; : 현재 작업 중인 branch 의 HEAD 정보를 나타냄(예 : ref: refs/heads/master)&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Github&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;branch 들 (example: ruby on rails repository 의 4-0-stable branch 와 3-2-stable branch) 사이의 변경 내역 확인하는 방법 : &lt;code&gt;https://github.com/rails/rails/compare/4-0-stable...3-2-stable&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;master branch 의 2015년 1월 1일부터의 변경 내역을 확인하는 방법(변경 내역이 너무 많거나, 기간이 너무 긴 경우에는 최근 변경 내용만 나온다) : &lt;code&gt;https://www.github.com/rails/rails/compare/master@{2015-01-01}...master&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;References&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://git-scm.com/book/en/v2"&gt;Git Book English&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://git-scm.com/book/ko/v2"&gt;Git Book Korean&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://rogerdudler.github.io/git-guide/index.ko.html"&gt;git - 간편 안내서&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="git"></category></entry><entry><title>Shell, Bash, Zsh</title><link href="https://imjang57.github.io/garret/introduction-shell-bash-zsh.html" rel="alternate"></link><published>2016-12-31T00:00:00+09:00</published><updated>2016-12-31T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2016-12-31:/garret/introduction-shell-bash-zsh.html</id><summary type="html">&lt;p&gt;내가 사용하는 Shell 에 대한 소개와 설치 과정&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Shell&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;Shell&lt;/em&gt; 은 &lt;em&gt;OS&lt;/em&gt; (&lt;em&gt;Operating System&lt;/em&gt;) 가 제공하는 여러 서비스들을 사용하기 위한 User interface 를 말한다. &lt;em&gt;CLI&lt;/em&gt; (&lt;em&gt;Command-line interface&lt;/em&gt;) 도 &lt;em&gt;Shell&lt;/em&gt; 이고 &lt;em&gt;GUI&lt;/em&gt; (&lt;em&gt;Graphical User Interface&lt;/em&gt;) 도 &lt;em&gt;Shell&lt;/em&gt; 이다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Linux&lt;/em&gt; 와 &lt;em&gt;OS X&lt;/em&gt; 에서는 보통 &lt;em&gt;Bash&lt;/em&gt; 가 Default shell 로 제공된다. 이 외에 &lt;em&gt;csh&lt;/em&gt;, &lt;em&gt;ksh&lt;/em&gt;, &lt;em&gt;zsh&lt;/em&gt; 등 많은 &lt;em&gt;Shell&lt;/em&gt; 들이 있다.&lt;/p&gt;
&lt;p&gt;요즘 가장 많이 사용되는 Linux 와 OS X  에서 Default shell 이고 수 많은 shell script 들이 &lt;em&gt;Bash&lt;/em&gt; 를 기반으로 작성되기 때문에 &lt;em&gt;Bash&lt;/em&gt; 는 필수이다. 여기에 나는 개인적으로 사용되는 환경에서는 &lt;em&gt;Zsh&lt;/em&gt; 을 추가로 설치해서 사용한다.&lt;/p&gt;
&lt;p&gt;이 &lt;em&gt;Shell&lt;/em&gt; 들은 마음에 드는 프롬프트를 만들고, 자주 사용하는 명령들을 alias 하고, 환경변수를 지정해서 사용하는 등 개인 취향에 따라 customizing 할 수 있다. 그래서 이 글에 내가 사용하는 Bash 설정과 Zsh 을 설치하고 설정하기 위한 과정들을 남긴다.&lt;/p&gt;
&lt;h2&gt;Shell 확인 및 변경&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Shell&lt;/em&gt; 확인은 다음과 같이 가능하다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;현재 내가 사용중인 Shell 확인 : &lt;code&gt;echo $SHELL&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;System 에서 사용가능한 Shell 목록 확인 : &lt;code&gt;cat /etc/shells&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;만약 내가 사용 중인 Shell 을 변경하고 싶다면 &lt;code&gt;chsh -s /path/to/other/shell&lt;/code&gt; 를 실행하면 된다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ chsh -s /usr/local/bin/zsh
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Shell 의 실행 형태&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Shell&lt;/em&gt; 의 실행 형태는 &lt;em&gt;Interacctive shell&lt;/em&gt; 과 &lt;em&gt;Non-interactive shell&lt;/em&gt; 2가지가 있다. &lt;em&gt;Interactive shell&lt;/em&gt; 은 사용자가 명령을 입력하고 이를 실행하는 형태의 &lt;em&gt;Shell&lt;/em&gt; 이고 &lt;em&gt;Non-interactive shell&lt;/em&gt; 은 Script 를 실행할 때 사용되는 형태이다. 그리고 &lt;em&gt;Interactive shell&lt;/em&gt; 은 &lt;em&gt;Login shell&lt;/em&gt; 과 &lt;em&gt;Non-login Shell&lt;/em&gt; 이 있다. &lt;em&gt;Shell&lt;/em&gt; 은 실행 형태에 따라 사용자가 로그인할 때, 로그아웃할 때 각각 수행되는 스크립트들이 있다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Bash&lt;/em&gt; 의 경우를 예로 살펴보자. &lt;em&gt;Interactive Login Shell&lt;/em&gt; 일 경우 로그인할 때는 &lt;code&gt;/etc/profile&lt;/code&gt; 이 먼저 실행되고 &lt;code&gt;~/.bash_profile&lt;/code&gt;, &lt;code&gt;~/.bash_login&lt;/code&gt;, &lt;code&gt;~/.profile&lt;/code&gt; 들 중 처음 나오는 1개가 실행되다. 로그아웃할 때는 &lt;code&gt;~/.bash_logout&lt;/code&gt; 을 실행한다. &lt;em&gt;Interactive Non-login Shell&lt;/em&gt; 일 경우 &lt;code&gt;~/.bashrc&lt;/code&gt; 가 실행된다. &lt;em&gt;Non-interactive shell&lt;/em&gt; 은 $BASH_ENV (script 를 sh 로 실행한 경우는 $ENV) Environment variable 을 찾아서 이 변수에서 지정하는 파일 내의 명령들을 실행한다. 대부분의 경우 System-wide environment variables 는 &lt;code&gt;/etc/profile&lt;/code&gt; 에 설정하고, 각 사용자가 필요한 내용은 &lt;code&gt;~/.bash_profile&lt;/code&gt; 에서 설정한다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Zsh&lt;/em&gt; 은 &lt;code&gt;/etc/profile&lt;/code&gt; 대신 &lt;code&gt;/etc/zprofile&lt;/code&gt;, &lt;code&gt;~/.bash_profile&lt;/code&gt; 대신 &lt;code&gt;~/.zprofile&lt;/code&gt;, &lt;code&gt;~/.bashrc&lt;/code&gt; 대신 &lt;code&gt;~/.zshrc&lt;/code&gt; 를 사용한다.&lt;/p&gt;
&lt;h2&gt;Prompt&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Interactive Shell&lt;/em&gt; 이 실행된 경우 사용자의 입력을 기다리고 있음을 나타내기 위해 &lt;code&gt;&amp;lt;username@hostname&amp;gt;&lt;/code&gt; 과 같은 내용을 표시하는데 이를 Prompt 라고 한다. 이 프롬프트는 $PS1 환경 변수에 의해 설정된다. 만약 &lt;code&gt;export PS1="\$? &amp;gt; "&lt;/code&gt; 를 실행하면 프롬프트는 &lt;code&gt;0 &amp;gt;&lt;/code&gt; 와 같이 출력된다. 숫자 0은 이전 명령에 대한 리턴값이다.&lt;/p&gt;
&lt;p&gt;나는 bash prompt 를 다음과 같이 설정해서 사용한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# Colorize bash prompt using ANSI escape codes.&lt;/span&gt;
&lt;span class="c1"&gt;#     below print : username@hostname:cwd $&lt;/span&gt;
&lt;span class="nb"&gt;export&lt;/span&gt; &lt;span class="nv"&gt;PS1&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;\[\033[36m\]\u\[\033[m\]@\[\033[32m\]\h:\[\033[33;1m\]\w\[\033[m\]\$ &amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;alias&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;alias&lt;/code&gt; 명령을 사용하면 긴 명령이나 자주 사용하는 명령을 내가 원하는 명령으로 지정할 수 있다. &lt;code&gt;alias ll='ls -GFhil'&lt;/code&gt; 을 실행하면 이후부터 &lt;code&gt;ll&lt;/code&gt; 을 입력했을 때 &lt;code&gt;ls -GFhil&lt;/code&gt; 가 실행된다.&lt;/p&gt;
&lt;p&gt;내가 주로 사용하는 &lt;code&gt;alias&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;alias ll=&amp;#39;ls -GFhil&amp;#39;
alias lt=&amp;#39;ls -altr&amp;#39;
alias vi=&amp;#39;vim&amp;#39;
ssh=&amp;#39;ssh -o StrictHostKeyChecking=no -t&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Bash&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;Bash&lt;/em&gt; 는 최초의 &lt;em&gt;Shell&lt;/em&gt; 인 Bourne shell 을 다시 만든 &lt;em&gt;Shell&lt;/em&gt; 로 Bourne-again Shell 을 줄여서 &lt;em&gt;Bash&lt;/em&gt; 라고 한다. Linux 와 OS X 에는 Default shell 이며 다른 Unix 에서는 Csh 을 쓰는 듯 하다.&lt;/p&gt;
&lt;p&gt;요즘 대부분 개발자들이 사용하는 환경은 Linux, OS X, Windows 라서 &lt;em&gt;Bash&lt;/em&gt; 는 따로 설치해본 적이 없다. Linux 와 OS X 응 Default shell 이고 Windows 는 Bash 안쓰니까.. 그러니까 &lt;em&gt;Bash&lt;/em&gt; 에 대한 얘기는 넘어가자.&lt;/p&gt;
&lt;h1&gt;Zsh&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;Zsh&lt;/em&gt; 은 &lt;em&gt;Bash&lt;/em&gt; 의 확장판 같은 거라고 한다(그렇다고 함..). 사실 &lt;em&gt;Zsh&lt;/em&gt; 을 사용하는 이유는 &lt;em&gt;oh-my-zsh&lt;/em&gt; 때문이다. &lt;em&gt;Zsh&lt;/em&gt; 자체도 (자기들 주장에는) 좋다고 하는데 사실 나는 &lt;em&gt;Bash&lt;/em&gt; 와 비교해서 딱히 뛰어난 걸 잘 못느꼈다. 게다가 대부분의 Shell script 는 &lt;em&gt;Bash&lt;/em&gt; 를 기준으로 하기 때문에 &lt;em&gt;Zsh&lt;/em&gt; 이 아무리 &lt;em&gt;Bash&lt;/em&gt; 와 호환된다 해도 사용할 이유를 느끼지 못했었다. &lt;em&gt;oh-my-zsh&lt;/em&gt; 이 없었으면 아마 사용 안했을 듯 하다.&lt;/p&gt;
&lt;h2&gt;Zsh + oh-my-zsh 설치 및 설정&lt;/h2&gt;
&lt;p&gt;zsh 설치는 &lt;code&gt;yum install zsh&lt;/code&gt;, &lt;code&gt;apt-get install zsh&lt;/code&gt;, &lt;code&gt;brew install zsh&lt;/code&gt; 중 자기 OS 에 맞는 걸로 사용해서 설치하자. zsh 소스를 받아서 컴파일 하여 설치하는 것은 &lt;a href="http://www.zsh.org"&gt;Zsh Homepage&lt;/a&gt; 가서 알아보자.&lt;/p&gt;
&lt;p&gt;이제 oh-my-zsh 을 설치하자. &lt;a href="https://github.com/robbyrussell/oh-my-zsh"&gt;oh-my-zsh github&lt;/a&gt; 에 설명이 잘 나와있으니 자세한 내용은 가서 읽어보자. 나는 curl 을 이용해서 설치했다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ curl -L https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh &lt;span class="p"&gt;|&lt;/span&gt; sh
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;위 명령을 실행하면 git repository 가 ~/.oh-my-zsh 디렉터리에 clone 되고 설치 작업이 수행된다. 그리고 ~/.zshrc 파일이 자동으로 생성된다.&lt;/p&gt;
&lt;p&gt;설치는 이렇게 쉽게 끝났고, oh-my-zsh 은 다양한 theme plugin 을 지원하므로 내가 원하는 theme 를 적용해보자. 나는 &lt;a href="https://gist.github.com/agnoster/3712874"&gt;agnoster&lt;/a&gt; theme 가 마음에 들어서 아래와 같이 ~/.zshrc 파일을 변경하였다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ZSH_THEME=&amp;quot;agnoster&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;변경 후 &lt;code&gt;~/.zshrc&lt;/code&gt; 파일을 다시 적용하면 theme 가 적용된다. 만약 &lt;code&gt;ZSH_THEME="random"&lt;/code&gt; 으로 하면 여러 테마들이 로그인할 때마다 랜덤으로 적용된다.&lt;/p&gt;
&lt;p&gt;agnoster 테마는 Powerline font 를 필요로 한다. 이 폰트는 &lt;a href="https://github.com/powerline/fonts"&gt;Powerline github&lt;/a&gt; 에서 받을 수 있다. 이 저장소를 clone 한 후 &lt;code&gt;install.sh&lt;/code&gt; 파일을 실행하면 알아서 폰트를 설치해준다.&lt;/p&gt;
&lt;p&gt;OS X 의 경우 터미널 앱의 환경설정으로 가서 테마에서 서체를 새로 설치한 &lt;em&gt;Meslo LG M for Powerline&lt;/em&gt; 으로 바꿔주자.&lt;/p&gt;</content><category term="shell"></category><category term="bash"></category><category term="zsh"></category></entry><entry><title>TMUX Introduction</title><link href="https://imjang57.github.io/garret/tmux-introduction.html" rel="alternate"></link><published>2016-12-31T00:00:00+09:00</published><updated>2016-12-31T00:00:00+09:00</updated><author><name>imjang57</name></author><id>tag:imjang57.github.io,2016-12-31:/garret/tmux-introduction.html</id><summary type="html">&lt;p&gt;TMUX 설치 및 사용법에 대한 간단한 소개&lt;/p&gt;</summary><content type="html">&lt;h1&gt;TMUX (Terminal Multiplexer)&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;tmux&lt;/em&gt; 는 terminal session 을 관리하기 위한 tool 이다. 여러 session 을 생성하여 서로 다른 workspace 를 만들 수 있고, session 을 유지시켜서 server 가 완전히 power off 되지않는다면 workspace 를 유지할 수도 있다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;tmux&lt;/em&gt; + &lt;em&gt;vim&lt;/em&gt; + &lt;em&gt;bash&lt;/em&gt; 는 매우 강력한 linux environment 를 제공한다.&lt;/p&gt;
&lt;h2&gt;설치&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;OS X: &lt;code&gt;brew install tmux&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Ubuntu: &lt;code&gt;apt-get install libevent-dev tmux&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;CentOS: &lt;code&gt;yum install libevent-dev tmux&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Linux 에서는 환경에 따라서 libncurses 모듈이 필요할 수 있다&lt;/p&gt;
&lt;h1&gt;tmux basic concepts&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;tmux&lt;/em&gt; 를 이용하기 전에 아래와 같은 개념에 대해 알고 가자.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;session&lt;/em&gt; : &lt;em&gt;tmux&lt;/em&gt; 실행 단위이다. 하나의 workspace 라고 생각할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;window&lt;/em&gt; : &lt;em&gt;session&lt;/em&gt; 내에 생성되는 하나의 terminal&lt;/li&gt;
&lt;li&gt;&lt;em&gt;pane&lt;/em&gt; : terminal 화면을 분할한 단위&lt;/li&gt;
&lt;li&gt;&lt;em&gt;status bar&lt;/em&gt; : 화면 아래부분에 표시되는 &lt;em&gt;session&lt;/em&gt; 의 status bar&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;99% 정도되는 대부분의 command 는 &lt;code&gt;ctrl + b&lt;/code&gt; 를 누른다음 이어서 command key 를 입력하여 실행된다. 예를 들어 command mode 로 직접 명령어를 입력하고 싶을 때는 &lt;code&gt;ctrl + b, :&lt;/code&gt; 와 같이 키를 입력한다. 정확하게는 &lt;code&gt;ctrl + b&lt;/code&gt; 를 누른 후 5초 내에 &lt;code&gt;:&lt;/code&gt; 를 입력한다. 5초 내에 command key 를 입력하면 된다.&lt;/p&gt;
&lt;h2&gt;Session&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;tmux&lt;/em&gt; 를 실행하면 &lt;em&gt;session&lt;/em&gt; 이라는 것이 생성된다. &lt;em&gt;session&lt;/em&gt; 은 실제 작업이 이루어지는 workspace 이며, &lt;em&gt;tmux&lt;/em&gt; 는 이 &lt;em&gt;session&lt;/em&gt; 을 관리하는 tool 이다.&lt;/p&gt;
&lt;h3&gt;create, rename, exit session&lt;/h3&gt;
&lt;p&gt;새로운 session 을 생성:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ tmux
$ tmux new-session -s &amp;lt;session name&amp;gt;
$ tmux new -s &amp;lt;session name&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;session name 을 직접 정하지 않았을 경우 숫자가 기본 session name 이 된다. 변경하고 싶으면 아래와 같은 command 를 입력한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ tmux rename-session -t &amp;lt;target session&amp;gt; &amp;lt;new session name&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;위의 명령에서 &lt;code&gt;tmux&lt;/code&gt; 를 제외한 부분(&lt;code&gt;rename-session&lt;/code&gt; 부터)을 &lt;em&gt;session&lt;/em&gt; 내에서 command mode(&lt;code&gt;ctrl + b, :&lt;/code&gt;) 에서 사용해도 된다.
또는 session 내에서 &lt;code&gt;ctrl + b, $&lt;/code&gt; 를 입력한다. 그러면 status bar 가 아래처럼 나타난다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(rename-session) 0
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;기존의 session name 인 0 을 삭제하고 새로운 session name 을 입력한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(rename-session) testsession
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;생성된 session 을 종료하고 싶으면 session 내에서 &lt;code&gt;exit&lt;/code&gt; 를 실행한다. 또는 &lt;code&gt;ctrl + d&lt;/code&gt; 를 입력한다.&lt;/p&gt;
&lt;h3&gt;attach and detach session&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;session&lt;/em&gt; 을 실행한 후 이를 유지하고 &lt;em&gt;session&lt;/em&gt; 밖으로 나갈 수도 있다. 서버만 내려가지 않는다면 이 &lt;em&gt;session&lt;/em&gt; 을 계속 유지시킬 수 있다. 이렇게 동작하는 것을 &lt;em&gt;session&lt;/em&gt; 을 detach 한다고 하는데 command mode 에서 &lt;code&gt;detach&lt;/code&gt; 를 입력하여 실행할 수 있다. 또는 &lt;code&gt;ctrl + b, d&lt;/code&gt; 를 입력해도 된다.&lt;/p&gt;
&lt;p&gt;이미 생성된 session 의 목록을 확인하려면 아래 명령을 실행한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ tmux list-sessions
testsession: &lt;span class="m"&gt;1&lt;/span&gt; windows &lt;span class="o"&gt;(&lt;/span&gt;created Thu Dec &lt;span class="m"&gt;22&lt;/span&gt; 09:31:45 2016&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;224x41&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;특정 session 에 다시 접속하려면 아래 명령을 실행한다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ tmux attach-session -t testsession
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;위 명령을 아래 처럼 짧게 사용할 수도 있다.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ tmux attach -t testsession
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Window&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;window&lt;/em&gt; 는 &lt;em&gt;session&lt;/em&gt; 내에서 나누어지는 공간이다. 일반적으로 인터넷 브라우저나 다른 어플리케이션에서 볼 수 있는 탭과 같은 것이다. &lt;em&gt;session&lt;/em&gt; 이라는 workspace 에 여러 &lt;em&gt;window&lt;/em&gt; 를 생성하여 한번에 여러가지 일들을 동시에 할 수 있게 된다.&lt;/p&gt;
&lt;h3&gt;create, rename, close window&lt;/h3&gt;
&lt;p&gt;최초에 &lt;em&gt;session&lt;/em&gt; 이 생성되면 무조건 1 개의 &lt;em&gt;window&lt;/em&gt; 가 생성된다. 최대 10개까지 생성할 수 있다. 화면 아래에 있는 status bar 에서 현재 &lt;em&gt;window&lt;/em&gt; 는 &lt;code&gt;*&lt;/code&gt; 가 window name 옆에 표시된다.&lt;/p&gt;
&lt;p&gt;현재 &lt;em&gt;session&lt;/em&gt; 에서 새로운 &lt;em&gt;window&lt;/em&gt; 를 생성하려면 &lt;code&gt;ctrl + b, c&lt;/code&gt; 를 입력한다. &lt;em&gt;tmux&lt;/em&gt; 로 새로운 &lt;em&gt;session&lt;/em&gt; 을 생성하면서 동시에 &lt;em&gt;session&lt;/em&gt; 과 &lt;em&gt;window&lt;/em&gt; 의 이름을 지정하려면 &lt;code&gt;tmux new-session -s testsession -n testwindow&lt;/code&gt; 명령으로 &lt;em&gt;tmux&lt;/em&gt; 를 실행하면 된다:&lt;/p&gt;
&lt;p&gt;현재 활성화된(&lt;code&gt;*&lt;/code&gt; 로 표시된) &lt;em&gt;window&lt;/em&gt; 의 name 을 변경하려면 &lt;code&gt;ctrl + b, ,&lt;/code&gt; 을 입력한다.&lt;/p&gt;
&lt;p&gt;현재 활성화된 &lt;em&gt;window&lt;/em&gt; 를 삭제하려면 &lt;code&gt;ctrl + b, &amp;amp;&lt;/code&gt; 를 입력하거나 &lt;code&gt;ctrl + d&lt;/code&gt; 를 입력한다.&lt;/p&gt;
&lt;h3&gt;Move to window&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;window&lt;/em&gt; 사이를 이동하려면 &lt;code&gt;ctrl + b, &amp;lt;window number: 0–9&amp;gt;&lt;/code&gt; 를 입력한다. 또는 &lt;code&gt;ctrl + b, n&lt;/code&gt; 으로 다음 &lt;em&gt;window&lt;/em&gt; 로, &lt;code&gt;ctrl + b, p&lt;/code&gt; 로 이전 &lt;em&gt;window&lt;/em&gt; 로 이동할 수 있다. 바로 직전에 작업하고 있던 &lt;em&gt;window&lt;/em&gt; 로 가려면 &lt;code&gt;ctrl + b, l&lt;/code&gt; 을 사용한다. l 의 의미는 last-window 이다.&lt;/p&gt;
&lt;p&gt;또 다른 &lt;em&gt;window&lt;/em&gt; 를 이동하는 방법은 &lt;code&gt;ctrl + b, w&lt;/code&gt; 를 사용하는 방법이다. 이 키를 입력하면 화면에 현재 &lt;em&gt;session&lt;/em&gt; 내에 열려 있는 &lt;em&gt;window&lt;/em&gt; 들이 list-up 된다. 원하는 &lt;em&gt;window&lt;/em&gt; 를 선택하여 바로 이동할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ctrl + b, f&lt;/code&gt; 를 이용하면 검색을 이용하여 &lt;em&gt;window&lt;/em&gt; 를 이동할 수 있다. 검색 결과가 복수이면 해당 &lt;em&gt;window&lt;/em&gt; 들이 list-up 된다. 원하는 &lt;em&gt;window&lt;/em&gt; 를 선택해서 이동할 수 있다.&lt;/p&gt;
&lt;h3&gt;Exit window&lt;/h3&gt;
&lt;p&gt;현재 &lt;em&gt;window&lt;/em&gt; 를 종료하려면 terminal 에서 &lt;code&gt;exit&lt;/code&gt; command 를 실행한다. 또는 &lt;code&gt;ctrl + d&lt;/code&gt; 를 입력한다. 모든 &lt;em&gt;window&lt;/em&gt; 가 종료되면 &lt;em&gt;session&lt;/em&gt; 도 종료된다.&lt;/p&gt;
&lt;h2&gt;Pane&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;pane&lt;/em&gt; 은 &lt;em&gt;windows&lt;/em&gt; 를 구성하는 화면들이다. &lt;em&gt;windows&lt;/em&gt; 는 1개 또는 여러 개의 pane 들로 구성될 수 있다. 때문에 2개의 &lt;em&gt;pane&lt;/em&gt; 을 만들어서 &lt;em&gt;window&lt;/em&gt; 를 좌우로 나누어 사용할 수도 있다.&lt;/p&gt;
&lt;h3&gt;Split&lt;/h3&gt;
&lt;p&gt;좌우로 window 분할(Split vertical)하려면 &lt;code&gt;ctrl + b, %&lt;/code&gt; 를 입력한다. 또는 command mode 로 &lt;code&gt;split-window -h&lt;/code&gt; 를 입력한다.&lt;/p&gt;
&lt;p&gt;상하로 window 분할(Split horizontal)하려면 &lt;code&gt;ctrl + b, "&lt;/code&gt; 를 입력한다. 또는 command mode 로 &lt;code&gt;split-window -v&lt;/code&gt; 를 입력한다.&lt;/p&gt;
&lt;h3&gt;Move to pane&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ctrl + b, q&lt;/code&gt; 를 입력하면 각 &lt;em&gt;pane&lt;/em&gt; 에 숫자가 잠시 표시된다. 이 때 원하는 pane 의 숫자를 입력하면 해당 &lt;em&gt;pane&lt;/em&gt; 으로 이동한다. 2초 간의 timeout 내에 입력해야 한다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ctrl + b, o&lt;/code&gt; 를 입력하면 정해진 순서에 따라 현재 &lt;em&gt;window&lt;/em&gt; 에 생성된 &lt;em&gt;pane&lt;/em&gt; 들을 차례대로 이동한다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ctrl + b, 방향키(Arrow key)&lt;/code&gt; 를 입력하면 인접한 방향의 &lt;em&gt;pane&lt;/em&gt; 으로 이동한다.&lt;/p&gt;
&lt;h3&gt;Exit pane&lt;/h3&gt;
&lt;p&gt;현재 &lt;em&gt;pane&lt;/em&gt; 을 종료시키려면 terminal 에서 &lt;code&gt;exit&lt;/code&gt; command 를 실행한다. 또는 &lt;code&gt;ctrl + d&lt;/code&gt; 를 입력한다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ctrl + b, x&lt;/code&gt; 를 입력하면 status bar 에 y/n 을 묻는 prompt 가 표시된다. y 를 선택하면 종료된다.&lt;/p&gt;
&lt;p&gt;모든 &lt;em&gt;pane&lt;/em&gt; 들이 종료되면 &lt;em&gt;window&lt;/em&gt; 도 종료된다.&lt;/p&gt;
&lt;h3&gt;Resizing pane&lt;/h3&gt;
&lt;p&gt;command mode 에서 명령을 입력하며 &lt;em&gt;pane&lt;/em&gt; 의 size 를 조절할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;왼쪽으로 10 줄이기 : &lt;code&gt;resize-pane -L 10&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;오른쪽으로 10 늘리기 : &lt;code&gt;resize-pane -R 10&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;아래쪽으로 10 늘리기 : &lt;code&gt;resize-pane -D 10&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;위쪽으로 10 늘리기 : &lt;code&gt;resize-pane -U 10&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Configuration file&lt;/h1&gt;
&lt;p&gt;tmux configuration file 은 &lt;code&gt;~/.tmux.conf&lt;/code&gt; 이다.&lt;/p&gt;
&lt;h1&gt;Key binding&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;ctrl + b + ?&lt;/code&gt; 을 입력하면 현재의 key binding 리스트를 볼 수 있다.&lt;/p&gt;
&lt;p&gt;사용자가 원하면 &lt;code&gt;~/.tmux.conf&lt;/code&gt; 파일에 key binding 를 설정할 수 있다. 자세한 내용은 tmux manpage 를 참고하자.&lt;/p&gt;
&lt;h1&gt;Copy mode&lt;/h1&gt;
&lt;p&gt;tmux 를 실행하고 있는 환경에서는 scroll bar 가 없다. 이때 &lt;em&gt;Copy mode&lt;/em&gt; 를 사용하면 이전 출력들을 볼 수 있다. 또한 &lt;em&gt;session&lt;/em&gt; 안에서 원하는 text 를 copy / paste 할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ctrl + b, [&lt;/code&gt; 를 입력하면 &lt;em&gt;Copy mode&lt;/em&gt; 로 진입한다. &lt;em&gt;pane&lt;/em&gt; 의 오른쪽 상단에 buffer 에 저장된 총 line 수가 출력된다. &lt;em&gt;Copy mode&lt;/em&gt; 를 종료하고 싶으면 &lt;code&gt;Enter&lt;/code&gt; 를 입력하거나 &lt;code&gt;q&lt;/code&gt; 를 입력한다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Copy mode&lt;/em&gt; 에서 이동은 &lt;code&gt;방향키(Arrow key)&lt;/code&gt;, &lt;code&gt;PageUp&lt;/code&gt;, &lt;code&gt;PageDown&lt;/code&gt; 키들을 사용한다. 만약 vi editor 의 방식으로 이동하고 싶으면 &lt;code&gt;~/.tmux.conf&lt;/code&gt; 파일에 &lt;code&gt;setw -g mode-keys vi&lt;/code&gt; 를 추가한다. 이 설정을 하면 &lt;code&gt;h&lt;/code&gt;, &lt;code&gt;j&lt;/code&gt;, &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;l&lt;/code&gt;, &lt;code&gt;G&lt;/code&gt;, &lt;code&gt;g&lt;/code&gt;, &lt;code&gt;ctrl + f&lt;/code&gt;, &lt;code&gt;ctrl + b&lt;/code&gt; 등 vi editor 에서 cursor 이동에 사용되는 key 들을 사용할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Copy mode&lt;/em&gt; 에서 검색은 &lt;code&gt;?&lt;/code&gt; 와 &lt;code&gt;/&lt;/code&gt; 를 사용한다. &lt;code&gt;?&lt;/code&gt; 또는 &lt;code&gt;/&lt;/code&gt; 를 입력하면 &lt;em&gt;pane&lt;/em&gt; 왼쪽 아래부분에 &lt;code&gt;Search Up:&lt;/code&gt; 이라고 표시된다. 여기에 검색어를 입력한다. &lt;code&gt;?&lt;/code&gt; 를 입력하면 위로 검색, &lt;code&gt;/&lt;/code&gt; 를 입력하면 아래로 검색한다. 다음, 이전 검색은 &lt;code&gt;N&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt; 을 입력한다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Copy mode&lt;/em&gt; 에서 &lt;code&gt;SPACEBAR&lt;/code&gt; 키를 입력하면 &lt;em&gt;Visual mode&lt;/em&gt; 가 되며, Text 를 선택할 수 있게 된다. 선택한 Text 를 복사하고 싶으면 &lt;code&gt;Enter&lt;/code&gt; 키를 입력한다. &lt;em&gt;Copy mode&lt;/em&gt; 에서는 quit 의 의미이지만 &lt;em&gt;Visual mode&lt;/em&gt; 에서는 복사와 함꼐 quit 를 수행한다. 복사한 Text 를 붙여넣고 싶다면 &lt;code&gt;ctrl + b, ]&lt;/code&gt; 를 입력한다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ctrl + b, :&lt;/code&gt; 를 입력하여 command mode 를 실행한 후 &lt;code&gt;list-buffers&lt;/code&gt; 를 실행하면 현재 저장된 모든 buffer 들을 볼 수 있다. &lt;code&gt;choose-buffer&lt;/code&gt; 를 입력하면 모든 buffer 들의 리스트가 출력되고 원하는 buffer 를 선택할 수 있다. &lt;code&gt;show-buffer&lt;/code&gt; 를 입력하면 0번째 buffer 의 내용을 보여준다. 참고로 &lt;code&gt;ctrl + b, ]&lt;/code&gt; 는 무조건 0번째 buffer 를 붙여넣기 한다.&lt;/p&gt;
&lt;h1&gt;Start with script&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;session&lt;/em&gt; 을 만들고, 화면을 분할하고, 특정 directory 를 생성하고, 패키지를 설치하고, 기타 필요한 작업들을 script 로 작성하여 &lt;em&gt;session&lt;/em&gt; 을 생성할 때 한꺼번에 수행되도록 할 수 있다.&lt;/p&gt;
&lt;p&gt;tmux initilizing automation script example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ cat start_with_tmux.sh
&lt;span class="c1"&gt;#!/bin/bash&lt;/span&gt;
&lt;span class="nv"&gt;SESSION&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;tmuxtest
&lt;span class="nv"&gt;PROJECT_HOME&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;~/Projects&amp;quot;&lt;/span&gt;
&lt;span class="nv"&gt;PROJECT_NAME&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;1&lt;/span&gt;&lt;span class="k"&gt;:-&lt;/span&gt;&lt;span class="nv"&gt;node&lt;/span&gt;&lt;span class="p"&gt;-project&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;
&lt;span class="nv"&gt;TMUX&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;tmux&amp;quot;&lt;/span&gt;
&lt;span class="c1"&gt;# Create new session&lt;/span&gt;
&lt;span class="nv"&gt;$TMUX&lt;/span&gt; new-session -d -s &lt;span class="nv"&gt;$SESSION&lt;/span&gt;
&lt;span class="c1"&gt;# Create new windows&lt;/span&gt;
&lt;span class="nv"&gt;$TMUX&lt;/span&gt; new-window -t &lt;span class="nv"&gt;$SESSION&lt;/span&gt;:1 -n withindex
&lt;span class="nv"&gt;$TMUX&lt;/span&gt; new-window -t &lt;span class="nv"&gt;$SESSION&lt;/span&gt; -n withoutindex
&lt;span class="c1"&gt;# Select window&lt;/span&gt;
&lt;span class="nv"&gt;$TMUX&lt;/span&gt; &lt;span class="k"&gt;select&lt;/span&gt;-window -t withindex
&lt;span class="c1"&gt;# Split window&lt;/span&gt;
&lt;span class="nv"&gt;$TMUX&lt;/span&gt; split-window -h
&lt;span class="c1"&gt;# Select pane and run commands&lt;/span&gt;
&lt;span class="nv"&gt;$TMUX&lt;/span&gt; &lt;span class="k"&gt;select&lt;/span&gt;-pane -t 0
&lt;span class="nv"&gt;$TMUX&lt;/span&gt; send-keys &lt;span class="s2"&gt;&amp;quot;mkdir -p &lt;/span&gt;&lt;span class="nv"&gt;$PROJECT_HOME&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; Enter
&lt;span class="nv"&gt;$TMUX&lt;/span&gt; send-keys &lt;span class="s2"&gt;&amp;quot;cd &lt;/span&gt;&lt;span class="nv"&gt;$PROJECT_HOME&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; Enter
&lt;span class="nv"&gt;$TMUX&lt;/span&gt; send-keys &lt;span class="s2"&gt;&amp;quot;echo &amp;#39;date&amp;#39; &amp;gt; test.txt&amp;quot;&lt;/span&gt; Enter
&lt;span class="nv"&gt;$TMUX&lt;/span&gt; split-window -v
&lt;span class="c1"&gt;# C-m means Carriage Return (one of control characters)&lt;/span&gt;
&lt;span class="nv"&gt;$TMUX&lt;/span&gt; send-keys &lt;span class="s2"&gt;&amp;quot;cd &lt;/span&gt;&lt;span class="nv"&gt;$PROJECT_HOME&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; Enter
&lt;span class="nv"&gt;$TMUX&lt;/span&gt; send-keys &lt;span class="s2"&gt;&amp;quot;tail -f test.txt&amp;quot;&lt;/span&gt; C-m
&lt;span class="c1"&gt;# Select pane and run commands&lt;/span&gt;
&lt;span class="nv"&gt;$TMUX&lt;/span&gt; &lt;span class="k"&gt;select&lt;/span&gt;-pane -t 2
&lt;span class="nv"&gt;$TMUX&lt;/span&gt; send-keys &lt;span class="s2"&gt;&amp;quot;ls -ail&amp;quot;&lt;/span&gt; Enter
References
http://tmux.github.io/
https://github.com/tmux/tmux
http://haruair.com/blog/2124
http://nodeqa.com/nodejs_ref/99
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;References&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://tmux.github.io"&gt;tmux web&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/tmux/tmux"&gt;tmux github&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="tmux"></category></entry></feed>