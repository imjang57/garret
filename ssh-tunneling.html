<!doctype html>
<html lang="en">

<head>
  <!-- Required meta tags -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <title>  SSH Tunneling | garret
</title>
  <link rel="canonical" href="https://imjang57.github.io/garret/ssh-tunneling.html">


  <link rel="stylesheet" href="https://imjang57.github.io/garret/theme/css/bootstrap.min.css">
  <link rel="stylesheet" href="https://imjang57.github.io/garret/theme/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://imjang57.github.io/garret/theme/css/pygments/default.min.css">
  <link rel="stylesheet" href="https://imjang57.github.io/garret/theme/css/theme.css">

  <link rel="alternate" type="application/atom+xml" title="Full Atom Feed"
        href="https://imjang57.github.io/garret/feeds/all.atom.xml">
  <link rel="alternate" type="application/atom+xml" title="Categories Atom Feed"
        href="https://imjang57.github.io/garret/feeds/tools.atom.xml">  
  <meta name="description" content="SSH Tunneling 사용 방법">
  <script>
    (function(i, s, o, g, r, a, m) {
      i['GoogleAnalyticsObject'] = r;
      i[r] = i[r] || function() {
        (i[r].q = i[r].q || []).push(arguments)
      }, i[r].l = 1 * new Date();
      a = s.createElement(o);
      a.async = 1;
      a.src = g;
      m = s.getElementsByTagName(o)[0];
      m.parentNode.insertBefore(a, m)
    })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
    ga('create', 'UA-90095241-1', 'auto');
    ga('send', 'pageview');
  </script>


</head>

<body>
  <header class="header">
    <div class="container">
<div class="row">
  <div class="col-sm-12">
    <h1 class="title"><a href="https://imjang57.github.io/garret/">garret</a></h1>
      <ul class="list-inline">
          <li class="list-inline-item"><a href="https://github.com/imjang57" target="_blank">Github</a></li>
          <li class="list-inline-item"><a href="https://github.com/imjang57/garret" target="_blank">Github site repo</a></li>
          <li class="list-inline-item"><a href="#" target="_blank">Site</a></li>
              <li class="list-inline-item text-muted">|</li>
            <li class="list-inline-item"><a href="https://imjang57.github.io/garret/pages/about.html">About</a></li>
      </ul>
  </div>
</div>    </div>
  </header>

  <div class="main">
    <div class="container">
      <h1>  SSH Tunneling
</h1>
      <hr>
  <article class="article">
    <header>
      <ul class="list-inline">
        <li class="list-inline-item text-muted" title="2017-01-02T00:00:00+09:00">
          <i class="fa fa-clock-o"></i>
          월 02 1월 2017
        </li>
        <li class="list-inline-item">
          <i class="fa fa-folder-open-o"></i>
          <a href="https://imjang57.github.io/garret/category/tools.html">tools</a>
        </li>
          <li class="list-inline-item">
            <i class="fa fa-files-o"></i>
              <a href="https://imjang57.github.io/garret/tag/ssh.html">#ssh</a>,               <a href="https://imjang57.github.io/garret/tag/tunneling.html">#tunneling</a>          </li>
      </ul>
    </header>
    <div class="content">
      <h1>SSH Tunneling</h1>
<p>SSH(Secure SHell)는 이름에서 알 수 있듯이 보안성이 좋은 프로토콜이다. SSH는 비대칭키를 이용한 인증(Authentication), 대칭키를 이용한 데이터 암호화(Encryption), 네트웍을 통해 전송된 데이터가 변경되지 않았음을 보장하는 무결성(Integrity) 등을 제공한다.</p>
<p>이외에 SSH는 정말 유용한 기능을 제공하는데 바로 포트 포워딩(Port Forwarding)을 이용한 터널링(Tunneling)이다.</p>
<p>SSH 클라이언트가 SSH 서버에 연결되면 둘 사이에 연결이 생성되는데 이를 보통 <strong>터널(Tunnel)</strong> 이라고 한다. 그리고 이 터널은 클라이언트와 서버 사이에서 암호화로 보호되는 통로이다. 보통은 이 터널을 통해서 클라이언트와 서버가 통신하는데, 포트 포워딩이라는 기술을 사용하면 이 터널을 다른 애플리케이션들이 이용하도록 할 수가 있다. 이를 터널링이라고 한다. 터널링을 사용하면 애플리케이션은 별도로 개발할 필요 없이 SSH의 보안 통로를 사용할 수 있게 되는 것이다. 터널링은 TCP만 가능하고 UDP는 불가능하다.</p>
<p>터널링은 크게 <strong>로컬 포트 포워딩(Local Port Forwarding)</strong> 과 <strong>리모트 포트 포워딩(Remote Port Forwarding)</strong> 으로 나누어져 있다. 어디가 요청을 받고 어느 방향으로 전달해주냐에 따라 나누어 진다. 그리고 포트 포워딩을 통한 SSH 터널링은 SSH 연결이 유지되는 동안에만 사용할 수 있다.</p>
<h1>Local Port Forwarding</h1>
<p>로컬 포트 포워딩은 SSH 클라이언트가 요청을 받아 SSH 서버를 통해 다른 서버로 요청을 포워딩해주는 것이다. 로컬 포트 포워딩은 다음과 같이 실행하면 사용할 수 있다.</p>
<div class="highlight"><pre><span></span>$ ssh -L&lt;<span class="nb">local</span> port number&gt;:&lt;host&gt;:&lt;remote port number&gt; &lt;user&gt;@&lt;SSH server host&gt;<span class="o">[</span>:&lt;SSH server port&gt;<span class="o">]</span>
</pre></div>


<p><code>&lt;local port number&gt;</code>는 SSH 클라이언트가 애플리케이션을 위해 포트를 열고 대기(LISTEN)하고 있는 포트 번호이다. <code>&lt;host&gt;</code>는 애플리케이션이 최종적으로 요청을 전달하려고 하는 서버 주소이다. <code>&lt;remote port number&gt;</code>는 애플리케이션이 최종적으로 요청을 전달하려고 하는 서버의 포트 번호이다. 그리고 SSH 연결을 위해 <code>&lt;user&gt;@&lt;SSH server host&gt;</code>를 전달한다.</p>
<p>예를 들어, SSH를 통해서만 연결이 가능한 분리된 네트웍이 있다고 하자. 하나는 <code>192.168.0.0/24</code>이고 다른 하나는 <code>192.169.0.0/24</code>이다. SSH 클라이언트는 <code>192.168.0.5</code>, 애플리케이션은 <code>192.168.0.10</code>, SSH 서버는 <code>192.169.0.5:22</code>, API 서버는 <code>192.169.0.10:10050</code>일 때 로컬 호스트에서 로컬 포트 포워딩으로 API 서버에 요청을 하려면 다음과 같이 실행하면 된다.</p>
<div class="highlight"><pre><span></span>$ ssh -L10010:192.169.0.10:10050 myuser@192.169.0.5
</pre></div>


<p>그리고 애플리케이션은 <code>192.168.0.5:10010</code>으로 요청하면 SSH 터널을 통해 API 서버로 요청을 전달할 수 있다. 즉, 애플리케이션 -&gt; SSH 클라이언트 -&gt; SSH 서버 -&gt; API 서버로 전달이 되는 것이다.</p>
<h1>Remote Port Forwaring</h1>
<p>리모트 포트 포워딩은 로컬 포트 포워딩과 반대이다. SSH 서버가 요청을 받아 SSH 클라이언트를 통해 다른 서버로 요청을 포워딩해주는 것이다. 리모트 포트 포워딩은 다음과 같이 실행하면 사용할 수 있다.</p>
<div class="highlight"><pre><span></span>$ ssh -R&lt;remote port number&gt;:&lt;host&gt;:&lt;<span class="nb">local</span> port number&gt; &lt;user&gt;@&lt;SSH server host&gt;<span class="o">[</span>:&lt;SSH server port&gt;<span class="o">]</span>
</pre></div>


<p><code>&lt;remote port number&gt;</code>는 SSH 서버가 애플리케이션을 위해 포트를 열고 대기(LISTEN)하고 있는 포트 번호이다. <code>&lt;host&gt;</code>는 애플리케이션이 최종적으로 요청을 전달하려고 하는 서버 주소이다. <code>&lt;local port number&gt;</code>는 애플리케이션이 최종적으로 요청을 전달하려고 하는 서버의 포트 번호이다. 그리고 SSH 연결을 위해 <code>&lt;user&gt;@&lt;SSH server host&gt;</code>를 전달한다.</p>
<p>가만히 보면 로컬 포트 포워딩과 순서가 반대인 것을 알 수 있다. 예를 들어, 예를 들어, SSH를 통해서만 연결이 가능한 분리된 네트웍이 있다고 하자. 하나는 <code>192.168.0.0/24</code>이고 다른 하나는 <code>192.169.0.0/24</code>이다. SSH 클라이언트는 <code>192.168.0.5</code>, API 서버는 <code>192.168.0.10</code>, SSH 서버는 <code>192.169.0.5:22</code>, 애플리케이션은 <code>192.169.0.10:10050</code>일 때 로컬 호스트에서 로컬 포트 포워딩으로 API 서버에 요청을 하려면 다음과 같이 실행하면 된다.</p>
<div class="highlight"><pre><span></span>$ ssh -R10050:192.168.0.10:10010 myuser@192.169.0.5
</pre></div>


<p>그리고 애플리케이션은 <code>192.169.0.5:10050</code>으로 요청하면 SSH 터널을 통해 API 서버로 요청을 전달할 수 있다. 즉, 애플리케이션 -&gt; SSH 서버 -&gt; SSH 클라이언트 -&gt; API 서버로 전달이 되는 것이다.</p>
<h1>참고사항</h1>
<p>SSH 터널링을 이용하면 방화벽을 우회할 수 있고, SSH가 제공하는 암호화된 통신을 쉽게 다른 목적으로도 사용할 수 있다. 그러니 SSH 접근 권한과 관련된 정보(로그인 정보, SSH Key 등)를 잘 관리하자.</p>
    </div>
  </article>
    </div>
  </div>

  <footer class="footer">
    <div class="container">
<div class="row">
  <ul class="col-sm-6 list-inline">
    <li class="list-inline-item"><a href="https://imjang57.github.io/garret/archives.html">Archives</a></li>
    <li class="list-inline-item"><a href="https://imjang57.github.io/garret/categories.html">Categories</a></li>
      <li class="list-inline-item"><a href="https://imjang57.github.io/garret/tags.html">Tags</a></li>
  </ul>
  <p class="col-sm-6 text-sm-right text-muted">
    Generated by <a href="https://github.com/getpelican/pelican" target="_blank">Pelican</a>
    / <a href="https://github.com/nairobilug/pelican-alchemy" target="_blank">&#x2728;</a>
  </p>
</div>    </div>
  </footer>
</body>

</html>